/// <reference path="./custom.d.ts" />
// tslint:disable
/**
 * sevDesk
 * # Getting started  The sevDesk API v1 uses a token authentication.    You need to click on the authorization button (lock symbol) and enter your api-key there.    The token can be found on [https://my.sevdesk.de](https://my.sevdesk.de).    settings-->user-->specific user    # General information    The sevDesk api uses **models** to represent the different categories like **contacts** and **invoices**.    Every time you request such a model from the api, it will return the whole model schema including the unique **model id** and all the other objects and parameters that are included in the model.    Have a look at it in the developer console of your desired browser, especially if you are looking for specific parameters like the model id.    # URL    The basic URL contains four elements. **BaseURL** + **Controller** + **Version** + **Model**: [https://my.sevdesk.de/api/v1/Contact/](https://my.sevdesk.de/api/v1/Contact/)    # Basic Operations    Access a list of models: [https://my.sevdesk.de/api/v1/{Model}/](https://my.sevdesk.de/api/v1/{Model}/)    Access a specific model: [https://my.sevdesk.de/api/v1/{Model}/{id}](https://my.sevdesk.de/api/v1/{Model}/{id})    The **id** of a specific model can usually be found in the **developer console** of your browser or when opening a specific model, in the **url**.    Call a model function: [https://my.sevdesk.de/api/v1/{Model}/{id}/{Function}](https://my.sevdesk.de/api/v1/{Model}/{id}/{Function})    Each operation can be used with different HTTP methods:  * GET - read data  * POST - create data  * PUT - update existing data  * DELETE - delete data    # Useful Parameters    For each request, there are some specific parameters.    **GET Query Parameters**  * **limit** - limits the number of entries returned  * **offset** - set the index where the returned entries should start  * **embed** - embed can be used to get some additional information about a model. For example you can get the addresses of a contact with **embed=addresses**    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=addresses`    * If there is a need to get more information about the country in the addresses, embed can be extended by **addresses.country**    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=addresses,addresses.country`    * Some models also contain other models. By default these models are only filled with an id and objectName. If you want to get more information about the nested model you can use embed too.    `[GET]https://my.sevdesk.de/api/v1/Contact/?embed=parent`    * Every model also has specified 'query parameters'. These can be used to filter the results. E.g. all Contacts with a 'Company' in their name    `[GET]https://my.sevdesk.de/api/v1/Contact/?name=Company`    * **countAll** If countAll is set to 1 the total number of entries will be returned additionally  * **orderBy** Is an array that can be filled with objects containing the the properties field and arrangement    `json: orderBy = [{field:'parent' ,arrangement:'desc'},{field:'name' ,arrangement:'asc'}];`    `url: ?orderBy[0][field]=parent&orderBy[0][arrangement]=desc&orderBy[1][field]=name&orderBy[1][arrangement]=asc`
 *
 * OpenAPI spec version: 1.0.0
 * 
 *
 * NOTE: This file is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the file manually.
 */

import * as url from "url";
import * as isomorphicFetch from "isomorphic-fetch";
import { Configuration } from "./configuration";

const BASE_PATH = "https://my.sevdesk.de/api/v1".replace(/\/+$/, "");

/**
 *
 * @export
 */
export const COLLECTION_FORMATS = {
    csv: ",",
    ssv: " ",
    tsv: "\t",
    pipes: "|",
};

/**
 *
 * @export
 * @interface FetchAPI
 */
export interface FetchAPI {
    (url: string, init?: any): Promise<Response>;
}

/**
 *
 * @export
 * @interface FetchArgs
 */
export interface FetchArgs {
    url: string;
    options: any;
}

/**
 *
 * @export
 * @class BaseAPI
 */
export class BaseAPI {
    protected configuration: Configuration;

    constructor(configuration?: Configuration, protected basePath: string = BASE_PATH, protected fetch: FetchAPI = isomorphicFetch) {
        if (configuration) {
            this.configuration = configuration;
            this.basePath = configuration.basePath || this.basePath;
        }
    }
};

/**
 *
 * @export
 * @class RequiredError
 * @extends {Error}
 */
export class RequiredError extends Error {
    name: "RequiredError"
    constructor(public field: string, msg?: string) {
        super(msg);
    }
}

/**
 * 
 * @export
 * @interface DocServerTestLetterpaperBody
 */
export interface DocServerTestLetterpaperBody {
    /**
     * Pdf file to test
     * @type {Blob}
     * @memberof DocServerTestLetterpaperBody
     */
    file: Blob;
}
/**
 * 
 * @export
 * @interface DocServerTestLetterpaperBody1
 */
export interface DocServerTestLetterpaperBody1 {
    /**
     * Pdf file to test
     * @type {Blob}
     * @memberof DocServerTestLetterpaperBody1
     */
    file: Blob;
}
/**
 * 
 * @export
 * @interface FactoryFileUploadBody
 */
export interface FactoryFileUploadBody {
    /**
     * file to upload
     * @type {Blob}
     * @memberof FactoryFileUploadBody
     */
    file: Blob;
}
/**
 * 
 * @export
 * @interface FactoryUploadTempFileBody
 */
export interface FactoryUploadTempFileBody {
    /**
     * file to upload
     * @type {Blob}
     * @memberof FactoryUploadTempFileBody
     */
    file: Blob;
}
/**
 * 
 * @export
 * @interface ModelAccountingChart
 */
export interface ModelAccountingChart {
    /**
     * creation date of the accounting chart
     * @type {Date}
     * @memberof ModelAccountingChart
     */
    create?: Date;
    /**
     * date the accounting chart was last updated
     * @type {Date}
     * @memberof ModelAccountingChart
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelAccountingChart
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingChart
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelAccountingContact
 */
export interface ModelAccountingContact {
    /**
     * date the accounting contact was created
     * @type {Date}
     * @memberof ModelAccountingContact
     */
    create?: Date;
    /**
     * date the accounting contact was last updated
     * @type {Date}
     * @memberof ModelAccountingContact
     */
    update?: Date;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelAccountingContact
     */
    contact?: ModelContact;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingContact
     */
    contactName?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelAccountingContact
     */
    sevClient?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingContact
     */
    debitorNumber?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingContact
     */
    creditorNumber?: number;
}
/**
 * 
 * @export
 * @interface ModelAccountingCorrection
 */
export interface ModelAccountingCorrection {
    /**
     * date the accounting correction was created
     * @type {Date}
     * @memberof ModelAccountingCorrection
     */
    create?: Date;
    /**
     * date the accounting correction was last updated
     * @type {Date}
     * @memberof ModelAccountingCorrection
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelAccountingCorrection
     */
    sevClient?: any;
    /**
     * object which is involved in the correction (eg. an invoice)
     * @type {any}
     * @memberof ModelAccountingCorrection
     */
    object?: any;
    /**
     * accounting type affected by the accounting correction
     * @type {any}
     * @memberof ModelAccountingCorrection
     */
    accountingType?: any;
    /**
     * amount of the correction
     * @type {number}
     * @memberof ModelAccountingCorrection
     */
    ammount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelAccountingCorrection
     */
    enshrined?: boolean;
}
/**
 * 
 * @export
 * @interface ModelAccountingIndex
 */
export interface ModelAccountingIndex {
    /**
     * date the accounting index was created
     * @type {Date}
     * @memberof ModelAccountingIndex
     */
    sevClient?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingIndex
     */
    keyword?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelAccountingIndex
     */
    accountingType?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingIndex
     */
    taxType?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelAccountingIndex
     */
    country?: any;
}
/**
 * 
 * @export
 * @interface ModelAccountingSystem
 */
export interface ModelAccountingSystem {
    /**
     * creation date of the accounting system
     * @type {Date}
     * @memberof ModelAccountingSystem
     */
    create?: Date;
    /**
     * date the accounting system was last updated
     * @type {Date}
     * @memberof ModelAccountingSystem
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {string}
     * @memberof ModelAccountingSystem
     */
    sevClient?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingSystem
     */
    name?: string;
    /**
     * 
     * @type {ModelAccountingChart}
     * @memberof ModelAccountingSystem
     */
    accountingChart?: ModelAccountingChart;
}
/**
 * 
 * @export
 * @interface ModelAccountingSystemNumber
 */
export interface ModelAccountingSystemNumber {
    /**
     * date the accounting system number was created
     * @type {Date}
     * @memberof ModelAccountingSystemNumber
     */
    create?: Date;
    /**
     * date the accounting system number was last updated
     * @type {Date}
     * @memberof ModelAccountingSystemNumber
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelAccountingSystemNumber
     */
    sevClient?: any;
    /**
     * accounting system number
     * @type {number}
     * @memberof ModelAccountingSystemNumber
     */
    number?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingSystemNumber
     */
    numberDepreciation?: number;
    /**
     * 
     * @type {ModelAccountingType}
     * @memberof ModelAccountingSystemNumber
     */
    accountingType?: ModelAccountingType;
    /**
     * 
     * @type {ModelAccountingSystem}
     * @memberof ModelAccountingSystemNumber
     */
    accountingSystem?: ModelAccountingSystem;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingSystemNumber
     */
    bookingType?: string;
}
/**
 * 
 * @export
 * @interface ModelAccountingType
 */
export interface ModelAccountingType {
    /**
     * date the accounting type was created
     * @type {Date}
     * @memberof ModelAccountingType
     */
    create?: Date;
    /**
     * date the accounting type was last updated
     * @type {Date}
     * @memberof ModelAccountingType
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelAccountingType
     */
    sevClient?: any;
    /**
     * 
     * @type {ModelAccountingType}
     * @memberof ModelAccountingType
     */
    parent?: ModelAccountingType;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingType
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skr03?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skr03Deprecation?: number;
    /**
     * 
     * @type {ModelAccountingChart}
     * @memberof ModelAccountingType
     */
    accountingChart?: ModelAccountingChart;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skr04?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skr04Deprecation?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skrAt?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skrAtDeprecation?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skrCh?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skrChDeprecation?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skrGr?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    skrGrDeprecation?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingType
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingType
     */
    translationCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingType
     */
    descriptionTranslationCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingType
     */
    connotationTranslationCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingType
     */
    bookingType?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelAccountingType
     */
    assetType?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelAccountingType
     */
    status?: number;
}
/**
 * 
 * @export
 * @interface ModelAccountingTypeFactory
 */
export interface ModelAccountingTypeFactory {
    /**
     * 
     * @type {ModelAccountingType}
     * @memberof ModelAccountingTypeFactory
     */
    accountingType?: ModelAccountingType;
}
/**
 * 
 * @export
 * @interface ModelAggregator
 */
export interface ModelAggregator {
}
/**
 * 
 * @export
 * @interface ModelAsset
 */
export interface ModelAsset {
    /**
     * date the asset was created
     * @type {Date}
     * @memberof ModelAsset
     */
    create?: Date;
    /**
     * date the asset was last updated
     * @type {Date}
     * @memberof ModelAsset
     */
    update?: Date;
    /**
     * 
     * @type {ModelVoucherPos}
     * @memberof ModelAsset
     */
    voucherPos?: ModelVoucherPos;
    /**
     * 
     * @type {string}
     * @memberof ModelAsset
     */
    name?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelAsset
     */
    sevClient?: any;
    /**
     * lifespan of the asset
     * @type {number}
     * @memberof ModelAsset
     */
    usefulLife?: number;
    /**
     * date the asset was acquired
     * @type {Date}
     * @memberof ModelAsset
     */
    acquisitionDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof ModelAsset
     */
    purchasePrice?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAsset
     */
    purchasePriceAccounting?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAsset
     */
    taxRate?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelAsset
     */
    assetNumber?: string;
    /**
     * 
     * @type {ModelAccountingType}
     * @memberof ModelAsset
     */
    accountingType?: ModelAccountingType;
    /**
     * 
     * @type {number}
     * @memberof ModelAsset
     */
    status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelAsset
     */
    enshrined?: boolean;
}
/**
 * 
 * @export
 * @interface ModelAssetPos
 */
export interface ModelAssetPos {
    /**
     * date the asset position was created
     * @type {Date}
     * @memberof ModelAssetPos
     */
    create?: Date;
    /**
     * date the asset position was last updated
     * @type {Date}
     * @memberof ModelAssetPos
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelAssetPos
     */
    sevClient?: any;
    /**
     * asset the asset position belongs to
     * @type {any}
     * @memberof ModelAssetPos
     */
    asset?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelAssetPos
     */
    year?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAssetPos
     */
    depreciationAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAssetPos
     */
    residualValue?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelAssetPos
     */
    month?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelAssetPos
     */
    enshrined?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelAssetPos
     */
    correction?: boolean;
}
/**
 * 
 * @export
 * @interface ModelCategory
 */
export interface ModelCategory {
    /**
     * creation date of the category
     * @type {Date}
     * @memberof ModelCategory
     */
    create?: Date;
    /**
     * date the category was last updated
     * @type {Date}
     * @memberof ModelCategory
     */
    update?: Date;
    /**
     * 
     * @type {ModelCategory}
     * @memberof ModelCategory
     */
    parent?: ModelCategory;
    /**
     * 
     * @type {string}
     * @memberof ModelCategory
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCategory
     */
    objectType?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelCategory
     */
    priority?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCategory
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCategory
     */
    color?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelCategory
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelCategory
     */
    postingAccount?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCategory
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCategory
     */
    translationCode?: string;
    /**
     * 
     * @type {ModelEntryType}
     * @memberof ModelCategory
     */
    entryType?: ModelEntryType;
}
/**
 * 
 * @export
 * @interface ModelCheckAccount
 */
export interface ModelCheckAccount {
    /**
     * date the CheckAccount was created
     * @type {Date}
     * @memberof ModelCheckAccount
     */
    create?: Date;
    /**
     * date the CheckAccount was last updated
     * @type {Date}
     * @memberof ModelCheckAccount
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelCheckAccount
     */
    sevClient?: any;
    /**
     * name of the CheckAccount
     * @type {string}
     * @memberof ModelCheckAccount
     */
    name?: string;
    /**
     * type of the CheckAccount
     * @type {string}
     * @memberof ModelCheckAccount
     */
    type?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccount
     */
    importType?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccount
     */
    currency?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccount
     */
    checkAccId?: string;
    /**
     * boolean showing whether this account is the default account or not
     * @type {string}
     * @memberof ModelCheckAccount
     */
    defaultAccount?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelCheckAccount
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccount
     */
    translationCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccount
     */
    bankServer?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelCheckAccount
     */
    balance?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelCheckAccount
     */
    accountingNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccount
     */
    iban?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccount
     */
    bic?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelCheckAccount
     */
    baseAccount?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelCheckAccount
     */
    priority?: number;
}
/**
 * 
 * @export
 * @interface ModelCheckAccountTransaction
 */
export interface ModelCheckAccountTransaction {
    /**
     * date the check account transaction was created
     * @type {Date}
     * @memberof ModelCheckAccountTransaction
     */
    create?: Date;
    /**
     * date the check account transaction was last updated
     * @type {Date}
     * @memberof ModelCheckAccountTransaction
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelCheckAccountTransaction
     */
    sevClient?: any;
    /**
     * 
     * @type {Date}
     * @memberof ModelCheckAccountTransaction
     */
    valueDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ModelCheckAccountTransaction
     */
    entryDate?: Date;
    /**
     * amount of the transaction
     * @type {number}
     * @memberof ModelCheckAccountTransaction
     */
    amount?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    gvCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    entryText?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    primaNotaNo?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    paymtPurpose?: string;
    /**
     * payer bank code
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    payeePayerBankCode?: string;
    /**
     * payer account number
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    payeePayerAcctNo?: string;
    /**
     * payer name
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    payeePayerName?: string;
    /**
     * 
     * @type {ModelCheckAccount}
     * @memberof ModelCheckAccountTransaction
     */
    checkAccount?: ModelCheckAccount;
    /**
     * 
     * @type {number}
     * @memberof ModelCheckAccountTransaction
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    score?: string;
    /**
     * hash to be compared
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    compareHash?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelCheckAccountTransaction
     */
    entryType?: any;
    /**
     * 
     * @type {boolean}
     * @memberof ModelCheckAccountTransaction
     */
    enshrined?: boolean;
    /**
     * source check account transaction used for transfers
     * @type {any}
     * @memberof ModelCheckAccountTransaction
     */
    sourceTransaction?: any;
    /**
     * destination check account transaction used for transfers
     * @type {any}
     * @memberof ModelCheckAccountTransaction
     */
    targetTransaction?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelCheckAccountTransaction
     */
    obonoReceiptUuid?: string;
}
/**
 * 
 * @export
 * @interface ModelCheckAccountTransactionLog
 */
export interface ModelCheckAccountTransactionLog {
    /**
     * date the check account transaction log was created
     * @type {Date}
     * @memberof ModelCheckAccountTransactionLog
     */
    create?: Date;
    /**
     * 
     * @type {ModelCheckAccountTransaction}
     * @memberof ModelCheckAccountTransactionLog
     */
    checkAccountTransaction?: ModelCheckAccountTransaction;
    /**
     * the status before the logged change
     * @type {number}
     * @memberof ModelCheckAccountTransactionLog
     */
    fromStatus?: number;
    /**
     * the status after the logged change
     * @type {number}
     * @memberof ModelCheckAccountTransactionLog
     */
    toStatus?: number;
    /**
     * the logged amount which was paid
     * @type {number}
     * @memberof ModelCheckAccountTransactionLog
     */
    amountPaid?: number;
    /**
     * 
     * @type {Date}
     * @memberof ModelCheckAccountTransactionLog
     */
    bookingDate?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelCheckAccountTransactionLog
     */
    sevClient?: any;
    /**
     * Invoice/Voucher to which the logged transaction belongs
     * @type {any}
     * @memberof ModelCheckAccountTransactionLog
     */
    object?: any;
}
/**
 * 
 * @export
 * @interface ModelCommunicationWay
 */
export interface ModelCommunicationWay {
    /**
     * date the communication way was created
     * @type {Date}
     * @memberof ModelCommunicationWay
     */
    create?: Date;
    /**
     * date the communication way was last updated
     * @type {Date}
     * @memberof ModelCommunicationWay
     */
    update?: Date;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelCommunicationWay
     */
    contact?: ModelContact;
    /**
     * type of the communication way
     * @type {string}
     * @memberof ModelCommunicationWay
     */
    type?: ModelCommunicationWay.TypeEnum;
    /**
     * value of the communication way
     * @type {string}
     * @memberof ModelCommunicationWay
     */
    value?: string;
    /**
     * 
     * @type {ModelCommunicationWayKey}
     * @memberof ModelCommunicationWay
     */
    key?: ModelCommunicationWayKey;
    /**
     * 
     * @type {boolean}
     * @memberof ModelCommunicationWay
     */
    main?: boolean;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelCommunicationWay
     */
    sevClient?: any;
}

/**
 * @export
 * @namespace ModelCommunicationWay
 */
export namespace ModelCommunicationWay {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        EMAIL = <any> 'EMAIL',
        PHONE = <any> 'PHONE',
        WEB = <any> 'WEB',
        MOBILE = <any> 'MOBILE'
    }
}
/**
 * CommunicationWayKey is read only
 * @export
 * @interface ModelCommunicationWayKey
 */
export interface ModelCommunicationWayKey {
    /**
     * date the communication way key was created
     * @type {Date}
     * @memberof ModelCommunicationWayKey
     */
    create?: Date;
    /**
     * date the communication way key was last updated
     * @type {Date}
     * @memberof ModelCommunicationWayKey
     */
    update?: Date;
    /**
     * name of the communication way key
     * @type {string}
     * @memberof ModelCommunicationWayKey
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCommunicationWayKey
     */
    translationCode?: string;
}
/**
 * 
 * @export
 * @interface ModelContact
 */
export interface ModelContact {
    /**
     * 
     * @type {ModelContactAddress}
     * @memberof ModelContact
     */
    address?: ModelContactAddress;
    /**
     * the creation date of the contact
     * @type {Date}
     * @memberof ModelContact
     */
    create?: Date;
    /**
     * date, the contact was last updated
     * @type {Date}
     * @memberof ModelContact
     */
    update?: Date;
    /**
     * name of the contact
     * @type {string}
     * @memberof ModelContact
     */
    name?: string;
    /**
     * status of the contact
     * @type {number}
     * @memberof ModelContact
     */
    status?: number;
    /**
     * customer number of the contact
     * @type {number}
     * @memberof ModelContact
     */
    customerNumber?: number;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelContact
     */
    parent?: ModelContact;
    /**
     * surname of the contact
     * @type {string}
     * @memberof ModelContact
     */
    surename?: string;
    /**
     * family name of the contact
     * @type {string}
     * @memberof ModelContact
     */
    familyname?: string;
    /**
     * title of the contact
     * @type {string}
     * @memberof ModelContact
     */
    titel?: string;
    /**
     * 
     * @type {ModelCategory}
     * @memberof ModelContact
     */
    category?: ModelCategory;
    /**
     * description of the contact
     * @type {string}
     * @memberof ModelContact
     */
    description?: string;
    /**
     * any academic title of the contact
     * @type {string}
     * @memberof ModelContact
     */
    academicTitle?: string;
    /**
     * gender of the contact
     * @type {string}
     * @memberof ModelContact
     */
    gender?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelContact
     */
    sevClient?: any;
    /**
     * second name of the contact
     * @type {string}
     * @memberof ModelContact
     */
    name2?: string;
    /**
     * birthday of the contact
     * @type {Date}
     * @memberof ModelContact
     */
    birthday?: Date;
    /**
     * vat number of the contact
     * @type {string}
     * @memberof ModelContact
     */
    vatNumber?: string;
    /**
     * bank account of the contact
     * @type {string}
     * @memberof ModelContact
     */
    bankAccount?: string;
    /**
     * bank number of the contact
     * @type {string}
     * @memberof ModelContact
     */
    bankNumber?: string;
    /**
     * 
     * @type {ModelPaymentMethod}
     * @memberof ModelContact
     */
    paymentMethod?: ModelPaymentMethod;
    /**
     * 
     * @type {ModelEntryType}
     * @memberof ModelContact
     */
    entryType?: ModelEntryType;
    /**
     * default cashback time of the contact
     * @type {number}
     * @memberof ModelContact
     */
    defaultCashbackTime?: number;
    /**
     * default cashback percentage of the contact
     * @type {number}
     * @memberof ModelContact
     */
    defaultCashbackPercent?: number;
    /**
     * default time to pay of the contact
     * @type {number}
     * @memberof ModelContact
     */
    defaultTimeToPay?: number;
    /**
     * tax number of the contact
     * @type {string}
     * @memberof ModelContact
     */
    taxNumber?: string;
    /**
     * tax office of the contact
     * @type {string}
     * @memberof ModelContact
     */
    taxOffice?: string;
}
/**
 * 
 * @export
 * @interface ModelContactAddress
 */
export interface ModelContactAddress {
    /**
     * the creation date of the contact
     * @type {Date}
     * @memberof ModelContactAddress
     */
    create?: Date;
    /**
     * date, the contact was last updated
     * @type {Date}
     * @memberof ModelContactAddress
     */
    update?: Date;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelContactAddress
     */
    contact?: ModelContact;
    /**
     * 
     * @type {string}
     * @memberof ModelContactAddress
     */
    street?: string;
    /**
     * zip of the city/village
     * @type {string}
     * @memberof ModelContactAddress
     */
    zip?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelContactAddress
     */
    city?: string;
    /**
     * 
     * @type {ModelStaticCountry}
     * @memberof ModelContactAddress
     */
    country?: ModelStaticCountry;
    /**
     * 
     * @type {ModelCategory}
     * @memberof ModelContactAddress
     */
    category?: ModelCategory;
    /**
     * 
     * @type {string}
     * @memberof ModelContactAddress
     */
    name?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelContactAddress
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelContactAddress
     */
    name2?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelContactAddress
     */
    name3?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelContactAddress
     */
    name4?: string;
}
/**
 * Below are the models which can be used for the functions in Contact/Factory.php. Beware that you need to use them without the underscore at the beginning!
 * @export
 * @interface ModelContactFactory
 */
export interface ModelContactFactory {
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelContactFactory
     */
    contact?: ModelContact;
}
/**
 * 
 * @export
 * @interface ModelCostCentre
 */
export interface ModelCostCentre {
    /**
     * date the cost centre was created
     * @type {Date}
     * @memberof ModelCostCentre
     */
    create?: Date;
    /**
     * date the cost centre was last updated
     * @type {Date}
     * @memberof ModelCostCentre
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelCostCentre
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelCostCentre
     */
    number?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCostCentre
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCostCentre
     */
    color?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelCostCentre
     */
    postingAccount?: string;
}
/**
 * 
 * @export
 * @interface ModelCurrencyExchangeRate
 */
export interface ModelCurrencyExchangeRate {
    /**
     * date of the currency exchange rate
     * @type {Date}
     * @memberof ModelCurrencyExchangeRate
     */
    date?: Date;
    /**
     * currency which is rated
     * @type {string}
     * @memberof ModelCurrencyExchangeRate
     */
    currency?: string;
    /**
     * rate of the currency compared to EUR
     * @type {number}
     * @memberof ModelCurrencyExchangeRate
     */
    rate?: number;
}
/**
 * 
 * @export
 * @interface ModelDiscounts
 */
export interface ModelDiscounts {
    /**
     * date the discount was created
     * @type {Date}
     * @memberof ModelDiscounts
     */
    create?: Date;
    /**
     * date the discount was last updated
     * @type {Date}
     * @memberof ModelDiscounts
     */
    update?: Date;
    /**
     * object to which the discount belongs
     * @type {any}
     * @memberof ModelDiscounts
     */
    object?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelDiscounts
     */
    sevClient?: any;
    /**
     * specifies if a discount is enabled
     * @type {boolean}
     * @memberof ModelDiscounts
     */
    discount?: boolean;
    /**
     * description of the discount
     * @type {string}
     * @memberof ModelDiscounts
     */
    text?: string;
    /**
     * specifies if discount is of type percentage, otherwise its a value
     * @type {boolean}
     * @memberof ModelDiscounts
     */
    percentage?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelDiscounts
     */
    value?: number;
}
/**
 * 
 * @export
 * @interface ModelDocServer
 */
export interface ModelDocServer {
}
/**
 * 
 * @export
 * @interface ModelDocument
 */
export interface ModelDocument {
    /**
     * date the document was created
     * @type {Date}
     * @memberof ModelDocument
     */
    create?: Date;
    /**
     * date the document was last updated
     * @type {Date}
     * @memberof ModelDocument
     */
    update?: Date;
    /**
     * 
     * @type {any}
     * @memberof ModelDocument
     */
    object?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelDocument
     */
    documentNumber?: string;
    /**
     * 
     * @type {Date}
     * @memberof ModelDocument
     */
    baseObject?: Date;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelDocument
     */
    createUser?: ModelSevUser;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelDocument
     */
    updateUser?: ModelSevUser;
    /**
     * 
     * @type {string}
     * @memberof ModelDocument
     */
    mimeType?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelDocument
     */
    description?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelDocument
     */
    objectAction?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelDocument
     */
    sevClient?: any;
    /**
     * 
     * @type {ModelDocumentFolder}
     * @memberof ModelDocument
     */
    folder?: ModelDocumentFolder;
    /**
     * 
     * @type {string}
     * @memberof ModelDocument
     */
    filename?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelDocument
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelDocument
     */
    extension?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelDocument
     */
    filesize?: number;
}
/**
 * Below are the models which can be used for the functions in Document/Factory.php. Beware that you need to use them without the underscore at the beginning!
 * @export
 * @interface ModelDocumentFactory
 */
export interface ModelDocumentFactory {
    /**
     * 
     * @type {ModelDocument}
     * @memberof ModelDocumentFactory
     */
    modelDocument?: ModelDocument;
}
/**
 * 
 * @export
 * @interface ModelDocumentFolder
 */
export interface ModelDocumentFolder {
    /**
     * date the document folder was created
     * @type {Date}
     * @memberof ModelDocumentFolder
     */
    create?: Date;
    /**
     * date the document folder was last updated
     * @type {Date}
     * @memberof ModelDocumentFolder
     */
    update?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelDocumentFolder
     */
    name?: string;
    /**
     * 
     * @type {ModelDocumentFolder}
     * @memberof ModelDocumentFolder
     */
    parent?: ModelDocumentFolder;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelDocumentFolder
     */
    sevClient?: any;
    /**
     * 
     * @type {any}
     * @memberof ModelDocumentFolder
     */
    object?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelDocumentFolder
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelDocumentFolder
     */
    translationCode?: string;
}
/**
 * 
 * @export
 * @interface ModelDocumentIndex
 */
export interface ModelDocumentIndex {
    /**
     * date the document index was created
     * @type {Date}
     * @memberof ModelDocumentIndex
     */
    create?: Date;
    /**
     * date the document index was last updated
     * @type {Date}
     * @memberof ModelDocumentIndex
     */
    update?: Date;
    /**
     * user that created the document index
     * @type {any}
     * @memberof ModelDocumentIndex
     */
    user?: any;
    /**
     * the document to which the index belongs
     * @type {any}
     * @memberof ModelDocumentIndex
     */
    document?: any;
    /**
     * index
     * @type {number}
     * @memberof ModelDocumentIndex
     */
    index?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelDocumentIndex
     */
    name?: string;
    /**
     * status of the document index
     * @type {number}
     * @memberof ModelDocumentIndex
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelDocumentIndex
     */
    extension?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelDocumentIndex
     */
    mimeType?: string;
    /**
     * sevClient that created the document index
     * @type {any}
     * @memberof ModelDocumentIndex
     */
    sevClient?: any;
}
/**
 * 
 * @export
 * @interface ModelEmail
 */
export interface ModelEmail {
    /**
     * creation date of the Email
     * @type {Date}
     * @memberof ModelEmail
     */
    create?: Date;
    /**
     * date the email was last updated
     * @type {Date}
     * @memberof ModelEmail
     */
    update?: Date;
    /**
     * 
     * @type {ModelInvoice}
     * @memberof ModelEmail
     */
    object?: ModelInvoice;
    /**
     * sender of the email
     * @type {string}
     * @memberof ModelEmail
     */
    from?: string;
    /**
     * recipient of the email
     * @type {string}
     * @memberof ModelEmail
     */
    to?: string;
    /**
     * subject of the email
     * @type {string}
     * @memberof ModelEmail
     */
    subject?: string;
    /**
     * text written in the email
     * @type {string}
     * @memberof ModelEmail
     */
    text?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelEmail
     */
    sevClient?: any;
    /**
     * cc of the email
     * @type {string}
     * @memberof ModelEmail
     */
    cc?: string;
    /**
     * bcc of the email
     * @type {string}
     * @memberof ModelEmail
     */
    bcc?: string;
    /**
     * arrival date of the email
     * @type {Date}
     * @memberof ModelEmail
     */
    arrived?: Date;
}
/**
 * 
 * @export
 * @interface ModelEntryType
 */
export interface ModelEntryType {
    /**
     * date the entry type was created
     * @type {Date}
     * @memberof ModelEntryType
     */
    create?: Date;
    /**
     * date the entry type was last updated
     * @type {Date}
     * @memberof ModelEntryType
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelEntryType
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelEntryType
     */
    name?: string;
}
/**
 * 
 * @export
 * @interface ModelExport
 */
export interface ModelExport {
}
/**
 * 
 * @export
 * @interface ModelFeed
 */
export interface ModelFeed {
    /**
     * creation date of the feed
     * @type {Date}
     * @memberof ModelFeed
     */
    create?: Date;
    /**
     * date the feed was last updated
     * @type {Date}
     * @memberof ModelFeed
     */
    update?: Date;
    /**
     * 
     * @type {any}
     * @memberof ModelFeed
     */
    object?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelFeed
     */
    text?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelFeed
     */
    type?: any;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelFeed
     */
    user?: ModelSevUser;
    /**
     * 
     * @type {any}
     * @memberof ModelFeed
     */
    objectAction?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelFeed
     */
    sevClient?: any;
}
/**
 * 
 * @export
 * @interface ModelHelp
 */
export interface ModelHelp {
}
/**
 * The inventory part log contains all part bookings (acquisition/dispatch)
 * @export
 * @interface ModelInventoryPartLog
 */
export interface ModelInventoryPartLog {
    /**
     * creation date of the inventory part log
     * @type {Date}
     * @memberof ModelInventoryPartLog
     */
    create?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ModelInventoryPartLog
     */
    postingDate?: Date;
    /**
     * part which is involved in the part booking which is logged
     * @type {any}
     * @memberof ModelInventoryPartLog
     */
    part?: any;
    /**
     * supplier which is involved in the part booking which is logged
     * @type {any}
     * @memberof ModelInventoryPartLog
     */
    supplier?: any;
    /**
     * amount booked which is logged
     * @type {number}
     * @memberof ModelInventoryPartLog
     */
    ammount?: number;
    /**
     * description of the booking which is logged
     * @type {string}
     * @memberof ModelInventoryPartLog
     */
    name?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelInventoryPartLog
     */
    sevClient?: any;
    /**
     * 
     * @type {any}
     * @memberof ModelInventoryPartLog
     */
    object?: any;
}
/**
 * 
 * @export
 * @interface ModelInvoice
 */
export interface ModelInvoice {
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    invoiceNumber?: string;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelInvoice
     */
    contact?: ModelContact;
    /**
     * the date the invoice was created
     * @type {Date}
     * @memberof ModelInvoice
     */
    create?: Date;
    /**
     * the date the invoice was last updated
     * @type {Date}
     * @memberof ModelInvoice
     */
    update?: Date;
    /**
     * the date of the invoice
     * @type {Date}
     * @memberof ModelInvoice
     */
    invoiceDate?: Date;
    /**
     * header/subject of the invoice
     * @type {string}
     * @memberof ModelInvoice
     */
    header?: string;
    /**
     * head text of the invoice
     * @type {string}
     * @memberof ModelInvoice
     */
    headText?: string;
    /**
     * foot text of the invoice
     * @type {string}
     * @memberof ModelInvoice
     */
    footText?: string;
    /**
     * time left for paying the invoice, use format dd.MM.yyyy or number for number of days left
     * @type {Date}
     * @memberof ModelInvoice
     */
    timeToPay?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ModelInvoice
     */
    discountTime?: Date;
    /**
     * the discount value in '%'
     * @type {number}
     * @memberof ModelInvoice
     */
    discount?: number;
    /**
     * the name in the address, equals the contacts name
     * @type {string}
     * @memberof ModelInvoice
     */
    addressName?: string;
    /**
     * the street in the address, equals the contacts street
     * @type {string}
     * @memberof ModelInvoice
     */
    addressStreet?: string;
    /**
     * the zip-code in the address, equals the contacts zip
     * @type {string}
     * @memberof ModelInvoice
     */
    addressZip?: string;
    /**
     * the city in the address, equals the contacts city
     * @type {string}
     * @memberof ModelInvoice
     */
    addressCity?: string;
    /**
     * 
     * @type {ModelStaticCountry}
     * @memberof ModelInvoice
     */
    addressCountry?: ModelStaticCountry;
    /**
     * time left for paying the invoice, use format DD.MM.YYYY or number for number of days left
     * @type {Date}
     * @memberof ModelInvoice
     */
    payDate?: Date;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelInvoice
     */
    createUser?: ModelSevUser;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelInvoice
     */
    sevClient?: any;
    /**
     * delivery date of the goods from the invoice, please use dd.MM.yyyy
     * @type {Date}
     * @memberof ModelInvoice
     */
    deliveryDate?: Date;
    /**
     * status of the invoice
     * @type {number}
     * @memberof ModelInvoice
     */
    status?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelInvoice
     */
    smallSettlement?: boolean;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelInvoice
     */
    contactPerson?: ModelSevUser;
    /**
     * tax rate used when adding a value added tax regulation
     * @type {number}
     * @memberof ModelInvoice
     */
    taxRate?: number;
    /**
     * additional text when adding a value added tax regulation
     * @type {string}
     * @memberof ModelInvoice
     */
    taxText?: ModelInvoice.TaxTextEnum;
    /**
     * dunning level of the invoice
     * @type {number}
     * @memberof ModelInvoice
     */
    dunningLevel?: number;
    /**
     * name of the contacts address
     * @type {string}
     * @memberof ModelInvoice
     */
    addressParentName?: string;
    /**
     * 
     * @type {ModelContactAddress}
     * @memberof ModelInvoice
     */
    addressContactRef?: ModelContactAddress;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    taxType?: ModelInvoice.TaxTypeEnum;
    /**
     * 
     * @type {ModelPaymentMethod}
     * @memberof ModelInvoice
     */
    paymentMethod?: ModelPaymentMethod;
    /**
     * 
     * @type {ModelCostCentre}
     * @memberof ModelInvoice
     */
    costCentre?: ModelCostCentre;
    /**
     * 
     * @type {Date}
     * @memberof ModelInvoice
     */
    sendDate?: Date;
    /**
     * 
     * @type {any}
     * @memberof ModelInvoice
     */
    origin?: any;
    /**
     * type of the invoice
     * @type {string}
     * @memberof ModelInvoice
     */
    invoiceType?: ModelInvoice.InvoiceTypeEnum;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    accountIntervall?: number;
    /**
     * 
     * @type {Date}
     * @memberof ModelInvoice
     */
    accountLastInvoice?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ModelInvoice
     */
    accountNextInvoice?: Date;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    reminderTotal?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    reminderDebit?: number;
    /**
     * 
     * @type {Date}
     * @memberof ModelInvoice
     */
    reminderDeadline?: Date;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    reminderCharge?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    addressParentName2?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    addressName2?: string;
    /**
     * 
     * @type {ModelTaxSet}
     * @memberof ModelInvoice
     */
    taxSet?: ModelTaxSet;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    addressGender?: string;
    /**
     * 
     * @type {Date}
     * @memberof ModelInvoice
     */
    accountEndDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumNet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumTax?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumGross?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumDiscounts?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumNetForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumTaxForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumGrossForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumDiscountsForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumNetAccounting?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumTaxAccounting?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoice
     */
    sumGrossAccounting?: number;
    /**
     * 
     * @type {ModelEntryType}
     * @memberof ModelInvoice
     */
    entryType?: ModelEntryType;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    costumerInternalNote?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelInvoice
     */
    showNet?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelInvoice
     */
    enshrined?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoice
     */
    sendType?: string;
    /**
     * 
     * @type {Date}
     * @memberof ModelInvoice
     */
    deliveryDateUntil?: Date;
}

/**
 * @export
 * @namespace ModelInvoice
 */
export namespace ModelInvoice {
    /**
     * @export
     * @enum {string}
     */
    export enum TaxTextEnum {
        UmsatzsteuerAusweisen = <any> 'Umsatzsteuer ausweisen',
        SteuerfreieInnergemeinschaftlicheLieferungEuropischeUnion = <any> 'Steuerfreie innergemeinschaftliche Lieferung(Europäische Union)',
        SteuerschuldnerschaftDesLeistungsempfngersAuerhalbEUZBSchweiz = <any> 'Steuerschuldnerschaft des Leistungsempfängers (Außerhalb EU, z.B. Schweiz)'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TaxTypeEnum {
        Default = <any> 'default',
        Eu = <any> 'eu',
        Noteu = <any> 'noteu'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum InvoiceTypeEnum {
        REInvoice = <any> 'RE (Invoice)',
        MAInvoiceReminder = <any> 'MA (Invoice reminder)',
        WKRPeriodicInvoice = <any> 'WKR (periodic invoice)'
    }
}
/**
 * Below are the models which can be used for the functions in Invoice/Factory.php. Beware that you need to use them without the underscore at the beginning!
 * @export
 * @interface ModelInvoiceFactory
 */
export interface ModelInvoiceFactory {
    /**
     * 
     * @type {ModelInvoice}
     * @memberof ModelInvoiceFactory
     */
    invoice?: ModelInvoice;
    /**
     * 
     * @type {ModelInvoice}
     * @memberof ModelInvoiceFactory
     */
    invoicePosSave?: ModelInvoice;
    /**
     * 
     * @type {ModelInvoice}
     * @memberof ModelInvoiceFactory
     */
    invoicePosDelete?: ModelInvoice;
    /**
     * 
     * @type {ModelDiscounts}
     * @memberof ModelInvoiceFactory
     */
    discountSave?: ModelDiscounts;
    /**
     * 
     * @type {ModelDiscounts}
     * @memberof ModelInvoiceFactory
     */
    discountDelete?: ModelDiscounts;
}
/**
 * 
 * @export
 * @interface ModelInvoiceLog
 */
export interface ModelInvoiceLog {
    /**
     * date the invoice log was created
     * @type {Date}
     * @memberof ModelInvoiceLog
     */
    create?: Date;
    /**
     * the invoice which is logged
     * @type {any}
     * @memberof ModelInvoiceLog
     */
    invoice?: any;
    /**
     * status before the change
     * @type {number}
     * @memberof ModelInvoiceLog
     */
    fromStatus?: number;
    /**
     * status after the change
     * @type {number}
     * @memberof ModelInvoiceLog
     */
    toStatus?: number;
    /**
     * amount that was payed
     * @type {number}
     * @memberof ModelInvoiceLog
     */
    ammountPayed?: number;
    /**
     * date of the booking
     * @type {Date}
     * @memberof ModelInvoiceLog
     */
    bookingDate?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelInvoiceLog
     */
    sevClient?: any;
}
/**
 * 
 * @export
 * @interface ModelInvoicePos
 */
export interface ModelInvoicePos {
    /**
     * creation date of the invoice position
     * @type {Date}
     * @memberof ModelInvoicePos
     */
    create?: Date;
    /**
     * date the invoice position was last updated
     * @type {Date}
     * @memberof ModelInvoicePos
     */
    update?: Date;
    /**
     * 
     * @type {ModelInvoice}
     * @memberof ModelInvoicePos
     */
    invoice?: ModelInvoice;
    /**
     * 
     * @type {ModelPart}
     * @memberof ModelInvoicePos
     */
    part?: ModelPart;
    /**
     * the quantity of the product/part
     * @type {number}
     * @memberof ModelInvoicePos
     */
    quantity?: number;
    /**
     * the price of the product/part
     * @type {number}
     * @memberof ModelInvoicePos
     */
    price?: number;
    /**
     * the name of the product/part
     * @type {string}
     * @memberof ModelInvoicePos
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoicePos
     */
    priority?: number;
    /**
     * 
     * @type {ModelUnity}
     * @memberof ModelInvoicePos
     */
    unity?: ModelUnity;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelInvoicePos
     */
    sevClient?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoicePos
     */
    positionNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelInvoicePos
     */
    text?: string;
    /**
     * does not get filled, discount is handled in the discount_model
     * @type {number}
     * @memberof ModelInvoicePos
     */
    discount?: number;
    /**
     * tax rate in percent
     * @type {number}
     * @memberof ModelInvoicePos
     */
    taxRate?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelInvoicePos
     */
    temporary?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoicePos
     */
    sumNet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoicePos
     */
    sumGross?: number;
    /**
     * does not get filled, sumDiscount is handled in the discount_model
     * @type {number}
     * @memberof ModelInvoicePos
     */
    sumDiscount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoicePos
     */
    sumTax?: number;
    /**
     * equals sumNet
     * @type {number}
     * @memberof ModelInvoicePos
     */
    sumNetAccounting?: number;
    /**
     * equals sumTax
     * @type {number}
     * @memberof ModelInvoicePos
     */
    sumTaxAccounting?: number;
    /**
     * equals sumGross
     * @type {number}
     * @memberof ModelInvoicePos
     */
    sumGrossAccounting?: number;
    /**
     * net price of the product/part (one)
     * @type {number}
     * @memberof ModelInvoicePos
     */
    priceNet?: number;
    /**
     * gross price of the product/part (one)
     * @type {number}
     * @memberof ModelInvoicePos
     */
    priceGross?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelInvoicePos
     */
    priceTax?: number;
}
/**
 * 
 * @export
 * @interface ModelLetter
 */
export interface ModelLetter {
    /**
     * creation date of the letter
     * @type {Date}
     * @memberof ModelLetter
     */
    create?: Date;
    /**
     * date the letter was last updated
     * @type {Date}
     * @memberof ModelLetter
     */
    update?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    letterNumber?: string;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelLetter
     */
    contact?: ModelContact;
    /**
     * 
     * @type {Date}
     * @memberof ModelLetter
     */
    letterDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    header?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressName?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressName2?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressStreet?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressZip?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressCity?: string;
    /**
     * 
     * @type {ModelStaticCountry}
     * @memberof ModelLetter
     */
    addressCountry?: ModelStaticCountry;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelLetter
     */
    sevClient?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelLetter
     */
    status?: number;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelLetter
     */
    contactPerson?: ModelSevUser;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressParentName?: string;
    /**
     * 
     * @type {ModelContactAddress}
     * @memberof ModelLetter
     */
    addressContactRef?: ModelContactAddress;
    /**
     * text for the letter
     * @type {string}
     * @memberof ModelLetter
     */
    text?: string;
    /**
     * 
     * @type {Date}
     * @memberof ModelLetter
     */
    sendDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressParentName2?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    addressGender?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    address?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelLetter
     */
    sendType?: string;
}
/**
 * Note that Model_ObjectUsed is read-only
 * @export
 * @interface ModelObjectUsed
 */
export interface ModelObjectUsed {
    /**
     * date the object used was created
     * @type {Date}
     * @memberof ModelObjectUsed
     */
    create?: Date;
    /**
     * sevUser that used an object
     * @type {any}
     * @memberof ModelObjectUsed
     */
    user?: any;
    /**
     * object that was used
     * @type {any}
     * @memberof ModelObjectUsed
     */
    object?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelObjectUsed
     */
    sevClient?: any;
}
/**
 * Note that Model_ObjectViewed is read-only!
 * @export
 * @interface ModelObjectViewed
 */
export interface ModelObjectViewed {
    /**
     * date the object viewed was created
     * @type {Date}
     * @memberof ModelObjectViewed
     */
    create?: Date;
    /**
     * date the object viewed was last updated
     * @type {Date}
     * @memberof ModelObjectViewed
     */
    update?: Date;
    /**
     * sevUser that viewed the object
     * @type {any}
     * @memberof ModelObjectViewed
     */
    user?: any;
    /**
     * object that was viewed
     * @type {any}
     * @memberof ModelObjectViewed
     */
    object?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelObjectViewed
     */
    sevClient?: any;
}
/**
 * 
 * @export
 * @interface ModelOrder
 */
export interface ModelOrder {
    /**
     * date the order was created
     * @type {Date}
     * @memberof ModelOrder
     */
    create?: Date;
    /**
     * date the order was last updated
     * @type {Date}
     * @memberof ModelOrder
     */
    update?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    oderNumber?: string;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelOrder
     */
    contact?: ModelContact;
    /**
     * 
     * @type {Date}
     * @memberof ModelOrder
     */
    orderDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    status?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    header?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    headText?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    footText?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressName?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressStreet?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressZip?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressCity?: string;
    /**
     * 
     * @type {ModelStaticCountry}
     * @memberof ModelOrder
     */
    addressCountry?: ModelStaticCountry;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelOrder
     */
    createUser?: ModelSevUser;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelOrder
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    deliveryTerms?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    paymentTerms?: string;
    /**
     * 
     * @type {any}
     * @memberof ModelOrder
     */
    origin?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    version?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrder
     */
    smallSettlement?: boolean;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelOrder
     */
    contactPerson?: ModelSevUser;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    taxRate?: number;
    /**
     * 
     * @type {ModelTaxSet}
     * @memberof ModelOrder
     */
    taxSet?: ModelTaxSet;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    taxText?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressParentName?: string;
    /**
     * 
     * @type {ModelContactAddress}
     * @memberof ModelOrder
     */
    addressContactRef?: ModelContactAddress;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    taxType?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    orderType?: string;
    /**
     * date the order was sent
     * @type {Date}
     * @memberof ModelOrder
     */
    sendDate?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressParentName2?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressName2?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    addressGender?: string;
    /**
     * 
     * @type {ModelContactAddress}
     * @memberof ModelOrder
     */
    address?: ModelContactAddress;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    currency?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumNet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumTax?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumGross?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumDiscounts?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumNetForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumTaxForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumGrossForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    sumDiscountsForeignCurrency?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrder
     */
    weight?: number;
    /**
     * 
     * @type {ModelEntryType}
     * @memberof ModelOrder
     */
    entryType?: ModelEntryType;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    costumerInternalNote?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrder
     */
    showNet?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelOrder
     */
    sendType?: string;
}
/**
 * 
 * @export
 * @interface ModelOrderLog
 */
export interface ModelOrderLog {
    /**
     * date the order log was created
     * @type {Date}
     * @memberof ModelOrderLog
     */
    create?: Date;
    /**
     * date the order was last updated
     * @type {Date}
     * @memberof ModelOrderLog
     */
    update?: Date;
    /**
     * date of the order log
     * @type {Date}
     * @memberof ModelOrderLog
     */
    date?: Date;
    /**
     * 
     * @type {ModelOrder}
     * @memberof ModelOrderLog
     */
    order?: ModelOrder;
    /**
     * the object which was involved in the logged order action (eg. a created invoice)
     * @type {any}
     * @memberof ModelOrderLog
     */
    object?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelOrderLog
     */
    sevClient?: any;
    /**
     * currency of the logged order
     * @type {string}
     * @memberof ModelOrderLog
     */
    currency?: string;
    /**
     * amount of the order position
     * @type {number}
     * @memberof ModelOrderLog
     */
    amount?: number;
    /**
     * type of the order position amount, can be one from unity or custom
     * @type {string}
     * @memberof ModelOrderLog
     */
    amountType?: string;
    /**
     * tax rate of the order
     * @type {number}
     * @memberof ModelOrderLog
     */
    taxRate?: number;
}
/**
 * 
 * @export
 * @interface ModelOrderPos
 */
export interface ModelOrderPos {
    /**
     * creation date of the order position
     * @type {Date}
     * @memberof ModelOrderPos
     */
    create?: Date;
    /**
     * date the order position was last updated
     * @type {Date}
     * @memberof ModelOrderPos
     */
    update?: Date;
    /**
     * 
     * @type {ModelOrder}
     * @memberof ModelOrderPos
     */
    order?: ModelOrder;
    /**
     * 
     * @type {ModelPart}
     * @memberof ModelOrderPos
     */
    part?: ModelPart;
    /**
     * quantity of the Model_Part
     * @type {number}
     * @memberof ModelOrderPos
     */
    quantity?: number;
    /**
     * price of the Model_Part
     * @type {number}
     * @memberof ModelOrderPos
     */
    price?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderPos
     */
    name?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderPos
     */
    priority?: number;
    /**
     * 
     * @type {ModelUnity}
     * @memberof ModelOrderPos
     */
    unity?: ModelUnity;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelOrderPos
     */
    sevClient?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderPos
     */
    positionNumber?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelOrderPos
     */
    text?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderPos
     */
    discount?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrderPos
     */
    optional?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelOrderPos
     */
    optionalChargeable?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderPos
     */
    taxRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderPos
     */
    sumNet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderPos
     */
    sumGross?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelOrderPos
     */
    sumDiscount?: number;
}
/**
 * 
 * @export
 * @interface ModelPart
 */
export interface ModelPart {
    /**
     * date the part was created
     * @type {Date}
     * @memberof ModelPart
     */
    create?: Date;
    /**
     * date the part was last updated
     * @type {Date}
     * @memberof ModelPart
     */
    update?: Date;
    /**
     * name of the part
     * @type {string}
     * @memberof ModelPart
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPart
     */
    partNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPart
     */
    text?: string;
    /**
     * 
     * @type {ModelCategory}
     * @memberof ModelPart
     */
    category?: ModelCategory;
    /**
     * 
     * @type {number}
     * @memberof ModelPart
     */
    stock?: number;
    /**
     * 
     * @type {ModelUnity}
     * @memberof ModelPart
     */
    unity?: ModelUnity;
    /**
     * price for a partner. Can be added via the options in the inventory where the part is displayed
     * @type {number}
     * @memberof ModelPart
     */
    pricePartner?: number;
    /**
     * price for a customer. Can be added via the options in the inventory where the part is displayed
     * @type {number}
     * @memberof ModelPart
     */
    priceCustomer?: number;
    /**
     * price of the part
     * @type {number}
     * @memberof ModelPart
     */
    price?: number;
    /**
     * 
     * @type {ModelUnity}
     * @memberof ModelPart
     */
    secondUnity?: ModelUnity;
    /**
     * factor for the second unity resulting in a new sumNet for the secondUnity
     * @type {number}
     * @memberof ModelPart
     */
    secondUnityFactor?: number;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelPart
     */
    sevClient?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelPart
     */
    pricePurchase?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelPart
     */
    taxRate?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelPart
     */
    image?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelPart
     */
    status?: number;
    /**
     * characteristics of the part
     * @type {string}
     * @memberof ModelPart
     */
    characteristics?: string;
    /**
     * 
     * @type {ModelPart}
     * @memberof ModelPart
     */
    origin?: ModelPart;
    /**
     * 
     * @type {string}
     * @memberof ModelPart
     */
    characteristicsString?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPart
     */
    internalComment?: string;
    /**
     * 
     * @type {ModelEntryType}
     * @memberof ModelPart
     */
    entryType?: ModelEntryType;
    /**
     * 
     * @type {ModelAccountingType}
     * @memberof ModelPart
     */
    accountingType?: ModelAccountingType;
    /**
     * 
     * @type {number}
     * @memberof ModelPart
     */
    priceNet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelPart
     */
    priceGross?: number;
}
/**
 * 
 * @export
 * @interface ModelPartContactPrice
 */
export interface ModelPartContactPrice {
    /**
     * date the part contact price was created
     * @type {Date}
     * @memberof ModelPartContactPrice
     */
    create?: Date;
    /**
     * date the part contact price was last updated
     * @type {Date}
     * @memberof ModelPartContactPrice
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelPartContactPrice
     */
    sevClient?: any;
    /**
     * contact for which you have a special price
     * @type {any}
     * @memberof ModelPartContactPrice
     */
    contact?: any;
    /**
     * part for which you have a special price
     * @type {any}
     * @memberof ModelPartContactPrice
     */
    part?: any;
    /**
     * type of the part contact price
     * @type {string}
     * @memberof ModelPartContactPrice
     */
    type?: ModelPartContactPrice.TypeEnum;
    /**
     * special net price for contact
     * @type {number}
     * @memberof ModelPartContactPrice
     */
    priceNet?: number;
    /**
     * special gross price for contact
     * @type {number}
     * @memberof ModelPartContactPrice
     */
    priceGross?: number;
}

/**
 * @export
 * @namespace ModelPartContactPrice
 */
export namespace ModelPartContactPrice {
    /**
     * @export
     * @enum {string}
     */
    export enum TypeEnum {
        SupSUPPLIER = <any> 'sup (SUPPLIER)',
        CustCUSTOMER = <any> 'cust (CUSTOMER)'
    }
}
/**
 * 
 * @export
 * @interface ModelPartUnity
 */
export interface ModelPartUnity {
    /**
     * date the part unity was created
     * @type {Date}
     * @memberof ModelPartUnity
     */
    create?: Date;
    /**
     * date the part unity was last updated
     * @type {Date}
     * @memberof ModelPartUnity
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelPartUnity
     */
    sevClient?: any;
    /**
     * part involved in the part unity
     * @type {any}
     * @memberof ModelPartUnity
     */
    part?: any;
    /**
     * price of the part
     * @type {number}
     * @memberof ModelPartUnity
     */
    price?: number;
    /**
     * factor of the part
     * @type {number}
     * @memberof ModelPartUnity
     */
    factor?: number;
    /**
     * unity of the part
     * @type {any}
     * @memberof ModelPartUnity
     */
    unity?: any;
}
/**
 * 
 * @export
 * @interface ModelPaymentMethod
 */
export interface ModelPaymentMethod {
    /**
     * date the payment method was created
     * @type {Date}
     * @memberof ModelPaymentMethod
     */
    create?: Date;
    /**
     * date the payment method was last updated
     * @type {Date}
     * @memberof ModelPaymentMethod
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelPaymentMethod
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelPaymentMethod
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelPaymentMethod
     */
    text?: string;
}
/**
 * 
 * @export
 * @interface ModelPlace
 */
export interface ModelPlace {
    /**
     * name of the place
     * @type {string}
     * @memberof ModelPlace
     */
    name?: string;
    /**
     * longitude of the place
     * @type {number}
     * @memberof ModelPlace
     */
    lon?: number;
    /**
     * latitude of the place
     * @type {number}
     * @memberof ModelPlace
     */
    lat?: number;
    /**
     * zip of the place
     * @type {string}
     * @memberof ModelPlace
     */
    zip?: string;
    /**
     * location id of the place
     * @type {number}
     * @memberof ModelPlace
     */
    locId?: number;
}
/**
 * 
 * @export
 * @interface ModelReport
 */
export interface ModelReport {
}
/**
 * 
 * @export
 * @interface ModelSearch
 */
export interface ModelSearch {
}
/**
 * 
 * @export
 * @interface ModelSevClient
 */
export interface ModelSevClient {
    /**
     * This information is not visible for you
     * @type {string}
     * @memberof ModelSevClient
     */
    hidden?: string;
}
/**
 * 
 * @export
 * @interface ModelSevClientConfig
 */
export interface ModelSevClientConfig {
    /**
     * This information is not visible for you
     * @type {string}
     * @memberof ModelSevClientConfig
     */
    hidden?: string;
}
/**
 * 
 * @export
 * @interface ModelSevQuery
 */
export interface ModelSevQuery {
    /**
     * Name of the model for which you want to make a query
     * @type {string}
     * @memberof ModelSevQuery
     */
    modelName?: string;
    /**
     * Limit for the returned entries
     * @type {number}
     * @memberof ModelSevQuery
     */
    limit?: number;
    /**
     * Offset for the returned entries
     * @type {number}
     * @memberof ModelSevQuery
     */
    offset?: number;
    /**
     * Filters that should be applied to the returned entries
     * @type {Array<string>}
     * @memberof ModelSevQuery
     */
    filter?: Array<string>;
    /**
     * Define how returned entries should be sorted
     * @type {string}
     * @memberof ModelSevQuery
     */
    order?: string;
}
/**
 * 
 * @export
 * @interface ModelSevSequence
 */
export interface ModelSevSequence {
    /**
     * date the SevSequence was created
     * @type {Date}
     * @memberof ModelSevSequence
     */
    create?: Date;
    /**
     * date the SevSequence was last updated
     * @type {Date}
     * @memberof ModelSevSequence
     */
    update?: Date;
    /**
     * Object for which the sequence is
     * @type {string}
     * @memberof ModelSevSequence
     */
    forObject?: string;
    /**
     * Format of the sequence
     * @type {string}
     * @memberof ModelSevSequence
     */
    format?: string;
    /**
     * next sequence of the object
     * @type {number}
     * @memberof ModelSevSequence
     */
    nextSequence?: number;
    /**
     * 
     * @type {any}
     * @memberof ModelSevSequence
     */
    sevClient?: any;
    /**
     * type of the object
     * @type {string}
     * @memberof ModelSevSequence
     */
    type?: string;
}
/**
 * 
 * @export
 * @interface ModelSevToken
 */
export interface ModelSevToken {
    /**
     * date the sevToken was created
     * @type {Date}
     * @memberof ModelSevToken
     */
    create?: Date;
    /**
     * date the sevToken was last updated
     * @type {Date}
     * @memberof ModelSevToken
     */
    update?: Date;
    /**
     * SevUser to whom the sevToken belongs
     * @type {any}
     * @memberof ModelSevToken
     */
    user?: any;
    /**
     * token of the sevUser
     * @type {string}
     * @memberof ModelSevToken
     */
    token?: string;
    /**
     * expiration date of the token
     * @type {Date}
     * @memberof ModelSevToken
     */
    expire?: Date;
    /**
     * Defines if the token is active
     * @type {boolean}
     * @memberof ModelSevToken
     */
    active?: boolean;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelSevToken
     */
    sevClient?: any;
    /**
     * Ip address of the user
     * @type {string}
     * @memberof ModelSevToken
     */
    ipAddress?: string;
    /**
     * Information about the users system
     * @type {string}
     * @memberof ModelSevToken
     */
    userAgent?: string;
    /**
     * Type of the token
     * @type {string}
     * @memberof ModelSevToken
     */
    tokenType?: ModelSevToken.TokenTypeEnum;
    /**
     * Confirmation token
     * @type {string}
     * @memberof ModelSevToken
     */
    confirmationToken?: string;
}

/**
 * @export
 * @namespace ModelSevToken
 */
export namespace ModelSevToken {
    /**
     * @export
     * @enum {string}
     */
    export enum TokenTypeEnum {
        LOGIN = <any> 'LOGIN',
        API = <any> 'API',
        SUPPORT = <any> 'SUPPORT'
    }
}
/**
 * 
 * @export
 * @interface ModelSevUser
 */
export interface ModelSevUser {
    /**
     * This information is not visible for you
     * @type {string}
     * @memberof ModelSevUser
     */
    hidden?: string;
}
/**
 * 
 * @export
 * @interface ModelStaticCountry
 */
export interface ModelStaticCountry {
    /**
     * 
     * @type {string}
     * @memberof ModelStaticCountry
     */
    code?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelStaticCountry
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelStaticCountry
     */
    nameEn?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelStaticCountry
     */
    translationCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelStaticCountry
     */
    locale?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelStaticCountry
     */
    priority?: number;
}
/**
 * 
 * @export
 * @interface ModelStaticIndustry
 */
export interface ModelStaticIndustry {
    /**
     * 
     * @type {string}
     * @memberof ModelStaticIndustry
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelStaticIndustry
     */
    translationCode?: string;
}
/**
 * 
 * @export
 * @interface ModelStaticReferralProgram
 */
export interface ModelStaticReferralProgram {
    /**
     * 
     * @type {string}
     * @memberof ModelStaticReferralProgram
     */
    headline?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelStaticReferralProgram
     */
    text?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelStaticReferralProgram
     */
    rewardAmountLead?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelStaticReferralProgram
     */
    rewardAmount?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelStaticReferralProgram
     */
    rewardPercentage?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelStaticReferralProgram
     */
    rewardType?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelStaticReferralProgram
     */
    earningAmount?: number;
}
/**
 * 
 * @export
 * @interface ModelSubscriptionHistory
 */
export interface ModelSubscriptionHistory {
    /**
     * End date of subscription in subscription history
     * @type {Date}
     * @memberof ModelSubscriptionHistory
     */
    endDate?: Date;
    /**
     * Status of the subscription you currently have
     * @type {string}
     * @memberof ModelSubscriptionHistory
     */
    currentSubscriptionCode?: string;
    /**
     * Duration of your current subscription
     * @type {string}
     * @memberof ModelSubscriptionHistory
     */
    currentSubscriptionDuration?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelSubscriptionHistory
     */
    sevClient?: any;
}
/**
 * 
 * @export
 * @interface ModelSubscriptionType
 */
export interface ModelSubscriptionType {
    /**
     * date the subscription type was created
     * @type {Date}
     * @memberof ModelSubscriptionType
     */
    create?: Date;
    /**
     * date the subscription type was last updated
     * @type {Date}
     * @memberof ModelSubscriptionType
     */
    update?: Date;
    /**
     * name of the subscription type
     * @type {string}
     * @memberof ModelSubscriptionType
     */
    name?: string;
    /**
     * code of the subscription plan
     * @type {string}
     * @memberof ModelSubscriptionType
     */
    planCode?: string;
    /**
     * duration of the subscription plan in months
     * @type {string}
     * @memberof ModelSubscriptionType
     */
    planDuration?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelSubscriptionType
     */
    externalProductId?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelSubscriptionType
     */
    externalProductIdSandbox?: string;
    /**
     * net sum payable for the subscription type
     * @type {number}
     * @memberof ModelSubscriptionType
     */
    sumNet?: number;
    /**
     * vat sum payable for the subscription type
     * @type {number}
     * @memberof ModelSubscriptionType
     */
    sumVat?: number;
    /**
     * gross sum payable for the subscription type
     * @type {number}
     * @memberof ModelSubscriptionType
     */
    sumGross?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelSubscriptionType
     */
    externalProductIdGbp?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelSubscriptionType
     */
    sumNetGbp?: number;
    /**
     * translation code for the subscription type
     * @type {string}
     * @memberof ModelSubscriptionType
     */
    translationCode?: string;
}
/**
 * 
 * @export
 * @interface ModelSwissEsr
 */
export interface ModelSwissEsr {
    /**
     * date the swiss esr was created
     * @type {Date}
     * @memberof ModelSwissEsr
     */
    create?: Date;
    /**
     * date the swiss esr was last updated
     * @type {Date}
     * @memberof ModelSwissEsr
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelSwissEsr
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelSwissEsr
     */
    addressCityCredit?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelSwissEsr
     */
    addressZipCredit?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelSwissEsr
     */
    postSubscriberNumberBank?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelSwissEsr
     */
    internalSubscriberNumber?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelSwissEsr
     */
    documentTypeCode?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelSwissEsr
     */
    isEsr?: number;
}
/**
 * 
 * @export
 * @interface ModelTag
 */
export interface ModelTag {
    /**
     * date the tag was created
     * @type {Date}
     * @memberof ModelTag
     */
    create?: Date;
    /**
     * name of the tag
     * @type {string}
     * @memberof ModelTag
     */
    name?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTag
     */
    objectType?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelTag
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelTag
     */
    color?: string;
}
/**
 * 
 * @export
 * @interface ModelTagRelation
 */
export interface ModelTagRelation {
    /**
     * date the tag relation was created
     * @type {Date}
     * @memberof ModelTagRelation
     */
    create?: Date;
    /**
     * 
     * @type {ModelTag}
     * @memberof ModelTagRelation
     */
    tag?: ModelTag;
    /**
     * object type to which the tag is related
     * @type {any}
     * @memberof ModelTagRelation
     */
    object?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelTagRelation
     */
    sevClient?: any;
}
/**
 * 
 * @export
 * @interface ModelTask
 */
export interface ModelTask {
    /**
     * the date the task was created
     * @type {Date}
     * @memberof ModelTask
     */
    create?: Date;
    /**
     * date the task was last updated
     * @type {Date}
     * @memberof ModelTask
     */
    update?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelTask
     */
    name?: string;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelTask
     */
    assigned?: ModelSevUser;
    /**
     * can be a contact, invoice, etc to which the task refers to
     * @type {any}
     * @memberof ModelTask
     */
    object?: any;
    /**
     * 
     * @type {Date}
     * @memberof ModelTask
     */
    deadline?: Date;
    /**
     * 
     * @type {number}
     * @memberof ModelTask
     */
    status?: number;
    /**
     * 
     * @type {ModelCategory}
     * @memberof ModelTask
     */
    category?: ModelCategory;
    /**
     * 
     * @type {Date}
     * @memberof ModelTask
     */
    done?: Date;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelTask
     */
    createUser?: ModelSevUser;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelTask
     */
    doneUser?: ModelSevUser;
    /**
     * notice the creator when the task is finished
     * @type {boolean}
     * @memberof ModelTask
     */
    noticeCreator?: boolean;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelTask
     */
    sevClient?: any;
    /**
     * 
     * @type {Date}
     * @memberof ModelTask
     */
    begin?: Date;
}
/**
 * 
 * @export
 * @interface ModelTaxSet
 */
export interface ModelTaxSet {
    /**
     * date the tax set was created
     * @type {Date}
     * @memberof ModelTaxSet
     */
    create?: Date;
    /**
     * date the tax set was last updated
     * @type {Date}
     * @memberof ModelTaxSet
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelTaxSet
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelTaxSet
     */
    text?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelTaxSet
     */
    taxRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelTaxSet
     */
    code?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelTaxSet
     */
    displayText?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTaxSet
     */
    vatReportFieldNet?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTaxSet
     */
    vatReportFieldTax?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelTaxSet
     */
    accountingExportVatField?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelTaxSet
     */
    showInvoice?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelTaxSet
     */
    showDebitVoucher?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelTaxSet
     */
    showCreditVoucher?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelTaxSet
     */
    onlyForVatDec?: boolean;
}
/**
 * 
 * @export
 * @interface ModelTextTemplate
 */
export interface ModelTextTemplate {
    /**
     * date the text template was created
     * @type {Date}
     * @memberof ModelTextTemplate
     */
    create?: Date;
    /**
     * date the text template was last updated
     * @type {Date}
     * @memberof ModelTextTemplate
     */
    update?: Date;
    /**
     * name of the text template
     * @type {string}
     * @memberof ModelTextTemplate
     */
    name?: string;
    /**
     * text of your text template
     * @type {string}
     * @memberof ModelTextTemplate
     */
    text?: string;
    /**
     * object type for which you want to use the text template
     * @type {string}
     * @memberof ModelTextTemplate
     */
    objectType?: ModelTextTemplate.ObjectTypeEnum;
    /**
     * type of your text
     * @type {string}
     * @memberof ModelTextTemplate
     */
    textType?: ModelTextTemplate.TextTypeEnum;
    /**
     * sevUser who created the text template
     * @type {any}
     * @memberof ModelTextTemplate
     */
    sevUser?: any;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelTextTemplate
     */
    sevClient?: any;
    /**
     * defines if the text template is used as the main template
     * @type {boolean}
     * @memberof ModelTextTemplate
     */
    main?: boolean;
}

/**
 * @export
 * @namespace ModelTextTemplate
 */
export namespace ModelTextTemplate {
    /**
     * @export
     * @enum {string}
     */
    export enum ObjectTypeEnum {
        RE = <any> 'RE',
        AN = <any> 'AN',
        AB = <any> 'AB',
        LI = <any> 'LI',
        MA = <any> 'MA',
        MAIL = <any> 'MAIL'
    }
    /**
     * @export
     * @enum {string}
     */
    export enum TextTypeEnum {
        HEAD = <any> 'HEAD',
        FOOT = <any> 'FOOT'
    }
}
/**
 * 
 * @export
 * @interface ModelUnity
 */
export interface ModelUnity {
    /**
     * the date the unity was created
     * @type {Date}
     * @memberof ModelUnity
     */
    create?: Date;
    /**
     * 
     * @type {string}
     * @memberof ModelUnity
     */
    name?: string;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelUnity
     */
    sevClient?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelUnity
     */
    translationCode?: string;
    /**
     * 
     * @type {ModelEntryType}
     * @memberof ModelUnity
     */
    entryType?: ModelEntryType;
}
/**
 * 
 * @export
 * @interface ModelVatReport
 */
export interface ModelVatReport {
    /**
     * date the vat report was created
     * @type {Date}
     * @memberof ModelVatReport
     */
    create?: Date;
    /**
     * date the vat report was last updated
     * @type {Date}
     * @memberof ModelVatReport
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelVatReport
     */
    sevClient?: any;
    /**
     * 
     * @type {ModelStaticCountry}
     * @memberof ModelVatReport
     */
    country?: ModelStaticCountry;
    /**
     * date of the vat report
     * @type {Date}
     * @memberof ModelVatReport
     */
    reportDate?: Date;
    /**
     * year which is reported
     * @type {string}
     * @memberof ModelVatReport
     */
    reportingYear?: string;
    /**
     * period which is reported
     * @type {string}
     * @memberof ModelVatReport
     */
    reportingPeriod?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelVatReport
     */
    reportingPeriodCode?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelVatReport
     */
    reportingValues?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVatReport
     */
    testCase?: boolean;
    /**
     * define if you want to report the main income method or the profit and loss
     * @type {boolean}
     * @memberof ModelVatReport
     */
    actualTaxation?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVatReport
     */
    corrected?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelVatReport
     */
    resultFinanceAuthority?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelVatReport
     */
    financeAuthorityTicketNumber?: string;
}
/**
 * 
 * @export
 * @interface ModelVoucher
 */
export interface ModelVoucher {
    /**
     * date the voucher was created
     * @type {Date}
     * @memberof ModelVoucher
     */
    create?: Date;
    /**
     * date the voucher was last updated
     * @type {Date}
     * @memberof ModelVoucher
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelVoucher
     */
    sevClient?: any;
    /**
     * 
     * @type {ModelSevUser}
     * @memberof ModelVoucher
     */
    createUser?: ModelSevUser;
    /**
     * 
     * @type {Date}
     * @memberof ModelVoucher
     */
    voucherDate?: Date;
    /**
     * 
     * @type {ModelContact}
     * @memberof ModelVoucher
     */
    supplier?: ModelContact;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    supplierName?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    description?: string;
    /**
     * 
     * @type {ModelDocument}
     * @memberof ModelVoucher
     */
    document?: ModelDocument;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    resultDisdar?: string;
    /**
     * 
     * @type {ModelDocument}
     * @memberof ModelVoucher
     */
    documentPreview?: ModelDocument;
    /**
     * 
     * @type {Date}
     * @memberof ModelVoucher
     */
    payDate?: Date;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    status?: number;
    /**
     * 
     * @type {any}
     * @memberof ModelVoucher
     */
    object?: any;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    sumNet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    sumTax?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    sumGross?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    sumNetAccounting?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    sumTaxAccounting?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    sumGrossAccounting?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    taxType?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    creditDebit?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVoucher
     */
    hidden?: boolean;
    /**
     * 
     * @type {ModelCostCentre}
     * @memberof ModelVoucher
     */
    costCentre?: ModelCostCentre;
    /**
     * 
     * @type {any}
     * @memberof ModelVoucher
     */
    origin?: any;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    voucherType?: string;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    recurringIntervall?: number;
    /**
     * 
     * @type {Date}
     * @memberof ModelVoucher
     */
    recurringStartDate?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ModelVoucher
     */
    recurringNextVoucher?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ModelVoucher
     */
    recurringLastVoucher?: Date;
    /**
     * 
     * @type {Date}
     * @memberof ModelVoucher
     */
    recurringEndDate?: Date;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVoucher
     */
    enshrined?: boolean;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    inSource?: string;
    /**
     * 
     * @type {ModelTaxSet}
     * @memberof ModelVoucher
     */
    taxSet?: ModelTaxSet;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    iban?: string;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucher
     */
    accountingSpecialCase?: string;
    /**
     * 
     * @type {Date}
     * @memberof ModelVoucher
     */
    paymentDeadline?: Date;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucher
     */
    tip?: number;
}
/**
 * Below are the models which can be used for the saveVoucher function. Beware that you need to use them without the underscore at the beginning!
 * @export
 * @interface ModelVoucherFactory
 */
export interface ModelVoucherFactory {
    /**
     * 
     * @type {ModelVoucher}
     * @memberof ModelVoucherFactory
     */
    voucher?: ModelVoucher;
    /**
     * 
     * @type {ModelVoucherPos}
     * @memberof ModelVoucherFactory
     */
    voucherPosSave?: ModelVoucherPos;
    /**
     * 
     * @type {ModelVoucherPos}
     * @memberof ModelVoucherFactory
     */
    voucherPosDelete?: ModelVoucherPos;
}
/**
 * 
 * @export
 * @interface ModelVoucherLog
 */
export interface ModelVoucherLog {
    /**
     * date the voucher log was created
     * @type {Date}
     * @memberof ModelVoucherLog
     */
    create?: Date;
    /**
     * 
     * @type {ModelVoucher}
     * @memberof ModelVoucherLog
     */
    voucher?: ModelVoucher;
    /**
     * status of the voucher before the logged change
     * @type {number}
     * @memberof ModelVoucherLog
     */
    fromStatus?: number;
    /**
     * status of the voucher after the logged change
     * @type {number}
     * @memberof ModelVoucherLog
     */
    toStatus?: number;
    /**
     * amount which was payed
     * @type {number}
     * @memberof ModelVoucherLog
     */
    amountPayed?: number;
    /**
     * date of the booking
     * @type {Date}
     * @memberof ModelVoucherLog
     */
    bookingDate?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelVoucherLog
     */
    sevClient?: any;
}
/**
 * 
 * @export
 * @interface ModelVoucherPos
 */
export interface ModelVoucherPos {
    /**
     * date the voucher positions was created
     * @type {Date}
     * @memberof ModelVoucherPos
     */
    create?: Date;
    /**
     * date the voucher position was last updated
     * @type {Date}
     * @memberof ModelVoucherPos
     */
    update?: Date;
    /**
     * sevClient is the unique id every customer has and is used in nearly all operations
     * @type {any}
     * @memberof ModelVoucherPos
     */
    sevClient?: any;
    /**
     * 
     * @type {ModelVoucher}
     * @memberof ModelVoucherPos
     */
    voucher?: ModelVoucher;
    /**
     * 
     * @type {ModelAccountingType}
     * @memberof ModelVoucherPos
     */
    accountingType?: ModelAccountingType;
    /**
     * 
     * @type {ModelAccountingType}
     * @memberof ModelVoucherPos
     */
    estimatedAccountingType?: ModelAccountingType;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    taxRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    sum?: number;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVoucherPos
     */
    net?: boolean;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVoucherPos
     */
    isAsset?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    sumNet?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    sumTax?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    sumGross?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    sumNetAccounting?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    sumTaxAccounting?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    sumGrossAccounting?: number;
    /**
     * 
     * @type {string}
     * @memberof ModelVoucherPos
     */
    comment?: string;
    /**
     * 
     * @type {boolean}
     * @memberof ModelVoucherPos
     */
    isGwg?: boolean;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    cateringTaxRate?: number;
    /**
     * 
     * @type {number}
     * @memberof ModelVoucherPos
     */
    cateringTip?: number;
}
/**
 * AccountingChartApi - fetch parameter creator
 * @export
 */
export const AccountingChartApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls AccountingChart.php to add an accounting chart
         * @summary Create a new accounting chart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingChart(options: any = {}): FetchArgs {
            const localVarPath = `/AccountingChart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingChart.php to delete an accounting chart
         * @summary Delete an existing accounting chart
         * @param {number} id id of the accounting chart you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingChart(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccountingChart.');
            }
            const localVarPath = `/AccountingChart/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingChart.php to get necessary variables.
         * @summary Get an overview of all accounting charts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting charts start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingChart(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingChart`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingChart.php to update an accounting chart
         * @summary Update an existing accounting chart
         * @param {number} id id of accounting chart you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingChart(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccountingChart.');
            }
            const localVarPath = `/AccountingChart/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountingChartApi - functional programming interface
 * @export
 */
export const AccountingChartApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls AccountingChart.php to add an accounting chart
         * @summary Create a new accounting chart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingChart(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingChart> {
            const localVarFetchArgs = AccountingChartApiFetchParamCreator(configuration).addAccountingChart(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingChart.php to delete an accounting chart
         * @summary Delete an existing accounting chart
         * @param {number} id id of the accounting chart you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingChart(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingChartApiFetchParamCreator(configuration).deleteAccountingChart(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingChart.php to get necessary variables.
         * @summary Get an overview of all accounting charts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting charts start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingChart(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingChart> {
            const localVarFetchArgs = AccountingChartApiFetchParamCreator(configuration).getAccountingChart(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingChart.php to update an accounting chart
         * @summary Update an existing accounting chart
         * @param {number} id id of accounting chart you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingChart(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingChart> {
            const localVarFetchArgs = AccountingChartApiFetchParamCreator(configuration).updateAccountingChart(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountingChartApi - factory interface
 * @export
 */
export const AccountingChartApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls AccountingChart.php to add an accounting chart
         * @summary Create a new accounting chart
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingChart(options?: any) {
            return AccountingChartApiFp(configuration).addAccountingChart(options)(fetch, basePath);
        },
        /**
         * Calls AccountingChart.php to delete an accounting chart
         * @summary Delete an existing accounting chart
         * @param {number} id id of the accounting chart you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingChart(id: number, options?: any) {
            return AccountingChartApiFp(configuration).deleteAccountingChart(id, options)(fetch, basePath);
        },
        /**
         * Calls AccountingChart.php to get necessary variables.
         * @summary Get an overview of all accounting charts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting charts start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingChart(limit?: number, offset?: number, options?: any) {
            return AccountingChartApiFp(configuration).getAccountingChart(limit, offset, options)(fetch, basePath);
        },
        /**
         * Calls AccountingChart.php to update an accounting chart
         * @summary Update an existing accounting chart
         * @param {number} id id of accounting chart you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingChart(id: number, options?: any) {
            return AccountingChartApiFp(configuration).updateAccountingChart(id, options)(fetch, basePath);
        },
    };
};

/**
 * AccountingChartApi - object-oriented interface
 * @export
 * @class AccountingChartApi
 * @extends {BaseAPI}
 */
export class AccountingChartApi extends BaseAPI {
    /**
     * Calls AccountingChart.php to add an accounting chart
     * @summary Create a new accounting chart
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingChartApi
     */
    public addAccountingChart(options?: any) {
        return AccountingChartApiFp(this.configuration).addAccountingChart(options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingChart.php to delete an accounting chart
     * @summary Delete an existing accounting chart
     * @param {number} id id of the accounting chart you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingChartApi
     */
    public deleteAccountingChart(id: number, options?: any) {
        return AccountingChartApiFp(this.configuration).deleteAccountingChart(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingChart.php to get necessary variables.
     * @summary Get an overview of all accounting charts
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned accounting charts start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingChartApi
     */
    public getAccountingChart(limit?: number, offset?: number, options?: any) {
        return AccountingChartApiFp(this.configuration).getAccountingChart(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingChart.php to update an accounting chart
     * @summary Update an existing accounting chart
     * @param {number} id id of accounting chart you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingChartApi
     */
    public updateAccountingChart(id: number, options?: any) {
        return AccountingChartApiFp(this.configuration).updateAccountingChart(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AccountingContactApi - fetch parameter creator
 * @export
 */
export const AccountingContactApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls isAvailableDebitorCreditorNumber() in AccountingContact.php to get if the debitor / creditor number is available.
         * @summary Return if a debitor / creditor number is available
         * @param {number} [contactId] If you want to exclude a contact from getting checked you can provide its id here
         * @param {string} [contactObjectName] Contact object name
         * @param {string} [debitorNumber] debitor number of which you want to know if it is available
         * @param {string} [creditorNumber] creditor number of which you want to know if it is available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingContactIsAvailableDebitorCreditorNumber(contactId?: number, contactObjectName?: string, debitorNumber?: string, creditorNumber?: string, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingContact/isAvailableDebitorCreditorNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (contactId !== undefined) {
                localVarQueryParameter['contact[id]'] = contactId;
            }

            if (contactObjectName !== undefined) {
                localVarQueryParameter['contact[objectName]'] = contactObjectName;
            }

            if (debitorNumber !== undefined) {
                localVarQueryParameter['debitorNumber'] = debitorNumber;
            }

            if (creditorNumber !== undefined) {
                localVarQueryParameter['creditorNumber'] = creditorNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingContact.php 
         * @summary Create a new accounting contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingContact(options: any = {}): FetchArgs {
            const localVarPath = `/AccountingContact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in AccountingContact.php
         * @summary Delete an existing accounting contact
         * @param {number} id id of accounting contact you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingContact(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccountingContact.');
            }
            const localVarPath = `/AccountingContact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingContact.php to get necessary variables.
         * @summary Get an overview of all accounting contacts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned discounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingContacts(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingContact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingContact.php
         * @summary Update an existing accounting contact
         * @param {number} id id of accounting contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingContact(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccountingContact.');
            }
            const localVarPath = `/AccountingContact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountingContactApi - functional programming interface
 * @export
 */
export const AccountingContactApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls isAvailableDebitorCreditorNumber() in AccountingContact.php to get if the debitor / creditor number is available.
         * @summary Return if a debitor / creditor number is available
         * @param {number} [contactId] If you want to exclude a contact from getting checked you can provide its id here
         * @param {string} [contactObjectName] Contact object name
         * @param {string} [debitorNumber] debitor number of which you want to know if it is available
         * @param {string} [creditorNumber] creditor number of which you want to know if it is available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingContactIsAvailableDebitorCreditorNumber(contactId?: number, contactObjectName?: string, debitorNumber?: string, creditorNumber?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingContactApiFetchParamCreator(configuration).accountingContactIsAvailableDebitorCreditorNumber(contactId, contactObjectName, debitorNumber, creditorNumber, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingContact.php 
         * @summary Create a new accounting contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingContact(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingContact> {
            const localVarFetchArgs = AccountingContactApiFetchParamCreator(configuration).addAccountingContact(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in AccountingContact.php
         * @summary Delete an existing accounting contact
         * @param {number} id id of accounting contact you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingContact(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingContactApiFetchParamCreator(configuration).deleteAccountingContact(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingContact.php to get necessary variables.
         * @summary Get an overview of all accounting contacts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned discounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingContacts(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingContact> {
            const localVarFetchArgs = AccountingContactApiFetchParamCreator(configuration).getAccountingContacts(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingContact.php
         * @summary Update an existing accounting contact
         * @param {number} id id of accounting contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingContact(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingContact> {
            const localVarFetchArgs = AccountingContactApiFetchParamCreator(configuration).updateAccountingContact(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountingContactApi - factory interface
 * @export
 */
export const AccountingContactApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls isAvailableDebitorCreditorNumber() in AccountingContact.php to get if the debitor / creditor number is available.
         * @summary Return if a debitor / creditor number is available
         * @param {number} [contactId] If you want to exclude a contact from getting checked you can provide its id here
         * @param {string} [contactObjectName] Contact object name
         * @param {string} [debitorNumber] debitor number of which you want to know if it is available
         * @param {string} [creditorNumber] creditor number of which you want to know if it is available
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingContactIsAvailableDebitorCreditorNumber(contactId?: number, contactObjectName?: string, debitorNumber?: string, creditorNumber?: string, options?: any) {
            return AccountingContactApiFp(configuration).accountingContactIsAvailableDebitorCreditorNumber(contactId, contactObjectName, debitorNumber, creditorNumber, options)(fetch, basePath);
        },
        /**
         * Calls AccountingContact.php 
         * @summary Create a new accounting contact
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingContact(options?: any) {
            return AccountingContactApiFp(configuration).addAccountingContact(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in AccountingContact.php
         * @summary Delete an existing accounting contact
         * @param {number} id id of accounting contact you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingContact(id: number, options?: any) {
            return AccountingContactApiFp(configuration).deleteAccountingContact(id, options)(fetch, basePath);
        },
        /**
         * Calls AccountingContact.php to get necessary variables.
         * @summary Get an overview of all accounting contacts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned discounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingContacts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AccountingContactApiFp(configuration).getAccountingContacts(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls AccountingContact.php
         * @summary Update an existing accounting contact
         * @param {number} id id of accounting contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingContact(id: number, options?: any) {
            return AccountingContactApiFp(configuration).updateAccountingContact(id, options)(fetch, basePath);
        },
    };
};

/**
 * AccountingContactApi - object-oriented interface
 * @export
 * @class AccountingContactApi
 * @extends {BaseAPI}
 */
export class AccountingContactApi extends BaseAPI {
    /**
     * Calls isAvailableDebitorCreditorNumber() in AccountingContact.php to get if the debitor / creditor number is available.
     * @summary Return if a debitor / creditor number is available
     * @param {number} [contactId] If you want to exclude a contact from getting checked you can provide its id here
     * @param {string} [contactObjectName] Contact object name
     * @param {string} [debitorNumber] debitor number of which you want to know if it is available
     * @param {string} [creditorNumber] creditor number of which you want to know if it is available
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingContactApi
     */
    public accountingContactIsAvailableDebitorCreditorNumber(contactId?: number, contactObjectName?: string, debitorNumber?: string, creditorNumber?: string, options?: any) {
        return AccountingContactApiFp(this.configuration).accountingContactIsAvailableDebitorCreditorNumber(contactId, contactObjectName, debitorNumber, creditorNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingContact.php 
     * @summary Create a new accounting contact
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingContactApi
     */
    public addAccountingContact(options?: any) {
        return AccountingContactApiFp(this.configuration).addAccountingContact(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in AccountingContact.php
     * @summary Delete an existing accounting contact
     * @param {number} id id of accounting contact you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingContactApi
     */
    public deleteAccountingContact(id: number, options?: any) {
        return AccountingContactApiFp(this.configuration).deleteAccountingContact(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingContact.php to get necessary variables.
     * @summary Get an overview of all accounting contacts
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned discounts start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingContactApi
     */
    public getAccountingContacts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AccountingContactApiFp(this.configuration).getAccountingContacts(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingContact.php
     * @summary Update an existing accounting contact
     * @param {number} id id of accounting contact you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingContactApi
     */
    public updateAccountingContact(id: number, options?: any) {
        return AccountingContactApiFp(this.configuration).updateAccountingContact(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AccountingCorrectionApi - fetch parameter creator
 * @export
 */
export const AccountingCorrectionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls AccountingCorrection.php to add an accounting correction
         * @summary Create a new accounting correction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingCorrection(options: any = {}): FetchArgs {
            const localVarPath = `/AccountingCorrection`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingCorrection.php to delete an accounting correction
         * @summary Delete an existing accounting correction
         * @param {number} id id of the accounting correction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingCorrection(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccountingCorrection.');
            }
            const localVarPath = `/AccountingCorrection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingCorrection.php to get necessary variables.
         * @summary Get an overview of all accounting corrections
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting corrections start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingCorrections(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingCorrection`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingCorrection.php to update an accounting correction
         * @summary Update an existing accounting correction
         * @param {number} id id of accounting correction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingCorrection(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccountingCorrection.');
            }
            const localVarPath = `/AccountingCorrection/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountingCorrectionApi - functional programming interface
 * @export
 */
export const AccountingCorrectionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls AccountingCorrection.php to add an accounting correction
         * @summary Create a new accounting correction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingCorrection(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingCorrection> {
            const localVarFetchArgs = AccountingCorrectionApiFetchParamCreator(configuration).addAccountingCorrection(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingCorrection.php to delete an accounting correction
         * @summary Delete an existing accounting correction
         * @param {number} id id of the accounting correction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingCorrection(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingCorrectionApiFetchParamCreator(configuration).deleteAccountingCorrection(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingCorrection.php to get necessary variables.
         * @summary Get an overview of all accounting corrections
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting corrections start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingCorrections(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingCorrection> {
            const localVarFetchArgs = AccountingCorrectionApiFetchParamCreator(configuration).getAccountingCorrections(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingCorrection.php to update an accounting correction
         * @summary Update an existing accounting correction
         * @param {number} id id of accounting correction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingCorrection(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingCorrection> {
            const localVarFetchArgs = AccountingCorrectionApiFetchParamCreator(configuration).updateAccountingCorrection(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountingCorrectionApi - factory interface
 * @export
 */
export const AccountingCorrectionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls AccountingCorrection.php to add an accounting correction
         * @summary Create a new accounting correction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingCorrection(options?: any) {
            return AccountingCorrectionApiFp(configuration).addAccountingCorrection(options)(fetch, basePath);
        },
        /**
         * Calls AccountingCorrection.php to delete an accounting correction
         * @summary Delete an existing accounting correction
         * @param {number} id id of the accounting correction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingCorrection(id: number, options?: any) {
            return AccountingCorrectionApiFp(configuration).deleteAccountingCorrection(id, options)(fetch, basePath);
        },
        /**
         * Calls AccountingCorrection.php to get necessary variables.
         * @summary Get an overview of all accounting corrections
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting corrections start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingCorrections(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AccountingCorrectionApiFp(configuration).getAccountingCorrections(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls AccountingCorrection.php to update an accounting correction
         * @summary Update an existing accounting correction
         * @param {number} id id of accounting correction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingCorrection(id: number, options?: any) {
            return AccountingCorrectionApiFp(configuration).updateAccountingCorrection(id, options)(fetch, basePath);
        },
    };
};

/**
 * AccountingCorrectionApi - object-oriented interface
 * @export
 * @class AccountingCorrectionApi
 * @extends {BaseAPI}
 */
export class AccountingCorrectionApi extends BaseAPI {
    /**
     * Calls AccountingCorrection.php to add an accounting correction
     * @summary Create a new accounting correction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingCorrectionApi
     */
    public addAccountingCorrection(options?: any) {
        return AccountingCorrectionApiFp(this.configuration).addAccountingCorrection(options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingCorrection.php to delete an accounting correction
     * @summary Delete an existing accounting correction
     * @param {number} id id of the accounting correction you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingCorrectionApi
     */
    public deleteAccountingCorrection(id: number, options?: any) {
        return AccountingCorrectionApiFp(this.configuration).deleteAccountingCorrection(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingCorrection.php to get necessary variables.
     * @summary Get an overview of all accounting corrections
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned accounting corrections start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingCorrectionApi
     */
    public getAccountingCorrections(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AccountingCorrectionApiFp(this.configuration).getAccountingCorrections(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingCorrection.php to update an accounting correction
     * @summary Update an existing accounting correction
     * @param {number} id id of accounting correction you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingCorrectionApi
     */
    public updateAccountingCorrection(id: number, options?: any) {
        return AccountingCorrectionApiFp(this.configuration).updateAccountingCorrection(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AccountingIndexApi - fetch parameter creator
 * @export
 */
export const AccountingIndexApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls AccountingIndex.php to add an accounting index
         * @summary Create a new accounting index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingIndex(options: any = {}): FetchArgs {
            const localVarPath = `/AccountingIndex`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingIndex.php to delete an accounting index
         * @summary Delete an existing accounting index
         * @param {number} id id of the accounting index you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingIndex(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccountingIndex.');
            }
            const localVarPath = `/AccountingIndex/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingIndex.php to get necessary variables.
         * @summary Get an overview of all accounting indexes
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting indexes start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingIndexes(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingIndex`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingIndex.php to update an accounting index
         * @summary Update an existing accounting index
         * @param {number} id id of accounting index you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingIndex(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccountingIndex.');
            }
            const localVarPath = `/AccountingIndex/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountingIndexApi - functional programming interface
 * @export
 */
export const AccountingIndexApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls AccountingIndex.php to add an accounting index
         * @summary Create a new accounting index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingIndex(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingIndex> {
            const localVarFetchArgs = AccountingIndexApiFetchParamCreator(configuration).addAccountingIndex(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingIndex.php to delete an accounting index
         * @summary Delete an existing accounting index
         * @param {number} id id of the accounting index you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingIndex(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingIndexApiFetchParamCreator(configuration).deleteAccountingIndex(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingIndex.php to get necessary variables.
         * @summary Get an overview of all accounting indexes
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting indexes start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingIndexes(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingIndex> {
            const localVarFetchArgs = AccountingIndexApiFetchParamCreator(configuration).getAccountingIndexes(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingIndex.php to update an accounting index
         * @summary Update an existing accounting index
         * @param {number} id id of accounting index you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingIndex(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingIndex> {
            const localVarFetchArgs = AccountingIndexApiFetchParamCreator(configuration).updateAccountingIndex(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountingIndexApi - factory interface
 * @export
 */
export const AccountingIndexApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls AccountingIndex.php to add an accounting index
         * @summary Create a new accounting index
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingIndex(options?: any) {
            return AccountingIndexApiFp(configuration).addAccountingIndex(options)(fetch, basePath);
        },
        /**
         * Calls AccountingIndex.php to delete an accounting index
         * @summary Delete an existing accounting index
         * @param {number} id id of the accounting index you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingIndex(id: number, options?: any) {
            return AccountingIndexApiFp(configuration).deleteAccountingIndex(id, options)(fetch, basePath);
        },
        /**
         * Calls AccountingIndex.php to get necessary variables.
         * @summary Get an overview of all accounting indexes
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting indexes start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingIndexes(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AccountingIndexApiFp(configuration).getAccountingIndexes(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls AccountingIndex.php to update an accounting index
         * @summary Update an existing accounting index
         * @param {number} id id of accounting index you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingIndex(id: number, options?: any) {
            return AccountingIndexApiFp(configuration).updateAccountingIndex(id, options)(fetch, basePath);
        },
    };
};

/**
 * AccountingIndexApi - object-oriented interface
 * @export
 * @class AccountingIndexApi
 * @extends {BaseAPI}
 */
export class AccountingIndexApi extends BaseAPI {
    /**
     * Calls AccountingIndex.php to add an accounting index
     * @summary Create a new accounting index
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingIndexApi
     */
    public addAccountingIndex(options?: any) {
        return AccountingIndexApiFp(this.configuration).addAccountingIndex(options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingIndex.php to delete an accounting index
     * @summary Delete an existing accounting index
     * @param {number} id id of the accounting index you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingIndexApi
     */
    public deleteAccountingIndex(id: number, options?: any) {
        return AccountingIndexApiFp(this.configuration).deleteAccountingIndex(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingIndex.php to get necessary variables.
     * @summary Get an overview of all accounting indexes
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned accounting indexes start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingIndexApi
     */
    public getAccountingIndexes(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AccountingIndexApiFp(this.configuration).getAccountingIndexes(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingIndex.php to update an accounting index
     * @summary Update an existing accounting index
     * @param {number} id id of accounting index you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingIndexApi
     */
    public updateAccountingIndex(id: number, options?: any) {
        return AccountingIndexApiFp(this.configuration).updateAccountingIndex(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AccountingSystemApi - fetch parameter creator
 * @export
 */
export const AccountingSystemApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls AccountingSystem.php to get necessary variables.
         * @summary Get an overview of all accounting systems
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting systems start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingSystems(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingSystem`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountingSystemApi - functional programming interface
 * @export
 */
export const AccountingSystemApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls AccountingSystem.php to get necessary variables.
         * @summary Get an overview of all accounting systems
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting systems start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingSystems(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingSystem> {
            const localVarFetchArgs = AccountingSystemApiFetchParamCreator(configuration).getAccountingSystems(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountingSystemApi - factory interface
 * @export
 */
export const AccountingSystemApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls AccountingSystem.php to get necessary variables.
         * @summary Get an overview of all accounting systems
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned accounting systems start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingSystems(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AccountingSystemApiFp(configuration).getAccountingSystems(limit, offset, embed, options)(fetch, basePath);
        },
    };
};

/**
 * AccountingSystemApi - object-oriented interface
 * @export
 * @class AccountingSystemApi
 * @extends {BaseAPI}
 */
export class AccountingSystemApi extends BaseAPI {
    /**
     * Calls AccountingSystem.php to get necessary variables.
     * @summary Get an overview of all accounting systems
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned accounting systems start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingSystemApi
     */
    public getAccountingSystems(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AccountingSystemApiFp(this.configuration).getAccountingSystems(limit, offset, embed, options)(this.fetch, this.basePath);
    }

}
/**
 * AccountingSystemNumberApi - fetch parameter creator
 * @export
 */
export const AccountingSystemNumberApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls AccountingSystemNumber.php 
         * @summary Create a new accounting system number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingSystemNumber(options: any = {}): FetchArgs {
            const localVarPath = `/AccountingSystemNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in AccountingSystemNumber.php
         * @summary Delete an existing accounting system number
         * @param {number} id id of accounting system number you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingSystemNumber(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccountingSystemNumber.');
            }
            const localVarPath = `/AccountingSystemNumber/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingSystemNumber.php to get necessary variables.
         * @summary Get an overview of all accounting system numbers
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned accounting system numbers start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingSystemNumbers(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingSystemNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingSystemNumber.php
         * @summary Update an existing accounting system number
         * @param {number} id id of accounting system number you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingSystemNumber(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccountingSystemNumber.');
            }
            const localVarPath = `/AccountingSystemNumber/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountingSystemNumberApi - functional programming interface
 * @export
 */
export const AccountingSystemNumberApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls AccountingSystemNumber.php 
         * @summary Create a new accounting system number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingSystemNumber(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingSystemNumber> {
            const localVarFetchArgs = AccountingSystemNumberApiFetchParamCreator(configuration).addAccountingSystemNumber(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in AccountingSystemNumber.php
         * @summary Delete an existing accounting system number
         * @param {number} id id of accounting system number you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingSystemNumber(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingSystemNumberApiFetchParamCreator(configuration).deleteAccountingSystemNumber(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingSystemNumber.php to get necessary variables.
         * @summary Get an overview of all accounting system numbers
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned accounting system numbers start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingSystemNumbers(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingSystemNumber> {
            const localVarFetchArgs = AccountingSystemNumberApiFetchParamCreator(configuration).getAccountingSystemNumbers(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingSystemNumber.php
         * @summary Update an existing accounting system number
         * @param {number} id id of accounting system number you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingSystemNumber(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingType> {
            const localVarFetchArgs = AccountingSystemNumberApiFetchParamCreator(configuration).updateAccountingSystemNumber(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountingSystemNumberApi - factory interface
 * @export
 */
export const AccountingSystemNumberApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls AccountingSystemNumber.php 
         * @summary Create a new accounting system number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingSystemNumber(options?: any) {
            return AccountingSystemNumberApiFp(configuration).addAccountingSystemNumber(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in AccountingSystemNumber.php
         * @summary Delete an existing accounting system number
         * @param {number} id id of accounting system number you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingSystemNumber(id: number, options?: any) {
            return AccountingSystemNumberApiFp(configuration).deleteAccountingSystemNumber(id, options)(fetch, basePath);
        },
        /**
         * Calls AccountingSystemNumber.php to get necessary variables.
         * @summary Get an overview of all accounting system numbers
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned accounting system numbers start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingSystemNumbers(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AccountingSystemNumberApiFp(configuration).getAccountingSystemNumbers(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls AccountingSystemNumber.php
         * @summary Update an existing accounting system number
         * @param {number} id id of accounting system number you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingSystemNumber(id: number, options?: any) {
            return AccountingSystemNumberApiFp(configuration).updateAccountingSystemNumber(id, options)(fetch, basePath);
        },
    };
};

/**
 * AccountingSystemNumberApi - object-oriented interface
 * @export
 * @class AccountingSystemNumberApi
 * @extends {BaseAPI}
 */
export class AccountingSystemNumberApi extends BaseAPI {
    /**
     * Calls AccountingSystemNumber.php 
     * @summary Create a new accounting system number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingSystemNumberApi
     */
    public addAccountingSystemNumber(options?: any) {
        return AccountingSystemNumberApiFp(this.configuration).addAccountingSystemNumber(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in AccountingSystemNumber.php
     * @summary Delete an existing accounting system number
     * @param {number} id id of accounting system number you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingSystemNumberApi
     */
    public deleteAccountingSystemNumber(id: number, options?: any) {
        return AccountingSystemNumberApiFp(this.configuration).deleteAccountingSystemNumber(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingSystemNumber.php to get necessary variables.
     * @summary Get an overview of all accounting system numbers
     * @param {number} [limit] Limits the number of entries returned. Default is 1000
     * @param {number} [offset] Set the index where the returned accounting system numbers start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingSystemNumberApi
     */
    public getAccountingSystemNumbers(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AccountingSystemNumberApiFp(this.configuration).getAccountingSystemNumbers(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingSystemNumber.php
     * @summary Update an existing accounting system number
     * @param {number} id id of accounting system number you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingSystemNumberApi
     */
    public updateAccountingSystemNumber(id: number, options?: any) {
        return AccountingSystemNumberApiFp(this.configuration).updateAccountingSystemNumber(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AccountingTypeApi - fetch parameter creator
 * @export
 */
export const AccountingTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls getAccountingNumber() in AccountingType.php to get the accounting system number of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the number, not the model.
         * @summary Get accounting system number of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingNumber(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling accountingTypeGetAccountingNumber.');
            }
            const localVarPath = `/AccountingType/{id}/getAccountingNumber`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAccountingNumberDepreciation() in AccountingType.php to get the accounting system number depreciation of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the depreciation, not the model.
         * @summary Get accounting system number depreciation of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number depreciation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingNumberDepreciation(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling accountingTypeGetAccountingNumberDepreciation.');
            }
            const localVarPath = `/AccountingType/{id}/getAccountingNumberDepreciation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAccountingSystemNumber() in AccountingType.php to get the accounting system number of the specified accounting type.
         * @summary Get accounting system number of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingSystemNumber(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling accountingTypeGetAccountingSystemNumber.');
            }
            const localVarPath = `/AccountingType/{id}/getAccountingSystemNumber`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingType.php 
         * @summary Create a new accounting type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingType(options: any = {}): FetchArgs {
            const localVarPath = `/AccountingType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create a new accounting type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingTypeFactory(options: any = {}): FetchArgs {
            const localVarPath = `/AccountingType/Factory/createType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in AccountingType.php
         * @summary Delete an existing accounting type
         * @param {number} id id of accounting type you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingType(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAccountingType.');
            }
            const localVarPath = `/AccountingType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingType.php to get necessary variables.
         * @summary Get an overview of all accounting types
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned accounting types start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingTypes(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/AccountingType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AccountingType.php
         * @summary Update an existing accounting type
         * @param {number} id id of accounting type you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingType(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAccountingType.');
            }
            const localVarPath = `/AccountingType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AccountingTypeApi - functional programming interface
 * @export
 */
export const AccountingTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls getAccountingNumber() in AccountingType.php to get the accounting system number of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the number, not the model.
         * @summary Get accounting system number of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingNumber(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).accountingTypeGetAccountingNumber(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAccountingNumberDepreciation() in AccountingType.php to get the accounting system number depreciation of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the depreciation, not the model.
         * @summary Get accounting system number depreciation of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number depreciation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingNumberDepreciation(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).accountingTypeGetAccountingNumberDepreciation(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAccountingSystemNumber() in AccountingType.php to get the accounting system number of the specified accounting type.
         * @summary Get accounting system number of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingSystemNumber(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingSystemNumber> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).accountingTypeGetAccountingSystemNumber(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingType.php 
         * @summary Create a new accounting type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingType(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingType> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).addAccountingType(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create a new accounting type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingTypeFactory(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingType> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).addAccountingTypeFactory(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in AccountingType.php
         * @summary Delete an existing accounting type
         * @param {number} id id of accounting type you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingType(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).deleteAccountingType(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingType.php to get necessary variables.
         * @summary Get an overview of all accounting types
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned accounting types start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingTypes(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingType> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).getAccountingTypes(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AccountingType.php
         * @summary Update an existing accounting type
         * @param {number} id id of accounting type you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingType(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingType> {
            const localVarFetchArgs = AccountingTypeApiFetchParamCreator(configuration).updateAccountingType(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AccountingTypeApi - factory interface
 * @export
 */
export const AccountingTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls getAccountingNumber() in AccountingType.php to get the accounting system number of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the number, not the model.
         * @summary Get accounting system number of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingNumber(id: number, options?: any) {
            return AccountingTypeApiFp(configuration).accountingTypeGetAccountingNumber(id, options)(fetch, basePath);
        },
        /**
         * Calls getAccountingNumberDepreciation() in AccountingType.php to get the accounting system number depreciation of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the depreciation, not the model.
         * @summary Get accounting system number depreciation of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number depreciation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingNumberDepreciation(id: number, options?: any) {
            return AccountingTypeApiFp(configuration).accountingTypeGetAccountingNumberDepreciation(id, options)(fetch, basePath);
        },
        /**
         * Calls getAccountingSystemNumber() in AccountingType.php to get the accounting system number of the specified accounting type.
         * @summary Get accounting system number of the specified accounting type
         * @param {number} id Id of the accounting type for which you want to get the accounting system number
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        accountingTypeGetAccountingSystemNumber(id: number, embed?: Array<string>, options?: any) {
            return AccountingTypeApiFp(configuration).accountingTypeGetAccountingSystemNumber(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls AccountingType.php 
         * @summary Create a new accounting type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingType(options?: any) {
            return AccountingTypeApiFp(configuration).addAccountingType(options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create a new accounting type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAccountingTypeFactory(options?: any) {
            return AccountingTypeApiFp(configuration).addAccountingTypeFactory(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in AccountingType.php
         * @summary Delete an existing accounting type
         * @param {number} id id of accounting type you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAccountingType(id: number, options?: any) {
            return AccountingTypeApiFp(configuration).deleteAccountingType(id, options)(fetch, basePath);
        },
        /**
         * Calls AccountingType.php to get necessary variables.
         * @summary Get an overview of all accounting types
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned accounting types start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAccountingTypes(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AccountingTypeApiFp(configuration).getAccountingTypes(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls AccountingType.php
         * @summary Update an existing accounting type
         * @param {number} id id of accounting type you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAccountingType(id: number, options?: any) {
            return AccountingTypeApiFp(configuration).updateAccountingType(id, options)(fetch, basePath);
        },
    };
};

/**
 * AccountingTypeApi - object-oriented interface
 * @export
 * @class AccountingTypeApi
 * @extends {BaseAPI}
 */
export class AccountingTypeApi extends BaseAPI {
    /**
     * Calls getAccountingNumber() in AccountingType.php to get the accounting system number of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the number, not the model.
     * @summary Get accounting system number of the specified accounting type
     * @param {number} id Id of the accounting type for which you want to get the accounting system number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public accountingTypeGetAccountingNumber(id: number, options?: any) {
        return AccountingTypeApiFp(this.configuration).accountingTypeGetAccountingNumber(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAccountingNumberDepreciation() in AccountingType.php to get the accounting system number depreciation of the specified accounting type.    Basically this function does just calls getAccountingSystemNumber() and returns just the depreciation, not the model.
     * @summary Get accounting system number depreciation of the specified accounting type
     * @param {number} id Id of the accounting type for which you want to get the accounting system number depreciation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public accountingTypeGetAccountingNumberDepreciation(id: number, options?: any) {
        return AccountingTypeApiFp(this.configuration).accountingTypeGetAccountingNumberDepreciation(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAccountingSystemNumber() in AccountingType.php to get the accounting system number of the specified accounting type.
     * @summary Get accounting system number of the specified accounting type
     * @param {number} id Id of the accounting type for which you want to get the accounting system number
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public accountingTypeGetAccountingSystemNumber(id: number, embed?: Array<string>, options?: any) {
        return AccountingTypeApiFp(this.configuration).accountingTypeGetAccountingSystemNumber(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingType.php 
     * @summary Create a new accounting type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public addAccountingType(options?: any) {
        return AccountingTypeApiFp(this.configuration).addAccountingType(options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
     * @summary Create a new accounting type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public addAccountingTypeFactory(options?: any) {
        return AccountingTypeApiFp(this.configuration).addAccountingTypeFactory(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in AccountingType.php
     * @summary Delete an existing accounting type
     * @param {number} id id of accounting type you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public deleteAccountingType(id: number, options?: any) {
        return AccountingTypeApiFp(this.configuration).deleteAccountingType(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingType.php to get necessary variables.
     * @summary Get an overview of all accounting types
     * @param {number} [limit] Limits the number of entries returned. Default is 1000
     * @param {number} [offset] Set the index where the returned accounting types start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public getAccountingTypes(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AccountingTypeApiFp(this.configuration).getAccountingTypes(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AccountingType.php
     * @summary Update an existing accounting type
     * @param {number} id id of accounting type you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AccountingTypeApi
     */
    public updateAccountingType(id: number, options?: any) {
        return AccountingTypeApiFp(this.configuration).updateAccountingType(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AggregatorApi - fetch parameter creator
 * @export
 */
export const AggregatorApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls calcTotalDepreciation() in Aggregator.php to get total sum of all asset amounts for the year of the current query
         * @summary Calculates total sum of all asset amounts for the year of the current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorCalcTotalDepreciation(options: any = {}): FetchArgs {
            const localVarPath = `/Aggregator/calcTotalDepreciation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAccountingScore() in Aggregator.php to get your accounting score
         * @summary Get accounting score
         * @param {string} [startdate] Start date for the accounting score calculation
         * @param {string} [enddate] End date for the accounting score calculation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetAccountingScore(startdate?: string, enddate?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Aggregator/getAccountingScore`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (startdate !== undefined) {
                localVarQueryParameter['startdate'] = startdate;
            }

            if (enddate !== undefined) {
                localVarQueryParameter['enddate'] = enddate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAppRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard in the app
         * @summary Get the data which is displayed in the chart on the dashboard in the app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetAppRevenueChartData(options: any = {}): FetchArgs {
            const localVarPath = `/Aggregator/getAppRevenueChartData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getProfitAndLossCalculation() in Aggregator.php to calculate the profit and loss over a specified period.    The output of this function is divided into six groups:  * costs - all invoices/vouchers which contain a spending, again separated into direct [dc] and indirect costs [ic]  * earnings - all invoices/vouchers which contain a earning  * totalcosts  * totalearnings  * totalrevenue  * profit - the profit, difference between costs and earnings
         * @summary Calculates the profit and loss over a specified period
         * @param {string} startDate Start date of the period you want to calculate
         * @param {string} endDate End date of the period you want to calculate
         * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetProfitAndLossCalculation(startDate: string, endDate: string, actualTaxation: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling aggregatorGetProfitAndLossCalculation.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling aggregatorGetProfitAndLossCalculation.');
            }
            // verify required parameter 'actualTaxation' is not null or undefined
            if (actualTaxation === null || actualTaxation === undefined) {
                throw new RequiredError('actualTaxation','Required parameter actualTaxation was null or undefined when calling aggregatorGetProfitAndLossCalculation.');
            }
            const localVarPath = `/Aggregator/getProfitAndLossCalculation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (actualTaxation !== undefined) {
                localVarQueryParameter['actualTaxation'] = actualTaxation;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTaxInformation() in Aggregator.php to calculate tax of earnings and spending over a specified period.    This function will return:  * earningsSum (gross earnings), earningsSumNet (net earnings)  * earningsTax - tax on earnings  * expensesSum (gross expenses), expensesSumNet (net expenses)  * expensesTax - tax on expenses  * earningsTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * expensesTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * remainingTaxPayable - tax which is yet to be payed
         * @summary Calculates tax of earnings and spending over a specified period
         * @param {string} type Tax period you want to calculate with
         * @param {string} year Year of your tax calculation
         * @param {number} period Starting period (month) of your tax calculation
         * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
         * @param {boolean} noActualTaxationOnInputTax Specify if you want no actual taxation on input tax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetTaxInformation(type: string, year: string, period: number, actualTaxation: boolean, noActualTaxationOnInputTax: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'type' is not null or undefined
            if (type === null || type === undefined) {
                throw new RequiredError('type','Required parameter type was null or undefined when calling aggregatorGetTaxInformation.');
            }
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling aggregatorGetTaxInformation.');
            }
            // verify required parameter 'period' is not null or undefined
            if (period === null || period === undefined) {
                throw new RequiredError('period','Required parameter period was null or undefined when calling aggregatorGetTaxInformation.');
            }
            // verify required parameter 'actualTaxation' is not null or undefined
            if (actualTaxation === null || actualTaxation === undefined) {
                throw new RequiredError('actualTaxation','Required parameter actualTaxation was null or undefined when calling aggregatorGetTaxInformation.');
            }
            // verify required parameter 'noActualTaxationOnInputTax' is not null or undefined
            if (noActualTaxationOnInputTax === null || noActualTaxationOnInputTax === undefined) {
                throw new RequiredError('noActualTaxationOnInputTax','Required parameter noActualTaxationOnInputTax was null or undefined when calling aggregatorGetTaxInformation.');
            }
            const localVarPath = `/Aggregator/getTaxInformation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (period !== undefined) {
                localVarQueryParameter['period'] = period;
            }

            if (actualTaxation !== undefined) {
                localVarQueryParameter['actualTaxation'] = actualTaxation;
            }

            if (noActualTaxationOnInputTax !== undefined) {
                localVarQueryParameter['noActualTaxationOnInputTax'] = noActualTaxationOnInputTax;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getVoucherCategoryInformation() in Aggregator.php to get information about the categories of all vouchers in the year of the current query
         * @summary Get information about the categories of all vouchers in the year of the current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetVoucherCategoryInformation(options: any = {}): FetchArgs {
            const localVarPath = `/Aggregator/getVoucherCategoryInformation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getVoucherChartData() in Aggregator.php to get voucher chart data
         * @summary Get voucher chart data
         * @param {string} year Year for which you want to get the voucher chart data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetVoucherChartData(year: string, options: any = {}): FetchArgs {
            // verify required parameter 'year' is not null or undefined
            if (year === null || year === undefined) {
                throw new RequiredError('year','Required parameter year was null or undefined when calling aggregatorGetVoucherChartData.');
            }
            const localVarPath = `/Aggregator/getVoucherChartData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getWebRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard
         * @summary Get the data which is displayed in the chart on the dashboard
         * @param {boolean} [sumGrossToggle] Specify if you want to calculate sum gross instead of net
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetWebRevenueChartData(sumGrossToggle?: boolean, options: any = {}): FetchArgs {
            const localVarPath = `/Aggregator/getWebRevenueChartData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sumGrossToggle !== undefined) {
                localVarQueryParameter['sumGrossToggle'] = sumGrossToggle;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AggregatorApi - functional programming interface
 * @export
 */
export const AggregatorApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls calcTotalDepreciation() in Aggregator.php to get total sum of all asset amounts for the year of the current query
         * @summary Calculates total sum of all asset amounts for the year of the current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorCalcTotalDepreciation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorCalcTotalDepreciation(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAccountingScore() in Aggregator.php to get your accounting score
         * @summary Get accounting score
         * @param {string} [startdate] Start date for the accounting score calculation
         * @param {string} [enddate] End date for the accounting score calculation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetAccountingScore(startdate?: string, enddate?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorGetAccountingScore(startdate, enddate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAppRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard in the app
         * @summary Get the data which is displayed in the chart on the dashboard in the app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetAppRevenueChartData(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorGetAppRevenueChartData(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getProfitAndLossCalculation() in Aggregator.php to calculate the profit and loss over a specified period.    The output of this function is divided into six groups:  * costs - all invoices/vouchers which contain a spending, again separated into direct [dc] and indirect costs [ic]  * earnings - all invoices/vouchers which contain a earning  * totalcosts  * totalearnings  * totalrevenue  * profit - the profit, difference between costs and earnings
         * @summary Calculates the profit and loss over a specified period
         * @param {string} startDate Start date of the period you want to calculate
         * @param {string} endDate End date of the period you want to calculate
         * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetProfitAndLossCalculation(startDate: string, endDate: string, actualTaxation: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorGetProfitAndLossCalculation(startDate, endDate, actualTaxation, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTaxInformation() in Aggregator.php to calculate tax of earnings and spending over a specified period.    This function will return:  * earningsSum (gross earnings), earningsSumNet (net earnings)  * earningsTax - tax on earnings  * expensesSum (gross expenses), expensesSumNet (net expenses)  * expensesTax - tax on expenses  * earningsTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * expensesTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * remainingTaxPayable - tax which is yet to be payed
         * @summary Calculates tax of earnings and spending over a specified period
         * @param {string} type Tax period you want to calculate with
         * @param {string} year Year of your tax calculation
         * @param {number} period Starting period (month) of your tax calculation
         * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
         * @param {boolean} noActualTaxationOnInputTax Specify if you want no actual taxation on input tax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetTaxInformation(type: string, year: string, period: number, actualTaxation: boolean, noActualTaxationOnInputTax: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorGetTaxInformation(type, year, period, actualTaxation, noActualTaxationOnInputTax, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getVoucherCategoryInformation() in Aggregator.php to get information about the categories of all vouchers in the year of the current query
         * @summary Get information about the categories of all vouchers in the year of the current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetVoucherCategoryInformation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorGetVoucherCategoryInformation(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getVoucherChartData() in Aggregator.php to get voucher chart data
         * @summary Get voucher chart data
         * @param {string} year Year for which you want to get the voucher chart data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetVoucherChartData(year: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorGetVoucherChartData(year, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getWebRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard
         * @summary Get the data which is displayed in the chart on the dashboard
         * @param {boolean} [sumGrossToggle] Specify if you want to calculate sum gross instead of net
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetWebRevenueChartData(sumGrossToggle?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AggregatorApiFetchParamCreator(configuration).aggregatorGetWebRevenueChartData(sumGrossToggle, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AggregatorApi - factory interface
 * @export
 */
export const AggregatorApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls calcTotalDepreciation() in Aggregator.php to get total sum of all asset amounts for the year of the current query
         * @summary Calculates total sum of all asset amounts for the year of the current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorCalcTotalDepreciation(options?: any) {
            return AggregatorApiFp(configuration).aggregatorCalcTotalDepreciation(options)(fetch, basePath);
        },
        /**
         * Calls getAccountingScore() in Aggregator.php to get your accounting score
         * @summary Get accounting score
         * @param {string} [startdate] Start date for the accounting score calculation
         * @param {string} [enddate] End date for the accounting score calculation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetAccountingScore(startdate?: string, enddate?: string, options?: any) {
            return AggregatorApiFp(configuration).aggregatorGetAccountingScore(startdate, enddate, options)(fetch, basePath);
        },
        /**
         * Calls getAppRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard in the app
         * @summary Get the data which is displayed in the chart on the dashboard in the app
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetAppRevenueChartData(options?: any) {
            return AggregatorApiFp(configuration).aggregatorGetAppRevenueChartData(options)(fetch, basePath);
        },
        /**
         * Calls getProfitAndLossCalculation() in Aggregator.php to calculate the profit and loss over a specified period.    The output of this function is divided into six groups:  * costs - all invoices/vouchers which contain a spending, again separated into direct [dc] and indirect costs [ic]  * earnings - all invoices/vouchers which contain a earning  * totalcosts  * totalearnings  * totalrevenue  * profit - the profit, difference between costs and earnings
         * @summary Calculates the profit and loss over a specified period
         * @param {string} startDate Start date of the period you want to calculate
         * @param {string} endDate End date of the period you want to calculate
         * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetProfitAndLossCalculation(startDate: string, endDate: string, actualTaxation: boolean, options?: any) {
            return AggregatorApiFp(configuration).aggregatorGetProfitAndLossCalculation(startDate, endDate, actualTaxation, options)(fetch, basePath);
        },
        /**
         * Calls getTaxInformation() in Aggregator.php to calculate tax of earnings and spending over a specified period.    This function will return:  * earningsSum (gross earnings), earningsSumNet (net earnings)  * earningsTax - tax on earnings  * expensesSum (gross expenses), expensesSumNet (net expenses)  * expensesTax - tax on expenses  * earningsTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * expensesTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * remainingTaxPayable - tax which is yet to be payed
         * @summary Calculates tax of earnings and spending over a specified period
         * @param {string} type Tax period you want to calculate with
         * @param {string} year Year of your tax calculation
         * @param {number} period Starting period (month) of your tax calculation
         * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
         * @param {boolean} noActualTaxationOnInputTax Specify if you want no actual taxation on input tax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetTaxInformation(type: string, year: string, period: number, actualTaxation: boolean, noActualTaxationOnInputTax: boolean, options?: any) {
            return AggregatorApiFp(configuration).aggregatorGetTaxInformation(type, year, period, actualTaxation, noActualTaxationOnInputTax, options)(fetch, basePath);
        },
        /**
         * Calls getVoucherCategoryInformation() in Aggregator.php to get information about the categories of all vouchers in the year of the current query
         * @summary Get information about the categories of all vouchers in the year of the current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetVoucherCategoryInformation(options?: any) {
            return AggregatorApiFp(configuration).aggregatorGetVoucherCategoryInformation(options)(fetch, basePath);
        },
        /**
         * Calls getVoucherChartData() in Aggregator.php to get voucher chart data
         * @summary Get voucher chart data
         * @param {string} year Year for which you want to get the voucher chart data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetVoucherChartData(year: string, options?: any) {
            return AggregatorApiFp(configuration).aggregatorGetVoucherChartData(year, options)(fetch, basePath);
        },
        /**
         * Calls getWebRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard
         * @summary Get the data which is displayed in the chart on the dashboard
         * @param {boolean} [sumGrossToggle] Specify if you want to calculate sum gross instead of net
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        aggregatorGetWebRevenueChartData(sumGrossToggle?: boolean, options?: any) {
            return AggregatorApiFp(configuration).aggregatorGetWebRevenueChartData(sumGrossToggle, options)(fetch, basePath);
        },
    };
};

/**
 * AggregatorApi - object-oriented interface
 * @export
 * @class AggregatorApi
 * @extends {BaseAPI}
 */
export class AggregatorApi extends BaseAPI {
    /**
     * Calls calcTotalDepreciation() in Aggregator.php to get total sum of all asset amounts for the year of the current query
     * @summary Calculates total sum of all asset amounts for the year of the current query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorCalcTotalDepreciation(options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorCalcTotalDepreciation(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAccountingScore() in Aggregator.php to get your accounting score
     * @summary Get accounting score
     * @param {string} [startdate] Start date for the accounting score calculation
     * @param {string} [enddate] End date for the accounting score calculation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorGetAccountingScore(startdate?: string, enddate?: string, options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorGetAccountingScore(startdate, enddate, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAppRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard in the app
     * @summary Get the data which is displayed in the chart on the dashboard in the app
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorGetAppRevenueChartData(options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorGetAppRevenueChartData(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getProfitAndLossCalculation() in Aggregator.php to calculate the profit and loss over a specified period.    The output of this function is divided into six groups:  * costs - all invoices/vouchers which contain a spending, again separated into direct [dc] and indirect costs [ic]  * earnings - all invoices/vouchers which contain a earning  * totalcosts  * totalearnings  * totalrevenue  * profit - the profit, difference between costs and earnings
     * @summary Calculates the profit and loss over a specified period
     * @param {string} startDate Start date of the period you want to calculate
     * @param {string} endDate End date of the period you want to calculate
     * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorGetProfitAndLossCalculation(startDate: string, endDate: string, actualTaxation: boolean, options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorGetProfitAndLossCalculation(startDate, endDate, actualTaxation, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTaxInformation() in Aggregator.php to calculate tax of earnings and spending over a specified period.    This function will return:  * earningsSum (gross earnings), earningsSumNet (net earnings)  * earningsTax - tax on earnings  * expensesSum (gross expenses), expensesSumNet (net expenses)  * expensesTax - tax on expenses  * earningsTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * expensesTaxGroups - list of invoices/vouchers which involved a taxation, separated into tax groups  * remainingTaxPayable - tax which is yet to be payed
     * @summary Calculates tax of earnings and spending over a specified period
     * @param {string} type Tax period you want to calculate with
     * @param {string} year Year of your tax calculation
     * @param {number} period Starting period (month) of your tax calculation
     * @param {boolean} actualTaxation Specify if you want to calculate the net income method (true) or the profit and loss (false)
     * @param {boolean} noActualTaxationOnInputTax Specify if you want no actual taxation on input tax
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorGetTaxInformation(type: string, year: string, period: number, actualTaxation: boolean, noActualTaxationOnInputTax: boolean, options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorGetTaxInformation(type, year, period, actualTaxation, noActualTaxationOnInputTax, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getVoucherCategoryInformation() in Aggregator.php to get information about the categories of all vouchers in the year of the current query
     * @summary Get information about the categories of all vouchers in the year of the current query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorGetVoucherCategoryInformation(options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorGetVoucherCategoryInformation(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getVoucherChartData() in Aggregator.php to get voucher chart data
     * @summary Get voucher chart data
     * @param {string} year Year for which you want to get the voucher chart data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorGetVoucherChartData(year: string, options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorGetVoucherChartData(year, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getWebRevenueChartData() in Aggregator.php to get data displayed in the revenue chart on the dashboard
     * @summary Get the data which is displayed in the chart on the dashboard
     * @param {boolean} [sumGrossToggle] Specify if you want to calculate sum gross instead of net
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AggregatorApi
     */
    public aggregatorGetWebRevenueChartData(sumGrossToggle?: boolean, options?: any) {
        return AggregatorApiFp(this.configuration).aggregatorGetWebRevenueChartData(sumGrossToggle, options)(this.fetch, this.basePath);
    }

}
/**
 * AssetApi - fetch parameter creator
 * @export
 */
export const AssetApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Asset.php 
         * @summary Create a new asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset(options: any = {}): FetchArgs {
            const localVarPath = `/Asset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDepreciationAmount() in Asset.php to get the depreciation ammount of the specified asset for the given year/month
         * @summary Get depreciation amount of the specified asset for the given year/month
         * @param {number} id Id of the asset of which you want to get the depreciation amount
         * @param {string} [year] year for which you want to get the depreciation amount
         * @param {string} [month] month for which you want to get the depreciation amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetDepreciationAmount(id: number, year?: string, month?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assetGetDepreciationAmount.');
            }
            const localVarPath = `/Asset/{id}/getDepreciationAmount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getResidualValue() in Asset.php to get the residual value of the specified asset for the given year/month
         * @summary Get residual value of the specified asset for the given year/month
         * @param {number} id Id of the asset of which you want to get the residual value
         * @param {string} [year] year for which you want to get the residual value
         * @param {string} [month] month for which you want to get the residual value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetResidualValue(id: number, year?: string, month?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assetGetResidualValue.');
            }
            const localVarPath = `/Asset/{id}/getResidualValue`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (year !== undefined) {
                localVarQueryParameter['year'] = year;
            }

            if (month !== undefined) {
                localVarQueryParameter['month'] = month;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getVoucher() in Asset.php to get the voucher of the specified asset
         * @summary Get voucher of the specified asset
         * @param {number} id Id of the asset of which you want to get the voucher
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetVoucher(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling assetGetVoucher.');
            }
            const localVarPath = `/Asset/{id}/getVoucher`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Asset.php
         * @summary Delete an existing asset
         * @param {number} id id of asset you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAsset.');
            }
            const localVarPath = `/Asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Asset.php to get necessary variables.
         * @summary Get an overview of all assets
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned assets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Asset`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Asset.php
         * @summary Update an existing asset
         * @param {number} id id of asset you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAsset.');
            }
            const localVarPath = `/Asset/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetApi - functional programming interface
 * @export
 */
export const AssetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Asset.php 
         * @summary Create a new asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAsset> {
            const localVarFetchArgs = AssetApiFetchParamCreator(configuration).addAsset(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDepreciationAmount() in Asset.php to get the depreciation ammount of the specified asset for the given year/month
         * @summary Get depreciation amount of the specified asset for the given year/month
         * @param {number} id Id of the asset of which you want to get the depreciation amount
         * @param {string} [year] year for which you want to get the depreciation amount
         * @param {string} [month] month for which you want to get the depreciation amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetDepreciationAmount(id: number, year?: string, month?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetApiFetchParamCreator(configuration).assetGetDepreciationAmount(id, year, month, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getResidualValue() in Asset.php to get the residual value of the specified asset for the given year/month
         * @summary Get residual value of the specified asset for the given year/month
         * @param {number} id Id of the asset of which you want to get the residual value
         * @param {string} [year] year for which you want to get the residual value
         * @param {string} [month] month for which you want to get the residual value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetResidualValue(id: number, year?: string, month?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetApiFetchParamCreator(configuration).assetGetResidualValue(id, year, month, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getVoucher() in Asset.php to get the voucher of the specified asset
         * @summary Get voucher of the specified asset
         * @param {number} id Id of the asset of which you want to get the voucher
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetVoucher(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucher> {
            const localVarFetchArgs = AssetApiFetchParamCreator(configuration).assetGetVoucher(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Asset.php
         * @summary Delete an existing asset
         * @param {number} id id of asset you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetApiFetchParamCreator(configuration).deleteAsset(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Asset.php to get necessary variables.
         * @summary Get an overview of all assets
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned assets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAsset> {
            const localVarFetchArgs = AssetApiFetchParamCreator(configuration).getAssets(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Asset.php
         * @summary Update an existing asset
         * @param {number} id id of asset you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAsset> {
            const localVarFetchArgs = AssetApiFetchParamCreator(configuration).updateAsset(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetApi - factory interface
 * @export
 */
export const AssetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Asset.php 
         * @summary Create a new asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAsset(options?: any) {
            return AssetApiFp(configuration).addAsset(options)(fetch, basePath);
        },
        /**
         * Calls getDepreciationAmount() in Asset.php to get the depreciation ammount of the specified asset for the given year/month
         * @summary Get depreciation amount of the specified asset for the given year/month
         * @param {number} id Id of the asset of which you want to get the depreciation amount
         * @param {string} [year] year for which you want to get the depreciation amount
         * @param {string} [month] month for which you want to get the depreciation amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetDepreciationAmount(id: number, year?: string, month?: string, options?: any) {
            return AssetApiFp(configuration).assetGetDepreciationAmount(id, year, month, options)(fetch, basePath);
        },
        /**
         * Calls getResidualValue() in Asset.php to get the residual value of the specified asset for the given year/month
         * @summary Get residual value of the specified asset for the given year/month
         * @param {number} id Id of the asset of which you want to get the residual value
         * @param {string} [year] year for which you want to get the residual value
         * @param {string} [month] month for which you want to get the residual value
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetResidualValue(id: number, year?: string, month?: string, options?: any) {
            return AssetApiFp(configuration).assetGetResidualValue(id, year, month, options)(fetch, basePath);
        },
        /**
         * Calls getVoucher() in Asset.php to get the voucher of the specified asset
         * @summary Get voucher of the specified asset
         * @param {number} id Id of the asset of which you want to get the voucher
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        assetGetVoucher(id: number, embed?: Array<string>, options?: any) {
            return AssetApiFp(configuration).assetGetVoucher(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Asset.php
         * @summary Delete an existing asset
         * @param {number} id id of asset you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAsset(id: number, options?: any) {
            return AssetApiFp(configuration).deleteAsset(id, options)(fetch, basePath);
        },
        /**
         * Calls Asset.php to get necessary variables.
         * @summary Get an overview of all assets
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned assets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssets(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AssetApiFp(configuration).getAssets(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls Asset.php
         * @summary Update an existing asset
         * @param {number} id id of asset you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAsset(id: number, options?: any) {
            return AssetApiFp(configuration).updateAsset(id, options)(fetch, basePath);
        },
    };
};

/**
 * AssetApi - object-oriented interface
 * @export
 * @class AssetApi
 * @extends {BaseAPI}
 */
export class AssetApi extends BaseAPI {
    /**
     * Calls Asset.php 
     * @summary Create a new asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public addAsset(options?: any) {
        return AssetApiFp(this.configuration).addAsset(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDepreciationAmount() in Asset.php to get the depreciation ammount of the specified asset for the given year/month
     * @summary Get depreciation amount of the specified asset for the given year/month
     * @param {number} id Id of the asset of which you want to get the depreciation amount
     * @param {string} [year] year for which you want to get the depreciation amount
     * @param {string} [month] month for which you want to get the depreciation amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetGetDepreciationAmount(id: number, year?: string, month?: string, options?: any) {
        return AssetApiFp(this.configuration).assetGetDepreciationAmount(id, year, month, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getResidualValue() in Asset.php to get the residual value of the specified asset for the given year/month
     * @summary Get residual value of the specified asset for the given year/month
     * @param {number} id Id of the asset of which you want to get the residual value
     * @param {string} [year] year for which you want to get the residual value
     * @param {string} [month] month for which you want to get the residual value
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetGetResidualValue(id: number, year?: string, month?: string, options?: any) {
        return AssetApiFp(this.configuration).assetGetResidualValue(id, year, month, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getVoucher() in Asset.php to get the voucher of the specified asset
     * @summary Get voucher of the specified asset
     * @param {number} id Id of the asset of which you want to get the voucher
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public assetGetVoucher(id: number, embed?: Array<string>, options?: any) {
        return AssetApiFp(this.configuration).assetGetVoucher(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Asset.php
     * @summary Delete an existing asset
     * @param {number} id id of asset you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public deleteAsset(id: number, options?: any) {
        return AssetApiFp(this.configuration).deleteAsset(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Asset.php to get necessary variables.
     * @summary Get an overview of all assets
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned assets start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public getAssets(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AssetApiFp(this.configuration).getAssets(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Asset.php
     * @summary Update an existing asset
     * @param {number} id id of asset you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetApi
     */
    public updateAsset(id: number, options?: any) {
        return AssetApiFp(this.configuration).updateAsset(id, options)(this.fetch, this.basePath);
    }

}
/**
 * AssetPosApi - fetch parameter creator
 * @export
 */
export const AssetPosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls AssetPos.php 
         * @summary Create a new asset position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetPos(options: any = {}): FetchArgs {
            const localVarPath = `/AssetPos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in AssetPos.php
         * @summary Delete an existing asset position
         * @param {number} id id of asset position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetPosition(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteAssetPosition.');
            }
            const localVarPath = `/AssetPos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AssetPos.php to get necessary variables.
         * @summary Get an overview of all asset positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned assets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetPositions(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/AssetPos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls AssetPos.php
         * @summary Update an existing asset position
         * @param {number} id id of asset position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetPosition(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateAssetPosition.');
            }
            const localVarPath = `/AssetPos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * AssetPosApi - functional programming interface
 * @export
 */
export const AssetPosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls AssetPos.php 
         * @summary Create a new asset position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetPos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAssetPos> {
            const localVarFetchArgs = AssetPosApiFetchParamCreator(configuration).addAssetPos(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in AssetPos.php
         * @summary Delete an existing asset position
         * @param {number} id id of asset position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetPosition(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = AssetPosApiFetchParamCreator(configuration).deleteAssetPosition(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AssetPos.php to get necessary variables.
         * @summary Get an overview of all asset positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned assets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAssetPos> {
            const localVarFetchArgs = AssetPosApiFetchParamCreator(configuration).getAssetPositions(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls AssetPos.php
         * @summary Update an existing asset position
         * @param {number} id id of asset position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetPosition(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAssetPos> {
            const localVarFetchArgs = AssetPosApiFetchParamCreator(configuration).updateAssetPosition(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * AssetPosApi - factory interface
 * @export
 */
export const AssetPosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls AssetPos.php 
         * @summary Create a new asset position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAssetPos(options?: any) {
            return AssetPosApiFp(configuration).addAssetPos(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in AssetPos.php
         * @summary Delete an existing asset position
         * @param {number} id id of asset position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteAssetPosition(id: number, options?: any) {
            return AssetPosApiFp(configuration).deleteAssetPosition(id, options)(fetch, basePath);
        },
        /**
         * Calls AssetPos.php to get necessary variables.
         * @summary Get an overview of all asset positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned assets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getAssetPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return AssetPosApiFp(configuration).getAssetPositions(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls AssetPos.php
         * @summary Update an existing asset position
         * @param {number} id id of asset position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateAssetPosition(id: number, options?: any) {
            return AssetPosApiFp(configuration).updateAssetPosition(id, options)(fetch, basePath);
        },
    };
};

/**
 * AssetPosApi - object-oriented interface
 * @export
 * @class AssetPosApi
 * @extends {BaseAPI}
 */
export class AssetPosApi extends BaseAPI {
    /**
     * Calls AssetPos.php 
     * @summary Create a new asset position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetPosApi
     */
    public addAssetPos(options?: any) {
        return AssetPosApiFp(this.configuration).addAssetPos(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in AssetPos.php
     * @summary Delete an existing asset position
     * @param {number} id id of asset position you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetPosApi
     */
    public deleteAssetPosition(id: number, options?: any) {
        return AssetPosApiFp(this.configuration).deleteAssetPosition(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AssetPos.php to get necessary variables.
     * @summary Get an overview of all asset positions
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned assets start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetPosApi
     */
    public getAssetPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return AssetPosApiFp(this.configuration).getAssetPositions(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls AssetPos.php
     * @summary Update an existing asset position
     * @param {number} id id of asset position you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof AssetPosApi
     */
    public updateAssetPosition(id: number, options?: any) {
        return AssetPosApiFp(this.configuration).updateAssetPosition(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CategoryApi - fetch parameter creator
 * @export
 */
export const CategoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Category.php 
         * @summary Create a new category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(options: any = {}): FetchArgs {
            const localVarPath = `/Category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Category.php
         * @summary Delete an existing category
         * @param {number} id id of category you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCategory.');
            }
            const localVarPath = `/Category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Category.php to get necessary variables.
         * @summary Get an overview of all categories
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned categories start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Category`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Category.php
         * @summary Update a existing category
         * @param {number} id id of category you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCategory.');
            }
            const localVarPath = `/Category/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CategoryApi - functional programming interface
 * @export
 */
export const CategoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Category.php 
         * @summary Create a new category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCategory> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).addCategory(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Category.php
         * @summary Delete an existing category
         * @param {number} id id of category you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).deleteCategory(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Category.php to get necessary variables.
         * @summary Get an overview of all categories
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned categories start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCategory> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).getCategories(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Category.php
         * @summary Update a existing category
         * @param {number} id id of category you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCategory> {
            const localVarFetchArgs = CategoryApiFetchParamCreator(configuration).updateCategory(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CategoryApi - factory interface
 * @export
 */
export const CategoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Category.php 
         * @summary Create a new category
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCategory(options?: any) {
            return CategoryApiFp(configuration).addCategory(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Category.php
         * @summary Delete an existing category
         * @param {number} id id of category you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCategory(id: number, options?: any) {
            return CategoryApiFp(configuration).deleteCategory(id, options)(fetch, basePath);
        },
        /**
         * Calls Category.php to get necessary variables.
         * @summary Get an overview of all categories
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned categories start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCategories(limit?: number, offset?: number, options?: any) {
            return CategoryApiFp(configuration).getCategories(limit, offset, options)(fetch, basePath);
        },
        /**
         * Calls Category.php
         * @summary Update a existing category
         * @param {number} id id of category you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCategory(id: number, options?: any) {
            return CategoryApiFp(configuration).updateCategory(id, options)(fetch, basePath);
        },
    };
};

/**
 * CategoryApi - object-oriented interface
 * @export
 * @class CategoryApi
 * @extends {BaseAPI}
 */
export class CategoryApi extends BaseAPI {
    /**
     * Calls Category.php 
     * @summary Create a new category
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public addCategory(options?: any) {
        return CategoryApiFp(this.configuration).addCategory(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Category.php
     * @summary Delete an existing category
     * @param {number} id id of category you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public deleteCategory(id: number, options?: any) {
        return CategoryApiFp(this.configuration).deleteCategory(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Category.php to get necessary variables.
     * @summary Get an overview of all categories
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned categories start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public getCategories(limit?: number, offset?: number, options?: any) {
        return CategoryApiFp(this.configuration).getCategories(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Category.php
     * @summary Update a existing category
     * @param {number} id id of category you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CategoryApi
     */
    public updateCategory(id: number, options?: any) {
        return CategoryApiFp(this.configuration).updateCategory(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CheckAccountApi - fetch parameter creator
 * @export
 */
export const CheckAccountApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls CheckAccount.php to create a check account
         * @summary Create a new check account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccount(options: any = {}): FetchArgs {
            const localVarPath = `/CheckAccount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCurrentBalance() in CheckAccount.php to get the balance of the specified check account.
         * @summary Get current balance of the specified check account
         * @param {number} id Id of the check account of which you want the current balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGetCurrentBalance(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling checkAccountGetCurrentBalance.');
            }
            const localVarPath = `/CheckAccount/{id}/getCurrentBalance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPaymentIsSupported() in CheckAccount.php to get if a payment method is supported.
         * @summary Return if a payment method is supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGetPaymentIsSupported(options: any = {}): FetchArgs {
            const localVarPath = `/CheckAccount/getPaymentIsSupported`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls setDefault() in CheckAccount.php to set a specified check account as the default check account
         * @summary Set the specified check accounts as the default check account
         * @param {number} id Id of check account you want to set as the default check account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountSetDefault(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling checkAccountSetDefault.');
            }
            const localVarPath = `/CheckAccount/{id}/setDefault`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls transfer() in CheckAccount.php to transfer an amount from one check account to another
         * @summary Transfer an amount from one check account to another
         * @param {number} id Id of check account you want to use as source account
         * @param {string} amount Amount you want to transfer
         * @param {number} targetId Target check account id
         * @param {string} targetObjectName Target check account object name
         * @param {string} date Date of the transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransfer(id: number, amount: string, targetId: number, targetObjectName: string, date: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling checkAccountTransfer.');
            }
            // verify required parameter 'amount' is not null or undefined
            if (amount === null || amount === undefined) {
                throw new RequiredError('amount','Required parameter amount was null or undefined when calling checkAccountTransfer.');
            }
            // verify required parameter 'targetId' is not null or undefined
            if (targetId === null || targetId === undefined) {
                throw new RequiredError('targetId','Required parameter targetId was null or undefined when calling checkAccountTransfer.');
            }
            // verify required parameter 'targetObjectName' is not null or undefined
            if (targetObjectName === null || targetObjectName === undefined) {
                throw new RequiredError('targetObjectName','Required parameter targetObjectName was null or undefined when calling checkAccountTransfer.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling checkAccountTransfer.');
            }
            const localVarPath = `/CheckAccount/{id}/transfer`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (amount !== undefined) {
                localVarQueryParameter['amount'] = amount;
            }

            if (targetId !== undefined) {
                localVarQueryParameter['target[id]'] = targetId;
            }

            if (targetObjectName !== undefined) {
                localVarQueryParameter['target[objectName]'] = targetObjectName;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in CheckAccount.php
         * @summary Delete an existing check account
         * @param {number} id Id of check account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCheckAccount.');
            }
            const localVarPath = `/CheckAccount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CheckAccount.php to get necessary variables.
         * @summary Get an overview of all check accounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccounts(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/CheckAccount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CheckAccount.php to update a check account
         * @summary Update an existing check account
         * @param {number} id Id of check account you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCheckAccount.');
            }
            const localVarPath = `/CheckAccount/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckAccountApi - functional programming interface
 * @export
 */
export const CheckAccountApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls CheckAccount.php to create a check account
         * @summary Create a new check account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccount> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).addCheckAccount(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCurrentBalance() in CheckAccount.php to get the balance of the specified check account.
         * @summary Get current balance of the specified check account
         * @param {number} id Id of the check account of which you want the current balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGetCurrentBalance(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).checkAccountGetCurrentBalance(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPaymentIsSupported() in CheckAccount.php to get if a payment method is supported.
         * @summary Return if a payment method is supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGetPaymentIsSupported(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).checkAccountGetPaymentIsSupported(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls setDefault() in CheckAccount.php to set a specified check account as the default check account
         * @summary Set the specified check accounts as the default check account
         * @param {number} id Id of check account you want to set as the default check account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountSetDefault(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).checkAccountSetDefault(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls transfer() in CheckAccount.php to transfer an amount from one check account to another
         * @summary Transfer an amount from one check account to another
         * @param {number} id Id of check account you want to use as source account
         * @param {string} amount Amount you want to transfer
         * @param {number} targetId Target check account id
         * @param {string} targetObjectName Target check account object name
         * @param {string} date Date of the transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransfer(id: number, amount: string, targetId: number, targetObjectName: string, date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).checkAccountTransfer(id, amount, targetId, targetObjectName, date, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in CheckAccount.php
         * @summary Delete an existing check account
         * @param {number} id Id of check account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).deleteCheckAccount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CheckAccount.php to get necessary variables.
         * @summary Get an overview of all check accounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccounts(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDiscounts> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).getCheckAccounts(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CheckAccount.php to update a check account
         * @summary Update an existing check account
         * @param {number} id Id of check account you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccount> {
            const localVarFetchArgs = CheckAccountApiFetchParamCreator(configuration).updateCheckAccount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckAccountApi - factory interface
 * @export
 */
export const CheckAccountApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls CheckAccount.php to create a check account
         * @summary Create a new check account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccount(options?: any) {
            return CheckAccountApiFp(configuration).addCheckAccount(options)(fetch, basePath);
        },
        /**
         * Calls getCurrentBalance() in CheckAccount.php to get the balance of the specified check account.
         * @summary Get current balance of the specified check account
         * @param {number} id Id of the check account of which you want the current balance
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGetCurrentBalance(id: number, options?: any) {
            return CheckAccountApiFp(configuration).checkAccountGetCurrentBalance(id, options)(fetch, basePath);
        },
        /**
         * Calls getPaymentIsSupported() in CheckAccount.php to get if a payment method is supported.
         * @summary Return if a payment method is supported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountGetPaymentIsSupported(options?: any) {
            return CheckAccountApiFp(configuration).checkAccountGetPaymentIsSupported(options)(fetch, basePath);
        },
        /**
         * Calls setDefault() in CheckAccount.php to set a specified check account as the default check account
         * @summary Set the specified check accounts as the default check account
         * @param {number} id Id of check account you want to set as the default check account
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountSetDefault(id: number, options?: any) {
            return CheckAccountApiFp(configuration).checkAccountSetDefault(id, options)(fetch, basePath);
        },
        /**
         * Calls transfer() in CheckAccount.php to transfer an amount from one check account to another
         * @summary Transfer an amount from one check account to another
         * @param {number} id Id of check account you want to use as source account
         * @param {string} amount Amount you want to transfer
         * @param {number} targetId Target check account id
         * @param {string} targetObjectName Target check account object name
         * @param {string} date Date of the transfer
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransfer(id: number, amount: string, targetId: number, targetObjectName: string, date: string, options?: any) {
            return CheckAccountApiFp(configuration).checkAccountTransfer(id, amount, targetId, targetObjectName, date, options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in CheckAccount.php
         * @summary Delete an existing check account
         * @param {number} id Id of check account you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccount(id: number, options?: any) {
            return CheckAccountApiFp(configuration).deleteCheckAccount(id, options)(fetch, basePath);
        },
        /**
         * Calls CheckAccount.php to get necessary variables.
         * @summary Get an overview of all check accounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccounts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return CheckAccountApiFp(configuration).getCheckAccounts(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls CheckAccount.php to update a check account
         * @summary Update an existing check account
         * @param {number} id Id of check account you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccount(id: number, options?: any) {
            return CheckAccountApiFp(configuration).updateCheckAccount(id, options)(fetch, basePath);
        },
    };
};

/**
 * CheckAccountApi - object-oriented interface
 * @export
 * @class CheckAccountApi
 * @extends {BaseAPI}
 */
export class CheckAccountApi extends BaseAPI {
    /**
     * Calls CheckAccount.php to create a check account
     * @summary Create a new check account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public addCheckAccount(options?: any) {
        return CheckAccountApiFp(this.configuration).addCheckAccount(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCurrentBalance() in CheckAccount.php to get the balance of the specified check account.
     * @summary Get current balance of the specified check account
     * @param {number} id Id of the check account of which you want the current balance
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public checkAccountGetCurrentBalance(id: number, options?: any) {
        return CheckAccountApiFp(this.configuration).checkAccountGetCurrentBalance(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPaymentIsSupported() in CheckAccount.php to get if a payment method is supported.
     * @summary Return if a payment method is supported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public checkAccountGetPaymentIsSupported(options?: any) {
        return CheckAccountApiFp(this.configuration).checkAccountGetPaymentIsSupported(options)(this.fetch, this.basePath);
    }

    /**
     * Calls setDefault() in CheckAccount.php to set a specified check account as the default check account
     * @summary Set the specified check accounts as the default check account
     * @param {number} id Id of check account you want to set as the default check account
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public checkAccountSetDefault(id: number, options?: any) {
        return CheckAccountApiFp(this.configuration).checkAccountSetDefault(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls transfer() in CheckAccount.php to transfer an amount from one check account to another
     * @summary Transfer an amount from one check account to another
     * @param {number} id Id of check account you want to use as source account
     * @param {string} amount Amount you want to transfer
     * @param {number} targetId Target check account id
     * @param {string} targetObjectName Target check account object name
     * @param {string} date Date of the transfer
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public checkAccountTransfer(id: number, amount: string, targetId: number, targetObjectName: string, date: string, options?: any) {
        return CheckAccountApiFp(this.configuration).checkAccountTransfer(id, amount, targetId, targetObjectName, date, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in CheckAccount.php
     * @summary Delete an existing check account
     * @param {number} id Id of check account you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public deleteCheckAccount(id: number, options?: any) {
        return CheckAccountApiFp(this.configuration).deleteCheckAccount(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CheckAccount.php to get necessary variables.
     * @summary Get an overview of all check accounts
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public getCheckAccounts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return CheckAccountApiFp(this.configuration).getCheckAccounts(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CheckAccount.php to update a check account
     * @summary Update an existing check account
     * @param {number} id Id of check account you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountApi
     */
    public updateCheckAccount(id: number, options?: any) {
        return CheckAccountApiFp(this.configuration).updateCheckAccount(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CheckAccountTransactionApi - fetch parameter creator
 * @export
 */
export const CheckAccountTransactionApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls CheckAccountTransaction.php 
         * @summary Create a new check account transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccountTransaction(options: any = {}): FetchArgs {
            const localVarPath = `/CheckAccountTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getLog() in CheckAccountTransaction.php to get the log of a specified check account transaction.
         * @summary Get log of a specified check account transaction
         * @param {number} id Id of the check account transaction of which you want to get the log
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransactionGetLog(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling checkAccountTransactionGetLog.');
            }
            const localVarPath = `/CheckAccountTransaction/{id}/getLog`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getRemainingAmount() in CheckAccountTransaction.php to get invoice amount which is not assigned yet.
         * @summary Get invoice amount which is not assigned yet
         * @param {number} id Id of check account transaction you want to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransactionGetRemainingAmount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling checkAccountTransactionGetRemainingAmount.');
            }
            const localVarPath = `/CheckAccountTransaction/{id}/getRemainingAmount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in CheckAccountTransaction.php
         * @summary Delete an existing check account transaction
         * @param {number} id id of check account transaction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccountTransaction(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCheckAccountTransaction.');
            }
            const localVarPath = `/CheckAccountTransaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CheckAccountTransaction.php to get necessary variables.
         * @summary Get an overview of all check account transactions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check account transactions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccountTransactions(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/CheckAccountTransaction`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls linkInvoice() in CheckAccountTransaction.php.      This will update the specified invoice as well as the status of the check account transaction!
         * @summary link invoice to check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkInvoiceToCheckAccountTransaction(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkInvoiceToCheckAccountTransaction.');
            }
            const localVarPath = `/CheckAccountTransaction/{id}/linkInvoice`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls linkVoucher() in CheckAccountTransaction.php.      This will update the specified voucher as well as the status of the check account transaction!
         * @summary link voucher to check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVoucherToCheckAccountTransaction(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling linkVoucherToCheckAccountTransaction.');
            }
            const localVarPath = `/CheckAccountTransaction/{id}/linkVoucher`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CheckAccountTransaction.php
         * @summary Update a existing check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransaction(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCheckAccountTransaction.');
            }
            const localVarPath = `/CheckAccountTransaction/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls changeStatus() in CheckAccountTransaction.php
         * @summary Update status of a existing check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransactionStatus(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCheckAccountTransactionStatus.');
            }
            const localVarPath = `/CheckAccountTransaction/{id}/changeStatus`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckAccountTransactionApi - functional programming interface
 * @export
 */
export const CheckAccountTransactionApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls CheckAccountTransaction.php 
         * @summary Create a new check account transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccountTransaction(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransaction> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).addCheckAccountTransaction(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getLog() in CheckAccountTransaction.php to get the log of a specified check account transaction.
         * @summary Get log of a specified check account transaction
         * @param {number} id Id of the check account transaction of which you want to get the log
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransactionGetLog(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransactionLog> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).checkAccountTransactionGetLog(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getRemainingAmount() in CheckAccountTransaction.php to get invoice amount which is not assigned yet.
         * @summary Get invoice amount which is not assigned yet
         * @param {number} id Id of check account transaction you want to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransactionGetRemainingAmount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).checkAccountTransactionGetRemainingAmount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in CheckAccountTransaction.php
         * @summary Delete an existing check account transaction
         * @param {number} id id of check account transaction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccountTransaction(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).deleteCheckAccountTransaction(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CheckAccountTransaction.php to get necessary variables.
         * @summary Get an overview of all check account transactions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check account transactions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccountTransactions(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransaction> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).getCheckAccountTransactions(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls linkInvoice() in CheckAccountTransaction.php.      This will update the specified invoice as well as the status of the check account transaction!
         * @summary link invoice to check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkInvoiceToCheckAccountTransaction(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransaction> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).linkInvoiceToCheckAccountTransaction(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls linkVoucher() in CheckAccountTransaction.php.      This will update the specified voucher as well as the status of the check account transaction!
         * @summary link voucher to check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVoucherToCheckAccountTransaction(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransaction> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).linkVoucherToCheckAccountTransaction(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CheckAccountTransaction.php
         * @summary Update a existing check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransaction(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransaction> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).updateCheckAccountTransaction(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls changeStatus() in CheckAccountTransaction.php
         * @summary Update status of a existing check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransactionStatus(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransaction> {
            const localVarFetchArgs = CheckAccountTransactionApiFetchParamCreator(configuration).updateCheckAccountTransactionStatus(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckAccountTransactionApi - factory interface
 * @export
 */
export const CheckAccountTransactionApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls CheckAccountTransaction.php 
         * @summary Create a new check account transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccountTransaction(options?: any) {
            return CheckAccountTransactionApiFp(configuration).addCheckAccountTransaction(options)(fetch, basePath);
        },
        /**
         * Calls getLog() in CheckAccountTransaction.php to get the log of a specified check account transaction.
         * @summary Get log of a specified check account transaction
         * @param {number} id Id of the check account transaction of which you want to get the log
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransactionGetLog(id: number, embed?: Array<string>, options?: any) {
            return CheckAccountTransactionApiFp(configuration).checkAccountTransactionGetLog(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getRemainingAmount() in CheckAccountTransaction.php to get invoice amount which is not assigned yet.
         * @summary Get invoice amount which is not assigned yet
         * @param {number} id Id of check account transaction you want to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        checkAccountTransactionGetRemainingAmount(id: number, options?: any) {
            return CheckAccountTransactionApiFp(configuration).checkAccountTransactionGetRemainingAmount(id, options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in CheckAccountTransaction.php
         * @summary Delete an existing check account transaction
         * @param {number} id id of check account transaction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccountTransaction(id: number, options?: any) {
            return CheckAccountTransactionApiFp(configuration).deleteCheckAccountTransaction(id, options)(fetch, basePath);
        },
        /**
         * Calls CheckAccountTransaction.php to get necessary variables.
         * @summary Get an overview of all check account transactions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check account transactions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccountTransactions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return CheckAccountTransactionApiFp(configuration).getCheckAccountTransactions(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls linkInvoice() in CheckAccountTransaction.php.      This will update the specified invoice as well as the status of the check account transaction!
         * @summary link invoice to check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkInvoiceToCheckAccountTransaction(id: number, options?: any) {
            return CheckAccountTransactionApiFp(configuration).linkInvoiceToCheckAccountTransaction(id, options)(fetch, basePath);
        },
        /**
         * Calls linkVoucher() in CheckAccountTransaction.php.      This will update the specified voucher as well as the status of the check account transaction!
         * @summary link voucher to check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        linkVoucherToCheckAccountTransaction(id: number, options?: any) {
            return CheckAccountTransactionApiFp(configuration).linkVoucherToCheckAccountTransaction(id, options)(fetch, basePath);
        },
        /**
         * Calls CheckAccountTransaction.php
         * @summary Update a existing check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransaction(id: number, options?: any) {
            return CheckAccountTransactionApiFp(configuration).updateCheckAccountTransaction(id, options)(fetch, basePath);
        },
        /**
         * Calls changeStatus() in CheckAccountTransaction.php
         * @summary Update status of a existing check account transaction
         * @param {number} id id of check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransactionStatus(id: number, options?: any) {
            return CheckAccountTransactionApiFp(configuration).updateCheckAccountTransactionStatus(id, options)(fetch, basePath);
        },
    };
};

/**
 * CheckAccountTransactionApi - object-oriented interface
 * @export
 * @class CheckAccountTransactionApi
 * @extends {BaseAPI}
 */
export class CheckAccountTransactionApi extends BaseAPI {
    /**
     * Calls CheckAccountTransaction.php 
     * @summary Create a new check account transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public addCheckAccountTransaction(options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).addCheckAccountTransaction(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getLog() in CheckAccountTransaction.php to get the log of a specified check account transaction.
     * @summary Get log of a specified check account transaction
     * @param {number} id Id of the check account transaction of which you want to get the log
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public checkAccountTransactionGetLog(id: number, embed?: Array<string>, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).checkAccountTransactionGetLog(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getRemainingAmount() in CheckAccountTransaction.php to get invoice amount which is not assigned yet.
     * @summary Get invoice amount which is not assigned yet
     * @param {number} id Id of check account transaction you want to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public checkAccountTransactionGetRemainingAmount(id: number, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).checkAccountTransactionGetRemainingAmount(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in CheckAccountTransaction.php
     * @summary Delete an existing check account transaction
     * @param {number} id id of check account transaction you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public deleteCheckAccountTransaction(id: number, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).deleteCheckAccountTransaction(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CheckAccountTransaction.php to get necessary variables.
     * @summary Get an overview of all check account transactions
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned check account transactions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public getCheckAccountTransactions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).getCheckAccountTransactions(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls linkInvoice() in CheckAccountTransaction.php.      This will update the specified invoice as well as the status of the check account transaction!
     * @summary link invoice to check account transaction
     * @param {number} id id of check account transaction you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public linkInvoiceToCheckAccountTransaction(id: number, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).linkInvoiceToCheckAccountTransaction(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls linkVoucher() in CheckAccountTransaction.php.      This will update the specified voucher as well as the status of the check account transaction!
     * @summary link voucher to check account transaction
     * @param {number} id id of check account transaction you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public linkVoucherToCheckAccountTransaction(id: number, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).linkVoucherToCheckAccountTransaction(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CheckAccountTransaction.php
     * @summary Update a existing check account transaction
     * @param {number} id id of check account transaction you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public updateCheckAccountTransaction(id: number, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).updateCheckAccountTransaction(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls changeStatus() in CheckAccountTransaction.php
     * @summary Update status of a existing check account transaction
     * @param {number} id id of check account transaction you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionApi
     */
    public updateCheckAccountTransactionStatus(id: number, options?: any) {
        return CheckAccountTransactionApiFp(this.configuration).updateCheckAccountTransactionStatus(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CheckAccountTransactionLogApi - fetch parameter creator
 * @export
 */
export const CheckAccountTransactionLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls CheckAccountTransactionLog.php 
         * @summary Create a new logged check account transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccountTransactionLog(options: any = {}): FetchArgs {
            const localVarPath = `/CheckAccountTransactionLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in CheckAccountTransactionLog.php
         * @summary Delete an existing logged check account transaction
         * @param {number} id id of logged check account transaction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccountTransactionLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCheckAccountTransactionLog.');
            }
            const localVarPath = `/CheckAccountTransactionLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CheckAccountTransactionLog.php to get necessary variables.
         * @summary Get an overview of all check account transactions which were logged
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned logged check account transactions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccountTransactionLog(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/CheckAccountTransactionLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CheckAccountTransactionLog.php
         * @summary Update a existing logged check account transaction
         * @param {number} id id of logged check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransactionLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCheckAccountTransactionLog.');
            }
            const localVarPath = `/CheckAccountTransactionLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CheckAccountTransactionLogApi - functional programming interface
 * @export
 */
export const CheckAccountTransactionLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls CheckAccountTransactionLog.php 
         * @summary Create a new logged check account transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccountTransactionLog(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransactionLog> {
            const localVarFetchArgs = CheckAccountTransactionLogApiFetchParamCreator(configuration).addCheckAccountTransactionLog(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in CheckAccountTransactionLog.php
         * @summary Delete an existing logged check account transaction
         * @param {number} id id of logged check account transaction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccountTransactionLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CheckAccountTransactionLogApiFetchParamCreator(configuration).deleteCheckAccountTransactionLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CheckAccountTransactionLog.php to get necessary variables.
         * @summary Get an overview of all check account transactions which were logged
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned logged check account transactions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccountTransactionLog(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransactionLog> {
            const localVarFetchArgs = CheckAccountTransactionLogApiFetchParamCreator(configuration).getCheckAccountTransactionLog(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CheckAccountTransactionLog.php
         * @summary Update a existing logged check account transaction
         * @param {number} id id of logged check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransactionLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransactionLog> {
            const localVarFetchArgs = CheckAccountTransactionLogApiFetchParamCreator(configuration).updateCheckAccountTransactionLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CheckAccountTransactionLogApi - factory interface
 * @export
 */
export const CheckAccountTransactionLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls CheckAccountTransactionLog.php 
         * @summary Create a new logged check account transaction
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCheckAccountTransactionLog(options?: any) {
            return CheckAccountTransactionLogApiFp(configuration).addCheckAccountTransactionLog(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in CheckAccountTransactionLog.php
         * @summary Delete an existing logged check account transaction
         * @param {number} id id of logged check account transaction you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCheckAccountTransactionLog(id: number, options?: any) {
            return CheckAccountTransactionLogApiFp(configuration).deleteCheckAccountTransactionLog(id, options)(fetch, basePath);
        },
        /**
         * Calls CheckAccountTransactionLog.php to get necessary variables.
         * @summary Get an overview of all check account transactions which were logged
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned logged check account transactions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCheckAccountTransactionLog(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return CheckAccountTransactionLogApiFp(configuration).getCheckAccountTransactionLog(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls CheckAccountTransactionLog.php
         * @summary Update a existing logged check account transaction
         * @param {number} id id of logged check account transaction you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCheckAccountTransactionLog(id: number, options?: any) {
            return CheckAccountTransactionLogApiFp(configuration).updateCheckAccountTransactionLog(id, options)(fetch, basePath);
        },
    };
};

/**
 * CheckAccountTransactionLogApi - object-oriented interface
 * @export
 * @class CheckAccountTransactionLogApi
 * @extends {BaseAPI}
 */
export class CheckAccountTransactionLogApi extends BaseAPI {
    /**
     * Calls CheckAccountTransactionLog.php 
     * @summary Create a new logged check account transaction
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionLogApi
     */
    public addCheckAccountTransactionLog(options?: any) {
        return CheckAccountTransactionLogApiFp(this.configuration).addCheckAccountTransactionLog(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in CheckAccountTransactionLog.php
     * @summary Delete an existing logged check account transaction
     * @param {number} id id of logged check account transaction you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionLogApi
     */
    public deleteCheckAccountTransactionLog(id: number, options?: any) {
        return CheckAccountTransactionLogApiFp(this.configuration).deleteCheckAccountTransactionLog(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CheckAccountTransactionLog.php to get necessary variables.
     * @summary Get an overview of all check account transactions which were logged
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned logged check account transactions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionLogApi
     */
    public getCheckAccountTransactionLog(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return CheckAccountTransactionLogApiFp(this.configuration).getCheckAccountTransactionLog(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CheckAccountTransactionLog.php
     * @summary Update a existing logged check account transaction
     * @param {number} id id of logged check account transaction you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CheckAccountTransactionLogApi
     */
    public updateCheckAccountTransactionLog(id: number, options?: any) {
        return CheckAccountTransactionLogApiFp(this.configuration).updateCheckAccountTransactionLog(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CommunicationWayApi - fetch parameter creator
 * @export
 */
export const CommunicationWayApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls CommunicationWay.php 
         * @summary Create a new communication way
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommunicationWay(options: any = {}): FetchArgs {
            const localVarPath = `/CommunicationWay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CommunicationWay.php
         * @summary Delete an existing communication way
         * @param {number} id id of communication way you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommunicationWay(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCommunicationWay.');
            }
            const localVarPath = `/CommunicationWay/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CommunicationWay.php to get necessary variables.
         * @summary Get an overview of all communication ways
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned communication ways start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationWays(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/CommunicationWay`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CommunicationWay.php
         * @summary Update a existing communication way
         * @param {number} id id of communication way you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommunicationWay(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCommunicationWay.');
            }
            const localVarPath = `/CommunicationWay/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommunicationWayApi - functional programming interface
 * @export
 */
export const CommunicationWayApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls CommunicationWay.php 
         * @summary Create a new communication way
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommunicationWay(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = CommunicationWayApiFetchParamCreator(configuration).addCommunicationWay(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CommunicationWay.php
         * @summary Delete an existing communication way
         * @param {number} id id of communication way you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommunicationWay(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CommunicationWayApiFetchParamCreator(configuration).deleteCommunicationWay(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CommunicationWay.php to get necessary variables.
         * @summary Get an overview of all communication ways
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned communication ways start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationWays(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = CommunicationWayApiFetchParamCreator(configuration).getCommunicationWays(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CommunicationWay.php
         * @summary Update a existing communication way
         * @param {number} id id of communication way you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommunicationWay(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = CommunicationWayApiFetchParamCreator(configuration).updateCommunicationWay(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommunicationWayApi - factory interface
 * @export
 */
export const CommunicationWayApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls CommunicationWay.php 
         * @summary Create a new communication way
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCommunicationWay(options?: any) {
            return CommunicationWayApiFp(configuration).addCommunicationWay(options)(fetch, basePath);
        },
        /**
         * Calls CommunicationWay.php
         * @summary Delete an existing communication way
         * @param {number} id id of communication way you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCommunicationWay(id: number, options?: any) {
            return CommunicationWayApiFp(configuration).deleteCommunicationWay(id, options)(fetch, basePath);
        },
        /**
         * Calls CommunicationWay.php to get necessary variables.
         * @summary Get an overview of all communication ways
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned communication ways start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationWays(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return CommunicationWayApiFp(configuration).getCommunicationWays(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls CommunicationWay.php
         * @summary Update a existing communication way
         * @param {number} id id of communication way you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCommunicationWay(id: number, options?: any) {
            return CommunicationWayApiFp(configuration).updateCommunicationWay(id, options)(fetch, basePath);
        },
    };
};

/**
 * CommunicationWayApi - object-oriented interface
 * @export
 * @class CommunicationWayApi
 * @extends {BaseAPI}
 */
export class CommunicationWayApi extends BaseAPI {
    /**
     * Calls CommunicationWay.php 
     * @summary Create a new communication way
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationWayApi
     */
    public addCommunicationWay(options?: any) {
        return CommunicationWayApiFp(this.configuration).addCommunicationWay(options)(this.fetch, this.basePath);
    }

    /**
     * Calls CommunicationWay.php
     * @summary Delete an existing communication way
     * @param {number} id id of communication way you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationWayApi
     */
    public deleteCommunicationWay(id: number, options?: any) {
        return CommunicationWayApiFp(this.configuration).deleteCommunicationWay(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CommunicationWay.php to get necessary variables.
     * @summary Get an overview of all communication ways
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned communication ways start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationWayApi
     */
    public getCommunicationWays(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return CommunicationWayApiFp(this.configuration).getCommunicationWays(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CommunicationWay.php
     * @summary Update a existing communication way
     * @param {number} id id of communication way you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationWayApi
     */
    public updateCommunicationWay(id: number, options?: any) {
        return CommunicationWayApiFp(this.configuration).updateCommunicationWay(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CommunicationWayKeyApi - fetch parameter creator
 * @export
 */
export const CommunicationWayKeyApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls CommunicationWayKey.php to get necessary variables.
         * @summary Get an overview of all communication way keys
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned communication way keys start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationWayKeys(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/CommunicationWayKey`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CommunicationWayKeyApi - functional programming interface
 * @export
 */
export const CommunicationWayKeyApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls CommunicationWayKey.php to get necessary variables.
         * @summary Get an overview of all communication way keys
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned communication way keys start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationWayKeys(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWayKey> {
            const localVarFetchArgs = CommunicationWayKeyApiFetchParamCreator(configuration).getCommunicationWayKeys(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CommunicationWayKeyApi - factory interface
 * @export
 */
export const CommunicationWayKeyApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls CommunicationWayKey.php to get necessary variables.
         * @summary Get an overview of all communication way keys
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned communication way keys start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCommunicationWayKeys(limit?: number, offset?: number, options?: any) {
            return CommunicationWayKeyApiFp(configuration).getCommunicationWayKeys(limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * CommunicationWayKeyApi - object-oriented interface
 * @export
 * @class CommunicationWayKeyApi
 * @extends {BaseAPI}
 */
export class CommunicationWayKeyApi extends BaseAPI {
    /**
     * Calls CommunicationWayKey.php to get necessary variables.
     * @summary Get an overview of all communication way keys
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned communication way keys start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CommunicationWayKeyApi
     */
    public getCommunicationWayKeys(limit?: number, offset?: number, options?: any) {
        return CommunicationWayKeyApiFp(this.configuration).getCommunicationWayKeys(limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * ContactApi - fetch parameter creator
 * @export
 */
export const ContactApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Adds an address to the contact by calling addAddress() in Contact.php. Address is defined in ContactAddress.php
         * @summary Add an address
         * @param {number} id Id of contact you want to add an address to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAddress(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addAddress.');
            }
            const localVarPath = `/Contact/{id}/addAddress`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Creating a new contact of type person/company calls a shared path with the same http-verb.  However, both types require certain parameters which will indicate that their type of contact should be created.  So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
         * @summary Create a new contact of type person or company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContact(options: any = {}): FetchArgs {
            const localVarPath = `/Contact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls addCommunicationWay() in Contact.php
         * @summary Create a new communication way for a contact
         * @param {number} id Id of contact you want to add a communication way to
         * @param {string} value Value of the communication way you want to add
         * @param {number} key Key of the communication way you want to add
         * @param {string} [type] Type of communication way you want to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactCommunicationWay(id: number, value: string, key: number, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addContactCommunicationWay.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling addContactCommunicationWay.');
            }
            // verify required parameter 'key' is not null or undefined
            if (key === null || key === undefined) {
                throw new RequiredError('key','Required parameter key was null or undefined when calling addContactCommunicationWay.');
            }
            const localVarPath = `/Contact/{id}/addCommunicationWay`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            if (key !== undefined) {
                localVarQueryParameter['key'] = key;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls addMobile in Contact.php
         * @summary Add a new mobile number
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMobile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addMobile.');
            }
            const localVarPath = `/Contact/{id}/addMobile`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls addPhone() in Contact.php
         * @summary Add a new phone number
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPhone(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addPhone.');
            }
            const localVarPath = `/Contact/{id}/addPhone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls addWeb() in Contact.php
         * @summary Add a new website
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebsite(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling addWebsite.');
            }
            const localVarPath = `/Contact/{id}/addWeb`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls addEmail() in Contact.php
         * @summary Add a new email
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactAddEmail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contactAddEmail.');
            }
            const localVarPath = `/Contact/{id}/addEmail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='    Creating a new contact of type person/company calls a shared path with the same http-verb.    However, both types require certain parameters which will indicate that their type of contact should be created.    So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
         * @summary Create a new contact of type person or company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactFactoryCreateContact(options: any = {}): FetchArgs {
            const localVarPath = `/Contact/Factory/create`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAddresses() in Contact.php to get the addresses of a specified contact
         * @summary Get the addresses of a specified contact
         * @param {number} id Id of the contact you want to get the addresses from
         * @param {number} categoryId Category of addresses you want to get
         * @param {string} categoryObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactGetAddresses(id: number, categoryId: number, categoryObjectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling contactGetAddresses.');
            }
            // verify required parameter 'categoryId' is not null or undefined
            if (categoryId === null || categoryId === undefined) {
                throw new RequiredError('categoryId','Required parameter categoryId was null or undefined when calling contactGetAddresses.');
            }
            // verify required parameter 'categoryObjectName' is not null or undefined
            if (categoryObjectName === null || categoryObjectName === undefined) {
                throw new RequiredError('categoryObjectName','Required parameter categoryObjectName was null or undefined when calling contactGetAddresses.');
            }
            const localVarPath = `/Contact/{id}/getAddresses`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (categoryId !== undefined) {
                localVarQueryParameter['category[id]'] = categoryId;
            }

            if (categoryObjectName !== undefined) {
                localVarQueryParameter['category[objectName]'] = categoryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Contact.php
         * @summary Delete an existing contact
         * @param {number} id id of contact you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteContact.');
            }
            const localVarPath = `/Contact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getBillingAddress() in Contact.php to get the billing address of a specified contact
         * @summary Get the billing address of a specified contact
         * @param {number} id Id of the contact you want to get the billing address from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactBillingAddress(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactBillingAddress.');
            }
            const localVarPath = `/Contact/{id}/getBillingAddress`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getBillingEmail() in Contact.php to get the billing email of a specified contact
         * @summary Get the billing email of a specified contact
         * @param {number} id Id of the contact you want to get the billing email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactBillingEmail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactBillingEmail.');
            }
            const localVarPath = `/Contact/{id}/getBillingEmail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCommunicationWays() in Contact.php to get the communication ways of a specified contact
         * @summary Get the communication ways of a specified contact
         * @param {number} id Id of the contact you want to get the communication ways from
         * @param {string} [type] Type of communication ways you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactCommunicationWays(id: number, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactCommunicationWays.');
            }
            const localVarPath = `/Contact/{id}/getCommunicationWays`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getMainAddress() in Contact.php to get the main address of a specified contact
         * @summary Get the main address of a specified contact
         * @param {number} id Id of the contact you want to get the main address from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainAddress(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactMainAddress.');
            }
            const localVarPath = `/Contact/{id}/getMainAddress`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getMainEmail() in Contact.php to get the main email of a specified contact
         * @summary Get the main email of a specified contact
         * @param {number} id Id of the contact you want to get the main email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainEmail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactMainEmail.');
            }
            const localVarPath = `/Contact/{id}/getMainEmail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getMainMobile() in Contact.php to get the main mobile of a specified contact
         * @summary Get the main mobile of a specified contact
         * @param {number} id Id of the contact you want to get the main mobile from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainMobile(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactMainMobile.');
            }
            const localVarPath = `/Contact/{id}/getMainMobile`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getMainPhone() in Contact.php to get the main phone of a specified contact
         * @summary Get the main phone of a specified contact
         * @param {number} id Id of the contact you want to get the main phone from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainPhone(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactMainPhone.');
            }
            const localVarPath = `/Contact/{id}/getMainPhone`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getMainWebsite() in Contact.php to get the main website of a specified contact
         * @summary Get the main website of a specified contact
         * @param {number} id Id of the contact you want to get the main website from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainWebsite(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactMainWebsite.');
            }
            const localVarPath = `/Contact/{id}/getMainWebsite`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getRelatedCommunicationWays() in Contact.php to get the related communication ways of a specified contact
         * @summary Get the related communication ways of a specified contact
         * @param {number} id Id of the contact you want to get the related communication ways from
         * @param {string} [type] Type of related communication ways you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactRelatedCommunicationWays(id: number, type?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactRelatedCommunicationWays.');
            }
            const localVarPath = `/Contact/{id}/getRelatedCommunicationWays`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (type !== undefined) {
                localVarQueryParameter['type'] = type;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTabsItemCount() in Contact.php to get the number of all invoices, orders, etc. of a specified contact
         * @summary Get number of all invoices, orders, etc. of a specified contact
         * @param {number} id Id of the contact you want to get the number of all invoices, orders, etc. from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactTabsItemCount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getContactTabsItemCount.');
            }
            const localVarPath = `/Contact/{id}/getTabsItemCount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Contact.php to get necessary variables
         * @summary Get an overview of all contacts
         * @param {number} [depth] If depth is set 1 companies and persons will be shown, otherwise only the companies will be shown. Default: 0
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned contacts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(depth?: number, limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Contact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (depth !== undefined) {
                localVarQueryParameter['depth'] = depth;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Get the next customer number in the sequence
         * @summary Get the next customer number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextCustomerNumber(options: any = {}): FetchArgs {
            const localVarPath = `/Contact/Factory/getNextCustomerNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Contact.php to update an existing contact
         * @summary Update an existing contact
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateContact.');
            }
            const localVarPath = `/Contact/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactApi - functional programming interface
 * @export
 */
export const ContactApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Adds an address to the contact by calling addAddress() in Contact.php. Address is defined in ContactAddress.php
         * @summary Add an address
         * @param {number} id Id of contact you want to add an address to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAddress(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContactAddress> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).addAddress(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Creating a new contact of type person/company calls a shared path with the same http-verb.  However, both types require certain parameters which will indicate that their type of contact should be created.  So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
         * @summary Create a new contact of type person or company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContact(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContact> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).addContact(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls addCommunicationWay() in Contact.php
         * @summary Create a new communication way for a contact
         * @param {number} id Id of contact you want to add a communication way to
         * @param {string} value Value of the communication way you want to add
         * @param {number} key Key of the communication way you want to add
         * @param {string} [type] Type of communication way you want to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactCommunicationWay(id: number, value: string, key: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).addContactCommunicationWay(id, value, key, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls addMobile in Contact.php
         * @summary Add a new mobile number
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMobile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).addMobile(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls addPhone() in Contact.php
         * @summary Add a new phone number
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPhone(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).addPhone(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls addWeb() in Contact.php
         * @summary Add a new website
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebsite(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).addWebsite(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls addEmail() in Contact.php
         * @summary Add a new email
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactAddEmail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).contactAddEmail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='    Creating a new contact of type person/company calls a shared path with the same http-verb.    However, both types require certain parameters which will indicate that their type of contact should be created.    So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
         * @summary Create a new contact of type person or company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactFactoryCreateContact(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContact> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).contactFactoryCreateContact(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAddresses() in Contact.php to get the addresses of a specified contact
         * @summary Get the addresses of a specified contact
         * @param {number} id Id of the contact you want to get the addresses from
         * @param {number} categoryId Category of addresses you want to get
         * @param {string} categoryObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactGetAddresses(id: number, categoryId: number, categoryObjectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContactAddress> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).contactGetAddresses(id, categoryId, categoryObjectName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Contact.php
         * @summary Delete an existing contact
         * @param {number} id id of contact you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).deleteContact(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getBillingAddress() in Contact.php to get the billing address of a specified contact
         * @summary Get the billing address of a specified contact
         * @param {number} id Id of the contact you want to get the billing address from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactBillingAddress(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContactAddress> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactBillingAddress(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getBillingEmail() in Contact.php to get the billing email of a specified contact
         * @summary Get the billing email of a specified contact
         * @param {number} id Id of the contact you want to get the billing email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactBillingEmail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactBillingEmail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCommunicationWays() in Contact.php to get the communication ways of a specified contact
         * @summary Get the communication ways of a specified contact
         * @param {number} id Id of the contact you want to get the communication ways from
         * @param {string} [type] Type of communication ways you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactCommunicationWays(id: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactCommunicationWays(id, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getMainAddress() in Contact.php to get the main address of a specified contact
         * @summary Get the main address of a specified contact
         * @param {number} id Id of the contact you want to get the main address from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainAddress(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContactAddress> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactMainAddress(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getMainEmail() in Contact.php to get the main email of a specified contact
         * @summary Get the main email of a specified contact
         * @param {number} id Id of the contact you want to get the main email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainEmail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactMainEmail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getMainMobile() in Contact.php to get the main mobile of a specified contact
         * @summary Get the main mobile of a specified contact
         * @param {number} id Id of the contact you want to get the main mobile from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainMobile(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactMainMobile(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getMainPhone() in Contact.php to get the main phone of a specified contact
         * @summary Get the main phone of a specified contact
         * @param {number} id Id of the contact you want to get the main phone from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainPhone(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactMainPhone(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getMainWebsite() in Contact.php to get the main website of a specified contact
         * @summary Get the main website of a specified contact
         * @param {number} id Id of the contact you want to get the main website from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainWebsite(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactMainWebsite(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getRelatedCommunicationWays() in Contact.php to get the related communication ways of a specified contact
         * @summary Get the related communication ways of a specified contact
         * @param {number} id Id of the contact you want to get the related communication ways from
         * @param {string} [type] Type of related communication ways you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactRelatedCommunicationWays(id: number, type?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCommunicationWay> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactRelatedCommunicationWays(id, type, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTabsItemCount() in Contact.php to get the number of all invoices, orders, etc. of a specified contact
         * @summary Get number of all invoices, orders, etc. of a specified contact
         * @param {number} id Id of the contact you want to get the number of all invoices, orders, etc. from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactTabsItemCount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContactTabsItemCount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Contact.php to get necessary variables
         * @summary Get an overview of all contacts
         * @param {number} [depth] If depth is set 1 companies and persons will be shown, otherwise only the companies will be shown. Default: 0
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned contacts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(depth?: number, limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContact> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getContacts(depth, limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Get the next customer number in the sequence
         * @summary Get the next customer number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextCustomerNumber(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).getNextCustomerNumber(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Contact.php to update an existing contact
         * @summary Update an existing contact
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContact> {
            const localVarFetchArgs = ContactApiFetchParamCreator(configuration).updateContact(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContactApi - factory interface
 * @export
 */
export const ContactApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Adds an address to the contact by calling addAddress() in Contact.php. Address is defined in ContactAddress.php
         * @summary Add an address
         * @param {number} id Id of contact you want to add an address to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addAddress(id: number, options?: any) {
            return ContactApiFp(configuration).addAddress(id, options)(fetch, basePath);
        },
        /**
         * Creating a new contact of type person/company calls a shared path with the same http-verb.  However, both types require certain parameters which will indicate that their type of contact should be created.  So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
         * @summary Create a new contact of type person or company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContact(options?: any) {
            return ContactApiFp(configuration).addContact(options)(fetch, basePath);
        },
        /**
         * Calls addCommunicationWay() in Contact.php
         * @summary Create a new communication way for a contact
         * @param {number} id Id of contact you want to add a communication way to
         * @param {string} value Value of the communication way you want to add
         * @param {number} key Key of the communication way you want to add
         * @param {string} [type] Type of communication way you want to add
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactCommunicationWay(id: number, value: string, key: number, type?: string, options?: any) {
            return ContactApiFp(configuration).addContactCommunicationWay(id, value, key, type, options)(fetch, basePath);
        },
        /**
         * Calls addMobile in Contact.php
         * @summary Add a new mobile number
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addMobile(id: number, options?: any) {
            return ContactApiFp(configuration).addMobile(id, options)(fetch, basePath);
        },
        /**
         * Calls addPhone() in Contact.php
         * @summary Add a new phone number
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPhone(id: number, options?: any) {
            return ContactApiFp(configuration).addPhone(id, options)(fetch, basePath);
        },
        /**
         * Calls addWeb() in Contact.php
         * @summary Add a new website
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addWebsite(id: number, options?: any) {
            return ContactApiFp(configuration).addWebsite(id, options)(fetch, basePath);
        },
        /**
         * Calls addEmail() in Contact.php
         * @summary Add a new email
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactAddEmail(id: number, options?: any) {
            return ContactApiFp(configuration).contactAddEmail(id, options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='    Creating a new contact of type person/company calls a shared path with the same http-verb.    However, both types require certain parameters which will indicate that their type of contact should be created.    So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
         * @summary Create a new contact of type person or company
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactFactoryCreateContact(options?: any) {
            return ContactApiFp(configuration).contactFactoryCreateContact(options)(fetch, basePath);
        },
        /**
         * Calls getAddresses() in Contact.php to get the addresses of a specified contact
         * @summary Get the addresses of a specified contact
         * @param {number} id Id of the contact you want to get the addresses from
         * @param {number} categoryId Category of addresses you want to get
         * @param {string} categoryObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        contactGetAddresses(id: number, categoryId: number, categoryObjectName: string, options?: any) {
            return ContactApiFp(configuration).contactGetAddresses(id, categoryId, categoryObjectName, options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Contact.php
         * @summary Delete an existing contact
         * @param {number} id id of contact you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContact(id: number, options?: any) {
            return ContactApiFp(configuration).deleteContact(id, options)(fetch, basePath);
        },
        /**
         * Calls getBillingAddress() in Contact.php to get the billing address of a specified contact
         * @summary Get the billing address of a specified contact
         * @param {number} id Id of the contact you want to get the billing address from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactBillingAddress(id: number, options?: any) {
            return ContactApiFp(configuration).getContactBillingAddress(id, options)(fetch, basePath);
        },
        /**
         * Calls getBillingEmail() in Contact.php to get the billing email of a specified contact
         * @summary Get the billing email of a specified contact
         * @param {number} id Id of the contact you want to get the billing email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactBillingEmail(id: number, options?: any) {
            return ContactApiFp(configuration).getContactBillingEmail(id, options)(fetch, basePath);
        },
        /**
         * Calls getCommunicationWays() in Contact.php to get the communication ways of a specified contact
         * @summary Get the communication ways of a specified contact
         * @param {number} id Id of the contact you want to get the communication ways from
         * @param {string} [type] Type of communication ways you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactCommunicationWays(id: number, type?: string, options?: any) {
            return ContactApiFp(configuration).getContactCommunicationWays(id, type, options)(fetch, basePath);
        },
        /**
         * Calls getMainAddress() in Contact.php to get the main address of a specified contact
         * @summary Get the main address of a specified contact
         * @param {number} id Id of the contact you want to get the main address from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainAddress(id: number, options?: any) {
            return ContactApiFp(configuration).getContactMainAddress(id, options)(fetch, basePath);
        },
        /**
         * Calls getMainEmail() in Contact.php to get the main email of a specified contact
         * @summary Get the main email of a specified contact
         * @param {number} id Id of the contact you want to get the main email from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainEmail(id: number, options?: any) {
            return ContactApiFp(configuration).getContactMainEmail(id, options)(fetch, basePath);
        },
        /**
         * Calls getMainMobile() in Contact.php to get the main mobile of a specified contact
         * @summary Get the main mobile of a specified contact
         * @param {number} id Id of the contact you want to get the main mobile from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainMobile(id: number, options?: any) {
            return ContactApiFp(configuration).getContactMainMobile(id, options)(fetch, basePath);
        },
        /**
         * Calls getMainPhone() in Contact.php to get the main phone of a specified contact
         * @summary Get the main phone of a specified contact
         * @param {number} id Id of the contact you want to get the main phone from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainPhone(id: number, options?: any) {
            return ContactApiFp(configuration).getContactMainPhone(id, options)(fetch, basePath);
        },
        /**
         * Calls getMainWebsite() in Contact.php to get the main website of a specified contact
         * @summary Get the main website of a specified contact
         * @param {number} id Id of the contact you want to get the main website from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactMainWebsite(id: number, options?: any) {
            return ContactApiFp(configuration).getContactMainWebsite(id, options)(fetch, basePath);
        },
        /**
         * Calls getRelatedCommunicationWays() in Contact.php to get the related communication ways of a specified contact
         * @summary Get the related communication ways of a specified contact
         * @param {number} id Id of the contact you want to get the related communication ways from
         * @param {string} [type] Type of related communication ways you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactRelatedCommunicationWays(id: number, type?: string, options?: any) {
            return ContactApiFp(configuration).getContactRelatedCommunicationWays(id, type, options)(fetch, basePath);
        },
        /**
         * Calls getTabsItemCount() in Contact.php to get the number of all invoices, orders, etc. of a specified contact
         * @summary Get number of all invoices, orders, etc. of a specified contact
         * @param {number} id Id of the contact you want to get the number of all invoices, orders, etc. from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactTabsItemCount(id: number, options?: any) {
            return ContactApiFp(configuration).getContactTabsItemCount(id, options)(fetch, basePath);
        },
        /**
         * Calls Contact.php to get necessary variables
         * @summary Get an overview of all contacts
         * @param {number} [depth] If depth is set 1 companies and persons will be shown, otherwise only the companies will be shown. Default: 0
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned contacts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContacts(depth?: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return ContactApiFp(configuration).getContacts(depth, limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Get the next customer number in the sequence
         * @summary Get the next customer number
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextCustomerNumber(options?: any) {
            return ContactApiFp(configuration).getNextCustomerNumber(options)(fetch, basePath);
        },
        /**
         * Calls Contact.php to update an existing contact
         * @summary Update an existing contact
         * @param {number} id Id of contact you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContact(id: number, options?: any) {
            return ContactApiFp(configuration).updateContact(id, options)(fetch, basePath);
        },
    };
};

/**
 * ContactApi - object-oriented interface
 * @export
 * @class ContactApi
 * @extends {BaseAPI}
 */
export class ContactApi extends BaseAPI {
    /**
     * Adds an address to the contact by calling addAddress() in Contact.php. Address is defined in ContactAddress.php
     * @summary Add an address
     * @param {number} id Id of contact you want to add an address to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public addAddress(id: number, options?: any) {
        return ContactApiFp(this.configuration).addAddress(id, options)(this.fetch, this.basePath);
    }

    /**
     * Creating a new contact of type person/company calls a shared path with the same http-verb.  However, both types require certain parameters which will indicate that their type of contact should be created.  So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
     * @summary Create a new contact of type person or company
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public addContact(options?: any) {
        return ContactApiFp(this.configuration).addContact(options)(this.fetch, this.basePath);
    }

    /**
     * Calls addCommunicationWay() in Contact.php
     * @summary Create a new communication way for a contact
     * @param {number} id Id of contact you want to add a communication way to
     * @param {string} value Value of the communication way you want to add
     * @param {number} key Key of the communication way you want to add
     * @param {string} [type] Type of communication way you want to add
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public addContactCommunicationWay(id: number, value: string, key: number, type?: string, options?: any) {
        return ContactApiFp(this.configuration).addContactCommunicationWay(id, value, key, type, options)(this.fetch, this.basePath);
    }

    /**
     * Calls addMobile in Contact.php
     * @summary Add a new mobile number
     * @param {number} id Id of contact you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public addMobile(id: number, options?: any) {
        return ContactApiFp(this.configuration).addMobile(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls addPhone() in Contact.php
     * @summary Add a new phone number
     * @param {number} id Id of contact you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public addPhone(id: number, options?: any) {
        return ContactApiFp(this.configuration).addPhone(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls addWeb() in Contact.php
     * @summary Add a new website
     * @param {number} id Id of contact you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public addWebsite(id: number, options?: any) {
        return ContactApiFp(this.configuration).addWebsite(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls addEmail() in Contact.php
     * @summary Add a new email
     * @param {number} id Id of contact you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactAddEmail(id: number, options?: any) {
        return ContactApiFp(this.configuration).contactAddEmail(id, options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='    Creating a new contact of type person/company calls a shared path with the same http-verb.    However, both types require certain parameters which will indicate that their type of contact should be created.    So, using **familyname** or **name** in front of 'category' will define if either a person or a company is created
     * @summary Create a new contact of type person or company
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactFactoryCreateContact(options?: any) {
        return ContactApiFp(this.configuration).contactFactoryCreateContact(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAddresses() in Contact.php to get the addresses of a specified contact
     * @summary Get the addresses of a specified contact
     * @param {number} id Id of the contact you want to get the addresses from
     * @param {number} categoryId Category of addresses you want to get
     * @param {string} categoryObjectName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public contactGetAddresses(id: number, categoryId: number, categoryObjectName: string, options?: any) {
        return ContactApiFp(this.configuration).contactGetAddresses(id, categoryId, categoryObjectName, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Contact.php
     * @summary Delete an existing contact
     * @param {number} id id of contact you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public deleteContact(id: number, options?: any) {
        return ContactApiFp(this.configuration).deleteContact(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getBillingAddress() in Contact.php to get the billing address of a specified contact
     * @summary Get the billing address of a specified contact
     * @param {number} id Id of the contact you want to get the billing address from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactBillingAddress(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactBillingAddress(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getBillingEmail() in Contact.php to get the billing email of a specified contact
     * @summary Get the billing email of a specified contact
     * @param {number} id Id of the contact you want to get the billing email from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactBillingEmail(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactBillingEmail(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCommunicationWays() in Contact.php to get the communication ways of a specified contact
     * @summary Get the communication ways of a specified contact
     * @param {number} id Id of the contact you want to get the communication ways from
     * @param {string} [type] Type of communication ways you want to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactCommunicationWays(id: number, type?: string, options?: any) {
        return ContactApiFp(this.configuration).getContactCommunicationWays(id, type, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getMainAddress() in Contact.php to get the main address of a specified contact
     * @summary Get the main address of a specified contact
     * @param {number} id Id of the contact you want to get the main address from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactMainAddress(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactMainAddress(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getMainEmail() in Contact.php to get the main email of a specified contact
     * @summary Get the main email of a specified contact
     * @param {number} id Id of the contact you want to get the main email from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactMainEmail(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactMainEmail(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getMainMobile() in Contact.php to get the main mobile of a specified contact
     * @summary Get the main mobile of a specified contact
     * @param {number} id Id of the contact you want to get the main mobile from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactMainMobile(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactMainMobile(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getMainPhone() in Contact.php to get the main phone of a specified contact
     * @summary Get the main phone of a specified contact
     * @param {number} id Id of the contact you want to get the main phone from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactMainPhone(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactMainPhone(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getMainWebsite() in Contact.php to get the main website of a specified contact
     * @summary Get the main website of a specified contact
     * @param {number} id Id of the contact you want to get the main website from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactMainWebsite(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactMainWebsite(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getRelatedCommunicationWays() in Contact.php to get the related communication ways of a specified contact
     * @summary Get the related communication ways of a specified contact
     * @param {number} id Id of the contact you want to get the related communication ways from
     * @param {string} [type] Type of related communication ways you want to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactRelatedCommunicationWays(id: number, type?: string, options?: any) {
        return ContactApiFp(this.configuration).getContactRelatedCommunicationWays(id, type, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTabsItemCount() in Contact.php to get the number of all invoices, orders, etc. of a specified contact
     * @summary Get number of all invoices, orders, etc. of a specified contact
     * @param {number} id Id of the contact you want to get the number of all invoices, orders, etc. from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContactTabsItemCount(id: number, options?: any) {
        return ContactApiFp(this.configuration).getContactTabsItemCount(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Contact.php to get necessary variables
     * @summary Get an overview of all contacts
     * @param {number} [depth] If depth is set 1 companies and persons will be shown, otherwise only the companies will be shown. Default: 0
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned contacts start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getContacts(depth?: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return ContactApiFp(this.configuration).getContacts(depth, limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Get the next customer number in the sequence
     * @summary Get the next customer number
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public getNextCustomerNumber(options?: any) {
        return ContactApiFp(this.configuration).getNextCustomerNumber(options)(this.fetch, this.basePath);
    }

    /**
     * Calls Contact.php to update an existing contact
     * @summary Update an existing contact
     * @param {number} id Id of contact you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactApi
     */
    public updateContact(id: number, options?: any) {
        return ContactApiFp(this.configuration).updateContact(id, options)(this.fetch, this.basePath);
    }

}
/**
 * ContactAddressApi - fetch parameter creator
 * @export
 */
export const ContactAddressApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls ContactAddress.php
         * @summary Create a new contact address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactAddress(options: any = {}): FetchArgs {
            const localVarPath = `/ContactAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in ContactAddress.php
         * @summary Delete an existing contact address
         * @param {number} id id of contact address you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactAddress(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteContactAddress.');
            }
            const localVarPath = `/ContactAddress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls ContactAddress.php to get necessary variables
         * @summary Get an overview of all contact addresses
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned contacts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactAddresses(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/ContactAddress`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls ContactAddress.php
         * @summary Update an existing contact address
         * @param {number} id id of contact address you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContactAddress(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateContactAddress.');
            }
            const localVarPath = `/ContactAddress/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ContactAddressApi - functional programming interface
 * @export
 */
export const ContactAddressApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls ContactAddress.php
         * @summary Create a new contact address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactAddress(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContactAddress> {
            const localVarFetchArgs = ContactAddressApiFetchParamCreator(configuration).addContactAddress(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in ContactAddress.php
         * @summary Delete an existing contact address
         * @param {number} id id of contact address you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactAddress(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = ContactAddressApiFetchParamCreator(configuration).deleteContactAddress(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls ContactAddress.php to get necessary variables
         * @summary Get an overview of all contact addresses
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned contacts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactAddresses(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContactAddress> {
            const localVarFetchArgs = ContactAddressApiFetchParamCreator(configuration).getContactAddresses(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls ContactAddress.php
         * @summary Update an existing contact address
         * @param {number} id id of contact address you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContactAddress(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelContactAddress> {
            const localVarFetchArgs = ContactAddressApiFetchParamCreator(configuration).updateContactAddress(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ContactAddressApi - factory interface
 * @export
 */
export const ContactAddressApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls ContactAddress.php
         * @summary Create a new contact address
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addContactAddress(options?: any) {
            return ContactAddressApiFp(configuration).addContactAddress(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in ContactAddress.php
         * @summary Delete an existing contact address
         * @param {number} id id of contact address you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteContactAddress(id: number, options?: any) {
            return ContactAddressApiFp(configuration).deleteContactAddress(id, options)(fetch, basePath);
        },
        /**
         * Calls ContactAddress.php to get necessary variables
         * @summary Get an overview of all contact addresses
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned contacts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getContactAddresses(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return ContactAddressApiFp(configuration).getContactAddresses(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls ContactAddress.php
         * @summary Update an existing contact address
         * @param {number} id id of contact address you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateContactAddress(id: number, options?: any) {
            return ContactAddressApiFp(configuration).updateContactAddress(id, options)(fetch, basePath);
        },
    };
};

/**
 * ContactAddressApi - object-oriented interface
 * @export
 * @class ContactAddressApi
 * @extends {BaseAPI}
 */
export class ContactAddressApi extends BaseAPI {
    /**
     * Calls ContactAddress.php
     * @summary Create a new contact address
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactAddressApi
     */
    public addContactAddress(options?: any) {
        return ContactAddressApiFp(this.configuration).addContactAddress(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in ContactAddress.php
     * @summary Delete an existing contact address
     * @param {number} id id of contact address you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactAddressApi
     */
    public deleteContactAddress(id: number, options?: any) {
        return ContactAddressApiFp(this.configuration).deleteContactAddress(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls ContactAddress.php to get necessary variables
     * @summary Get an overview of all contact addresses
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned contacts start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactAddressApi
     */
    public getContactAddresses(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return ContactAddressApiFp(this.configuration).getContactAddresses(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls ContactAddress.php
     * @summary Update an existing contact address
     * @param {number} id id of contact address you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ContactAddressApi
     */
    public updateContactAddress(id: number, options?: any) {
        return ContactAddressApiFp(this.configuration).updateContactAddress(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CostCentreApi - fetch parameter creator
 * @export
 */
export const CostCentreApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls CostCentre.php
         * @summary Create a new cost centre
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCostCentre(options: any = {}): FetchArgs {
            const localVarPath = `/CostCentre`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in CostCentre.php
         * @summary Delete an existing cost centre
         * @param {number} id id of cost centre you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCostCentre(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteCostCentre.');
            }
            const localVarPath = `/CostCentre/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CostCentre.php to get necessary variables
         * @summary Get an overview of all cost centre
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned cost centre start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostCentre(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/CostCentre`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls CostCentre.php
         * @summary Update an existing cost centre
         * @param {number} id id of cost centre you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCostCentre(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateCostCentre.');
            }
            const localVarPath = `/CostCentre/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CostCentreApi - functional programming interface
 * @export
 */
export const CostCentreApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls CostCentre.php
         * @summary Create a new cost centre
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCostCentre(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCostCentre> {
            const localVarFetchArgs = CostCentreApiFetchParamCreator(configuration).addCostCentre(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in CostCentre.php
         * @summary Delete an existing cost centre
         * @param {number} id id of cost centre you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCostCentre(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = CostCentreApiFetchParamCreator(configuration).deleteCostCentre(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CostCentre.php to get necessary variables
         * @summary Get an overview of all cost centre
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned cost centre start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostCentre(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCostCentre> {
            const localVarFetchArgs = CostCentreApiFetchParamCreator(configuration).getCostCentre(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls CostCentre.php
         * @summary Update an existing cost centre
         * @param {number} id id of cost centre you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCostCentre(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCostCentre> {
            const localVarFetchArgs = CostCentreApiFetchParamCreator(configuration).updateCostCentre(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CostCentreApi - factory interface
 * @export
 */
export const CostCentreApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls CostCentre.php
         * @summary Create a new cost centre
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addCostCentre(options?: any) {
            return CostCentreApiFp(configuration).addCostCentre(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in CostCentre.php
         * @summary Delete an existing cost centre
         * @param {number} id id of cost centre you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteCostCentre(id: number, options?: any) {
            return CostCentreApiFp(configuration).deleteCostCentre(id, options)(fetch, basePath);
        },
        /**
         * Calls CostCentre.php to get necessary variables
         * @summary Get an overview of all cost centre
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned cost centre start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCostCentre(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return CostCentreApiFp(configuration).getCostCentre(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls CostCentre.php
         * @summary Update an existing cost centre
         * @param {number} id id of cost centre you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateCostCentre(id: number, options?: any) {
            return CostCentreApiFp(configuration).updateCostCentre(id, options)(fetch, basePath);
        },
    };
};

/**
 * CostCentreApi - object-oriented interface
 * @export
 * @class CostCentreApi
 * @extends {BaseAPI}
 */
export class CostCentreApi extends BaseAPI {
    /**
     * Calls CostCentre.php
     * @summary Create a new cost centre
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostCentreApi
     */
    public addCostCentre(options?: any) {
        return CostCentreApiFp(this.configuration).addCostCentre(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in CostCentre.php
     * @summary Delete an existing cost centre
     * @param {number} id id of cost centre you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostCentreApi
     */
    public deleteCostCentre(id: number, options?: any) {
        return CostCentreApiFp(this.configuration).deleteCostCentre(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CostCentre.php to get necessary variables
     * @summary Get an overview of all cost centre
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned cost centre start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostCentreApi
     */
    public getCostCentre(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return CostCentreApiFp(this.configuration).getCostCentre(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls CostCentre.php
     * @summary Update an existing cost centre
     * @param {number} id id of cost centre you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CostCentreApi
     */
    public updateCostCentre(id: number, options?: any) {
        return CostCentreApiFp(this.configuration).updateCostCentre(id, options)(this.fetch, this.basePath);
    }

}
/**
 * CurrencyExchangeRateApi - fetch parameter creator
 * @export
 */
export const CurrencyExchangeRateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls CurrencyExchangeRate.php to get necessary variables
         * @summary Get an overview of all currency exchange rates
         * @param {number} [limit] Limits the number of entries returned. Default is 1000.    Be aware that there are over 100000 entries in the database for currency exchange rate, so using a limit higher than 1000 with offset&#x3D;0 is not recommended!    However you can set the offset appropriately so you minimize the amount of returned exchange rates and keep loading time to a low.
         * @param {number} [offset] Set the index where the returned currency exchange rates start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyExchangeRates(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/CurrencyExchangeRate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * CurrencyExchangeRateApi - functional programming interface
 * @export
 */
export const CurrencyExchangeRateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls CurrencyExchangeRate.php to get necessary variables
         * @summary Get an overview of all currency exchange rates
         * @param {number} [limit] Limits the number of entries returned. Default is 1000.    Be aware that there are over 100000 entries in the database for currency exchange rate, so using a limit higher than 1000 with offset&#x3D;0 is not recommended!    However you can set the offset appropriately so you minimize the amount of returned exchange rates and keep loading time to a low.
         * @param {number} [offset] Set the index where the returned currency exchange rates start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyExchangeRates(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCurrencyExchangeRate> {
            const localVarFetchArgs = CurrencyExchangeRateApiFetchParamCreator(configuration).getCurrencyExchangeRates(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * CurrencyExchangeRateApi - factory interface
 * @export
 */
export const CurrencyExchangeRateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls CurrencyExchangeRate.php to get necessary variables
         * @summary Get an overview of all currency exchange rates
         * @param {number} [limit] Limits the number of entries returned. Default is 1000.    Be aware that there are over 100000 entries in the database for currency exchange rate, so using a limit higher than 1000 with offset&#x3D;0 is not recommended!    However you can set the offset appropriately so you minimize the amount of returned exchange rates and keep loading time to a low.
         * @param {number} [offset] Set the index where the returned currency exchange rates start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getCurrencyExchangeRates(limit?: number, offset?: number, options?: any) {
            return CurrencyExchangeRateApiFp(configuration).getCurrencyExchangeRates(limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * CurrencyExchangeRateApi - object-oriented interface
 * @export
 * @class CurrencyExchangeRateApi
 * @extends {BaseAPI}
 */
export class CurrencyExchangeRateApi extends BaseAPI {
    /**
     * Calls CurrencyExchangeRate.php to get necessary variables
     * @summary Get an overview of all currency exchange rates
     * @param {number} [limit] Limits the number of entries returned. Default is 1000.    Be aware that there are over 100000 entries in the database for currency exchange rate, so using a limit higher than 1000 with offset&#x3D;0 is not recommended!    However you can set the offset appropriately so you minimize the amount of returned exchange rates and keep loading time to a low.
     * @param {number} [offset] Set the index where the returned currency exchange rates start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof CurrencyExchangeRateApi
     */
    public getCurrencyExchangeRates(limit?: number, offset?: number, options?: any) {
        return CurrencyExchangeRateApiFp(this.configuration).getCurrencyExchangeRates(limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * DiscountsApi - fetch parameter creator
 * @export
 */
export const DiscountsApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Discounts.php 
         * @summary Create a new discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDiscount(options: any = {}): FetchArgs {
            const localVarPath = `/Discounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Discounts.php
         * @summary Delete an existing discount
         * @param {number} id Id of discount you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDiscount.');
            }
            const localVarPath = `/Discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Discounts.php to get necessary variables.
         * @summary Get an overview of all discounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned discounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Discounts`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Discounts.php
         * @summary Update an existing discount
         * @param {number} id Id of discount you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDiscount.');
            }
            const localVarPath = `/Discounts/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DiscountsApi - functional programming interface
 * @export
 */
export const DiscountsApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Discounts.php 
         * @summary Create a new discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDiscount(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDiscounts> {
            const localVarFetchArgs = DiscountsApiFetchParamCreator(configuration).addDiscount(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Discounts.php
         * @summary Delete an existing discount
         * @param {number} id Id of discount you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DiscountsApiFetchParamCreator(configuration).deleteDiscount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Discounts.php to get necessary variables.
         * @summary Get an overview of all discounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned discounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDiscounts> {
            const localVarFetchArgs = DiscountsApiFetchParamCreator(configuration).getDiscounts(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Discounts.php
         * @summary Update an existing discount
         * @param {number} id Id of discount you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDiscounts> {
            const localVarFetchArgs = DiscountsApiFetchParamCreator(configuration).updateDiscount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DiscountsApi - factory interface
 * @export
 */
export const DiscountsApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Discounts.php 
         * @summary Create a new discount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDiscount(options?: any) {
            return DiscountsApiFp(configuration).addDiscount(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Discounts.php
         * @summary Delete an existing discount
         * @param {number} id Id of discount you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDiscount(id: number, options?: any) {
            return DiscountsApiFp(configuration).deleteDiscount(id, options)(fetch, basePath);
        },
        /**
         * Calls Discounts.php to get necessary variables.
         * @summary Get an overview of all discounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned discounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDiscounts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return DiscountsApiFp(configuration).getDiscounts(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls Discounts.php
         * @summary Update an existing discount
         * @param {number} id Id of discount you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDiscount(id: number, options?: any) {
            return DiscountsApiFp(configuration).updateDiscount(id, options)(fetch, basePath);
        },
    };
};

/**
 * DiscountsApi - object-oriented interface
 * @export
 * @class DiscountsApi
 * @extends {BaseAPI}
 */
export class DiscountsApi extends BaseAPI {
    /**
     * Calls Discounts.php 
     * @summary Create a new discount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public addDiscount(options?: any) {
        return DiscountsApiFp(this.configuration).addDiscount(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Discounts.php
     * @summary Delete an existing discount
     * @param {number} id Id of discount you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public deleteDiscount(id: number, options?: any) {
        return DiscountsApiFp(this.configuration).deleteDiscount(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Discounts.php to get necessary variables.
     * @summary Get an overview of all discounts
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned discounts start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public getDiscounts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return DiscountsApiFp(this.configuration).getDiscounts(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Discounts.php
     * @summary Update an existing discount
     * @param {number} id Id of discount you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DiscountsApi
     */
    public updateDiscount(id: number, options?: any) {
        return DiscountsApiFp(this.configuration).updateDiscount(id, options)(this.fetch, this.basePath);
    }

}
/**
 * DocServerApi - fetch parameter creator
 * @export
 */
export const DocServerApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls deleteLetterpaper() in DocServer.php to delete a specified letter paper
         * @summary Delete a specified letter paper
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerDeleteLetterPaper(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/deleteLetterpaper`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
         * @summary Delete a specified template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerDeleteTemplate(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/deleteTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getLetterpapers() in DocServer.php to get the stored letter papers
         * @summary Get an overview of all letter papers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetLetterPapers(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/getLetterpapers`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getLetterpapersWithThumb() in DocServer.php to get the stored letter papers with their thumb.
         * @summary Get an overview of all letter papers with their thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetLetterPapersWithThumb(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/getLetterpapersWithThumb`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTemplates() in DocServer.php to get the stored templates.
         * @summary Get an overview of all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetTemplates(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/getTemplates`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTemplatesWithThumb() in DocServer.php to get the stored templates with their thumb.
         * @summary Get an overview of all templates with their thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetTemplatesWithThumb(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/getTemplatesWithThumb`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls setDefaultLetterpaper() in DocServer.php to set the specified letter paper as the default letter paper
         * @summary Set a letter papers as the default letter paper
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerSetDefaultLetterPaper(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/setDefaultLetterpaper`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
         * @summary Set a template as the default template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerSetDefaultTemplate(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/setDefaultTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls storeLetterpaper() in DocServer.php to store a letter paper on the doc server
         * @summary Store a letter paper on the doc server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerStoreLetterPaper(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/storeLetterpaper`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls storeTemplate() in DocServer.php to store a template on the doc server
         * @summary Store a template on the doc server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerStoreTemplate(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/storeTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls testLetterpaper() in DocServer.php to test your letter paper by providing the pdf.
         * @summary Test a letter paper
         * @param {Blob} file 
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerTestLetterPaper(file: Blob, file: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling docServerTestLetterPaper.');
            }
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling docServerTestLetterPaper.');
            }
            const localVarPath = `/DocServer/testLetterpaper`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls testTemplate() in DocServer.php to test your template by providing the html.
         * @summary Test a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerTestTemplate(options: any = {}): FetchArgs {
            const localVarPath = `/DocServer/testTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocServerApi - functional programming interface
 * @export
 */
export const DocServerApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls deleteLetterpaper() in DocServer.php to delete a specified letter paper
         * @summary Delete a specified letter paper
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerDeleteLetterPaper(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerDeleteLetterPaper(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
         * @summary Delete a specified template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerDeleteTemplate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerDeleteTemplate(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getLetterpapers() in DocServer.php to get the stored letter papers
         * @summary Get an overview of all letter papers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetLetterPapers(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerGetLetterPapers(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getLetterpapersWithThumb() in DocServer.php to get the stored letter papers with their thumb.
         * @summary Get an overview of all letter papers with their thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetLetterPapersWithThumb(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerGetLetterPapersWithThumb(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTemplates() in DocServer.php to get the stored templates.
         * @summary Get an overview of all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetTemplates(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerGetTemplates(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTemplatesWithThumb() in DocServer.php to get the stored templates with their thumb.
         * @summary Get an overview of all templates with their thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetTemplatesWithThumb(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerGetTemplatesWithThumb(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls setDefaultLetterpaper() in DocServer.php to set the specified letter paper as the default letter paper
         * @summary Set a letter papers as the default letter paper
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerSetDefaultLetterPaper(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerSetDefaultLetterPaper(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
         * @summary Set a template as the default template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerSetDefaultTemplate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerSetDefaultTemplate(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls storeLetterpaper() in DocServer.php to store a letter paper on the doc server
         * @summary Store a letter paper on the doc server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerStoreLetterPaper(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerStoreLetterPaper(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls storeTemplate() in DocServer.php to store a template on the doc server
         * @summary Store a template on the doc server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerStoreTemplate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerStoreTemplate(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls testLetterpaper() in DocServer.php to test your letter paper by providing the pdf.
         * @summary Test a letter paper
         * @param {Blob} file 
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerTestLetterPaper(file: Blob, file: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerTestLetterPaper(file, file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls testTemplate() in DocServer.php to test your template by providing the html.
         * @summary Test a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerTestTemplate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocServerApiFetchParamCreator(configuration).docServerTestTemplate(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocServerApi - factory interface
 * @export
 */
export const DocServerApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls deleteLetterpaper() in DocServer.php to delete a specified letter paper
         * @summary Delete a specified letter paper
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerDeleteLetterPaper(options?: any) {
            return DocServerApiFp(configuration).docServerDeleteLetterPaper(options)(fetch, basePath);
        },
        /**
         * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
         * @summary Delete a specified template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerDeleteTemplate(options?: any) {
            return DocServerApiFp(configuration).docServerDeleteTemplate(options)(fetch, basePath);
        },
        /**
         * Calls getLetterpapers() in DocServer.php to get the stored letter papers
         * @summary Get an overview of all letter papers
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetLetterPapers(options?: any) {
            return DocServerApiFp(configuration).docServerGetLetterPapers(options)(fetch, basePath);
        },
        /**
         * Calls getLetterpapersWithThumb() in DocServer.php to get the stored letter papers with their thumb.
         * @summary Get an overview of all letter papers with their thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetLetterPapersWithThumb(options?: any) {
            return DocServerApiFp(configuration).docServerGetLetterPapersWithThumb(options)(fetch, basePath);
        },
        /**
         * Calls getTemplates() in DocServer.php to get the stored templates.
         * @summary Get an overview of all templates
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetTemplates(options?: any) {
            return DocServerApiFp(configuration).docServerGetTemplates(options)(fetch, basePath);
        },
        /**
         * Calls getTemplatesWithThumb() in DocServer.php to get the stored templates with their thumb.
         * @summary Get an overview of all templates with their thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerGetTemplatesWithThumb(options?: any) {
            return DocServerApiFp(configuration).docServerGetTemplatesWithThumb(options)(fetch, basePath);
        },
        /**
         * Calls setDefaultLetterpaper() in DocServer.php to set the specified letter paper as the default letter paper
         * @summary Set a letter papers as the default letter paper
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerSetDefaultLetterPaper(options?: any) {
            return DocServerApiFp(configuration).docServerSetDefaultLetterPaper(options)(fetch, basePath);
        },
        /**
         * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
         * @summary Set a template as the default template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerSetDefaultTemplate(options?: any) {
            return DocServerApiFp(configuration).docServerSetDefaultTemplate(options)(fetch, basePath);
        },
        /**
         * Calls storeLetterpaper() in DocServer.php to store a letter paper on the doc server
         * @summary Store a letter paper on the doc server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerStoreLetterPaper(options?: any) {
            return DocServerApiFp(configuration).docServerStoreLetterPaper(options)(fetch, basePath);
        },
        /**
         * Calls storeTemplate() in DocServer.php to store a template on the doc server
         * @summary Store a template on the doc server
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerStoreTemplate(options?: any) {
            return DocServerApiFp(configuration).docServerStoreTemplate(options)(fetch, basePath);
        },
        /**
         * Calls testLetterpaper() in DocServer.php to test your letter paper by providing the pdf.
         * @summary Test a letter paper
         * @param {Blob} file 
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerTestLetterPaper(file: Blob, file: Blob, options?: any) {
            return DocServerApiFp(configuration).docServerTestLetterPaper(file, file, options)(fetch, basePath);
        },
        /**
         * Calls testTemplate() in DocServer.php to test your template by providing the html.
         * @summary Test a template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        docServerTestTemplate(options?: any) {
            return DocServerApiFp(configuration).docServerTestTemplate(options)(fetch, basePath);
        },
    };
};

/**
 * DocServerApi - object-oriented interface
 * @export
 * @class DocServerApi
 * @extends {BaseAPI}
 */
export class DocServerApi extends BaseAPI {
    /**
     * Calls deleteLetterpaper() in DocServer.php to delete a specified letter paper
     * @summary Delete a specified letter paper
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerDeleteLetterPaper(options?: any) {
        return DocServerApiFp(this.configuration).docServerDeleteLetterPaper(options)(this.fetch, this.basePath);
    }

    /**
     * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
     * @summary Delete a specified template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerDeleteTemplate(options?: any) {
        return DocServerApiFp(this.configuration).docServerDeleteTemplate(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getLetterpapers() in DocServer.php to get the stored letter papers
     * @summary Get an overview of all letter papers
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerGetLetterPapers(options?: any) {
        return DocServerApiFp(this.configuration).docServerGetLetterPapers(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getLetterpapersWithThumb() in DocServer.php to get the stored letter papers with their thumb.
     * @summary Get an overview of all letter papers with their thumb
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerGetLetterPapersWithThumb(options?: any) {
        return DocServerApiFp(this.configuration).docServerGetLetterPapersWithThumb(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTemplates() in DocServer.php to get the stored templates.
     * @summary Get an overview of all templates
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerGetTemplates(options?: any) {
        return DocServerApiFp(this.configuration).docServerGetTemplates(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTemplatesWithThumb() in DocServer.php to get the stored templates with their thumb.
     * @summary Get an overview of all templates with their thumb
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerGetTemplatesWithThumb(options?: any) {
        return DocServerApiFp(this.configuration).docServerGetTemplatesWithThumb(options)(this.fetch, this.basePath);
    }

    /**
     * Calls setDefaultLetterpaper() in DocServer.php to set the specified letter paper as the default letter paper
     * @summary Set a letter papers as the default letter paper
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerSetDefaultLetterPaper(options?: any) {
        return DocServerApiFp(this.configuration).docServerSetDefaultLetterPaper(options)(this.fetch, this.basePath);
    }

    /**
     * Calls setDefaultTemplate() in DocServer.php to set the specified template as the default template
     * @summary Set a template as the default template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerSetDefaultTemplate(options?: any) {
        return DocServerApiFp(this.configuration).docServerSetDefaultTemplate(options)(this.fetch, this.basePath);
    }

    /**
     * Calls storeLetterpaper() in DocServer.php to store a letter paper on the doc server
     * @summary Store a letter paper on the doc server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerStoreLetterPaper(options?: any) {
        return DocServerApiFp(this.configuration).docServerStoreLetterPaper(options)(this.fetch, this.basePath);
    }

    /**
     * Calls storeTemplate() in DocServer.php to store a template on the doc server
     * @summary Store a template on the doc server
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerStoreTemplate(options?: any) {
        return DocServerApiFp(this.configuration).docServerStoreTemplate(options)(this.fetch, this.basePath);
    }

    /**
     * Calls testLetterpaper() in DocServer.php to test your letter paper by providing the pdf.
     * @summary Test a letter paper
     * @param {Blob} file 
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerTestLetterPaper(file: Blob, file: Blob, options?: any) {
        return DocServerApiFp(this.configuration).docServerTestLetterPaper(file, file, options)(this.fetch, this.basePath);
    }

    /**
     * Calls testTemplate() in DocServer.php to test your template by providing the html.
     * @summary Test a template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocServerApi
     */
    public docServerTestTemplate(options?: any) {
        return DocServerApiFp(this.configuration).docServerTestTemplate(options)(this.fetch, this.basePath);
    }

}
/**
 * DocumentApi - fetch parameter creator
 * @export
 */
export const DocumentApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Document.php
         * @summary Create a new document. Be aware that there wont be a working document with content!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument(options: any = {}): FetchArgs {
            const localVarPath = `/Document`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Document.php
         * @summary Delete an existing document
         * @param {number} id id of document you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDocument.');
            }
            const localVarPath = `/Document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls download() in Document.php to download a document. Will return base64 content.
         * @summary Download a document
         * @param {number} id Id of the document you want to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling downloadDocument.');
            }
            const localVarPath = `/Document/{id}/download`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Upload a file (creating a document)
         * @param {Blob} file 
         * @param {string} [object] object to which you want to upload your file
         * @param {string} [folder] folder to which you want to upload your file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        factoryAddDocument(file: Blob, object?: string, folder?: string, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling factoryAddDocument.');
            }
            const localVarPath = `/Document/Factory/fileUpload`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (object !== undefined) {
                localVarQueryParameter['object'] = object;
            }

            if (folder !== undefined) {
                localVarQueryParameter['folder'] = folder;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Document.php to get necessary variables
         * @summary Get an overview of all documents
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned documents start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Document`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Document.php
         * @summary Update an existing document. Be aware that you can only update its parameter but not the content of the document itself!
         * @param {number} id id of document you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDocument.');
            }
            const localVarPath = `/Document/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls trash() in Document.php
         * @summary Update an existing documents status to 'TRASHED', be aware that this deletes the document
         * @param {number} id id of document of which you want to update the status to &#x27;TRASHED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentStatusToTrashed(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDocumentStatusToTrashed.');
            }
            const localVarPath = `/Document/{id}/trash`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentApi - functional programming interface
 * @export
 */
export const DocumentApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Document.php
         * @summary Create a new document. Be aware that there wont be a working document with content!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocument> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).addDocument(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Document.php
         * @summary Delete an existing document
         * @param {number} id id of document you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).deleteDocument(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls download() in Document.php to download a document. Will return base64 content.
         * @summary Download a document
         * @param {number} id Id of the document you want to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).downloadDocument(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Upload a file (creating a document)
         * @param {Blob} file 
         * @param {string} [object] object to which you want to upload your file
         * @param {string} [folder] folder to which you want to upload your file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        factoryAddDocument(file: Blob, object?: string, folder?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).factoryAddDocument(file, object, folder, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Document.php to get necessary variables
         * @summary Get an overview of all documents
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned documents start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocument> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).getDocuments(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Document.php
         * @summary Update an existing document. Be aware that you can only update its parameter but not the content of the document itself!
         * @param {number} id id of document you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocument> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).updateDocument(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls trash() in Document.php
         * @summary Update an existing documents status to 'TRASHED', be aware that this deletes the document
         * @param {number} id id of document of which you want to update the status to &#x27;TRASHED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentStatusToTrashed(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = DocumentApiFetchParamCreator(configuration).updateDocumentStatusToTrashed(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentApi - factory interface
 * @export
 */
export const DocumentApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Document.php
         * @summary Create a new document. Be aware that there wont be a working document with content!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocument(options?: any) {
            return DocumentApiFp(configuration).addDocument(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Document.php
         * @summary Delete an existing document
         * @param {number} id id of document you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocument(id: number, options?: any) {
            return DocumentApiFp(configuration).deleteDocument(id, options)(fetch, basePath);
        },
        /**
         * Calls download() in Document.php to download a document. Will return base64 content.
         * @summary Download a document
         * @param {number} id Id of the document you want to download
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        downloadDocument(id: number, options?: any) {
            return DocumentApiFp(configuration).downloadDocument(id, options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Upload a file (creating a document)
         * @param {Blob} file 
         * @param {string} [object] object to which you want to upload your file
         * @param {string} [folder] folder to which you want to upload your file
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        factoryAddDocument(file: Blob, object?: string, folder?: string, options?: any) {
            return DocumentApiFp(configuration).factoryAddDocument(file, object, folder, options)(fetch, basePath);
        },
        /**
         * Calls Document.php to get necessary variables
         * @summary Get an overview of all documents
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned documents start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocuments(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return DocumentApiFp(configuration).getDocuments(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls Document.php
         * @summary Update an existing document. Be aware that you can only update its parameter but not the content of the document itself!
         * @param {number} id id of document you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocument(id: number, options?: any) {
            return DocumentApiFp(configuration).updateDocument(id, options)(fetch, basePath);
        },
        /**
         * Calls trash() in Document.php
         * @summary Update an existing documents status to 'TRASHED', be aware that this deletes the document
         * @param {number} id id of document of which you want to update the status to &#x27;TRASHED
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentStatusToTrashed(id: number, options?: any) {
            return DocumentApiFp(configuration).updateDocumentStatusToTrashed(id, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentApi - object-oriented interface
 * @export
 * @class DocumentApi
 * @extends {BaseAPI}
 */
export class DocumentApi extends BaseAPI {
    /**
     * Calls Document.php
     * @summary Create a new document. Be aware that there wont be a working document with content!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public addDocument(options?: any) {
        return DocumentApiFp(this.configuration).addDocument(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Document.php
     * @summary Delete an existing document
     * @param {number} id id of document you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public deleteDocument(id: number, options?: any) {
        return DocumentApiFp(this.configuration).deleteDocument(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls download() in Document.php to download a document. Will return base64 content.
     * @summary Download a document
     * @param {number} id Id of the document you want to download
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public downloadDocument(id: number, options?: any) {
        return DocumentApiFp(this.configuration).downloadDocument(id, options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
     * @summary Upload a file (creating a document)
     * @param {Blob} file 
     * @param {string} [object] object to which you want to upload your file
     * @param {string} [folder] folder to which you want to upload your file
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public factoryAddDocument(file: Blob, object?: string, folder?: string, options?: any) {
        return DocumentApiFp(this.configuration).factoryAddDocument(file, object, folder, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Document.php to get necessary variables
     * @summary Get an overview of all documents
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned documents start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public getDocuments(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return DocumentApiFp(this.configuration).getDocuments(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Document.php
     * @summary Update an existing document. Be aware that you can only update its parameter but not the content of the document itself!
     * @param {number} id id of document you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updateDocument(id: number, options?: any) {
        return DocumentApiFp(this.configuration).updateDocument(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls trash() in Document.php
     * @summary Update an existing documents status to 'TRASHED', be aware that this deletes the document
     * @param {number} id id of document of which you want to update the status to &#x27;TRASHED
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentApi
     */
    public updateDocumentStatusToTrashed(id: number, options?: any) {
        return DocumentApiFp(this.configuration).updateDocumentStatusToTrashed(id, options)(this.fetch, this.basePath);
    }

}
/**
 * DocumentFolderApi - fetch parameter creator
 * @export
 */
export const DocumentFolderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls DocumentFolder.php
         * @summary Create a new document folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentFolder(options: any = {}): FetchArgs {
            const localVarPath = `/DocumentFolder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in DocumentFolder.php
         * @summary Delete an existing document folder
         * @param {number} id id of document folder you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentFolder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteDocumentFolder.');
            }
            const localVarPath = `/DocumentFolder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the emptyBin() function in DocumentFolder.php
         * @summary Delete all objects in the bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyBin(options: any = {}): FetchArgs {
            const localVarPath = `/DocumentFolder/emptyBin`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getChildren() in DocumentFolder.php to get necessary variables
         * @summary Returns children (documents and document folders) as 'nodes' and count of all children as 'total'
         * @param {number} id Document folder of which you want to get the children
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned children start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderChildren(id: number, limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocumentFolderChildren.');
            }
            const localVarPath = `/DocumentFolder/{id}/getChildren`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDocuments() in DocumentFolder.php to get necessary variables
         * @summary Get an overview of all documents in a document folder
         * @param {number} id Document folder of which you want to get the containing documents
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned documents start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderDocuments(id: number, limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocumentFolderDocuments.');
            }
            const localVarPath = `/DocumentFolder/{id}/getDocuments`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getFolders() in DocumentFolder.php to get necessary variables
         * @summary Get an overview of all folders in a document folder
         * @param {number} id Document folder of which you want to get the containing folders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned folders start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderFolders(id: number, limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocumentFolderFolders.');
            }
            const localVarPath = `/DocumentFolder/{id}/getFolders`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPath() in DocumentFolder.php to get necessary variables
         * @summary Get path (all parent folders) of this folder
         * @param {number} id Document folder of which you want to get the path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderPath(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getDocumentFolderPath.');
            }
            const localVarPath = `/DocumentFolder/{id}/getPath`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls DocumentFolder.php to get necessary variables
         * @summary Get an overview of all document folders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned document folders start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolders(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/DocumentFolder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls trash() in DocumentFolder.php
         * @summary Trash an existing document folder
         * @param {number} id id of document folder you want to trash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trashDocumentFolder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling trashDocumentFolder.');
            }
            const localVarPath = `/DocumentFolder/{id}/trash`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls DocumentFolder.php
         * @summary Update an existing document folder
         * @param {number} id id of document folder you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentFolder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateDocumentFolder.');
            }
            const localVarPath = `/DocumentFolder/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentFolderApi - functional programming interface
 * @export
 */
export const DocumentFolderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls DocumentFolder.php
         * @summary Create a new document folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentFolder(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentFolder> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).addDocumentFolder(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in DocumentFolder.php
         * @summary Delete an existing document folder
         * @param {number} id id of document folder you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentFolder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).deleteDocumentFolder(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the emptyBin() function in DocumentFolder.php
         * @summary Delete all objects in the bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyBin(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).emptyBin(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getChildren() in DocumentFolder.php to get necessary variables
         * @summary Returns children (documents and document folders) as 'nodes' and count of all children as 'total'
         * @param {number} id Document folder of which you want to get the children
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned children start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderChildren(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentFolder> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).getDocumentFolderChildren(id, limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDocuments() in DocumentFolder.php to get necessary variables
         * @summary Get an overview of all documents in a document folder
         * @param {number} id Document folder of which you want to get the containing documents
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned documents start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderDocuments(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentFolder> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).getDocumentFolderDocuments(id, limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getFolders() in DocumentFolder.php to get necessary variables
         * @summary Get an overview of all folders in a document folder
         * @param {number} id Document folder of which you want to get the containing folders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned folders start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderFolders(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentFolder> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).getDocumentFolderFolders(id, limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPath() in DocumentFolder.php to get necessary variables
         * @summary Get path (all parent folders) of this folder
         * @param {number} id Document folder of which you want to get the path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderPath(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentFolder> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).getDocumentFolderPath(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls DocumentFolder.php to get necessary variables
         * @summary Get an overview of all document folders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned document folders start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolders(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentFolder> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).getDocumentFolders(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls trash() in DocumentFolder.php
         * @summary Trash an existing document folder
         * @param {number} id id of document folder you want to trash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trashDocumentFolder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).trashDocumentFolder(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls DocumentFolder.php
         * @summary Update an existing document folder
         * @param {number} id id of document folder you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentFolder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentFolder> {
            const localVarFetchArgs = DocumentFolderApiFetchParamCreator(configuration).updateDocumentFolder(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentFolderApi - factory interface
 * @export
 */
export const DocumentFolderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls DocumentFolder.php
         * @summary Create a new document folder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addDocumentFolder(options?: any) {
            return DocumentFolderApiFp(configuration).addDocumentFolder(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in DocumentFolder.php
         * @summary Delete an existing document folder
         * @param {number} id id of document folder you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteDocumentFolder(id: number, options?: any) {
            return DocumentFolderApiFp(configuration).deleteDocumentFolder(id, options)(fetch, basePath);
        },
        /**
         * Calls the emptyBin() function in DocumentFolder.php
         * @summary Delete all objects in the bin
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        emptyBin(options?: any) {
            return DocumentFolderApiFp(configuration).emptyBin(options)(fetch, basePath);
        },
        /**
         * Calls getChildren() in DocumentFolder.php to get necessary variables
         * @summary Returns children (documents and document folders) as 'nodes' and count of all children as 'total'
         * @param {number} id Document folder of which you want to get the children
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned children start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderChildren(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return DocumentFolderApiFp(configuration).getDocumentFolderChildren(id, limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getDocuments() in DocumentFolder.php to get necessary variables
         * @summary Get an overview of all documents in a document folder
         * @param {number} id Document folder of which you want to get the containing documents
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned documents start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderDocuments(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return DocumentFolderApiFp(configuration).getDocumentFolderDocuments(id, limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getFolders() in DocumentFolder.php to get necessary variables
         * @summary Get an overview of all folders in a document folder
         * @param {number} id Document folder of which you want to get the containing folders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned folders start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderFolders(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return DocumentFolderApiFp(configuration).getDocumentFolderFolders(id, limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getPath() in DocumentFolder.php to get necessary variables
         * @summary Get path (all parent folders) of this folder
         * @param {number} id Document folder of which you want to get the path
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolderPath(id: number, options?: any) {
            return DocumentFolderApiFp(configuration).getDocumentFolderPath(id, options)(fetch, basePath);
        },
        /**
         * Calls DocumentFolder.php to get necessary variables
         * @summary Get an overview of all document folders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned document folders start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentFolders(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return DocumentFolderApiFp(configuration).getDocumentFolders(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls trash() in DocumentFolder.php
         * @summary Trash an existing document folder
         * @param {number} id id of document folder you want to trash
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        trashDocumentFolder(id: number, options?: any) {
            return DocumentFolderApiFp(configuration).trashDocumentFolder(id, options)(fetch, basePath);
        },
        /**
         * Calls DocumentFolder.php
         * @summary Update an existing document folder
         * @param {number} id id of document folder you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateDocumentFolder(id: number, options?: any) {
            return DocumentFolderApiFp(configuration).updateDocumentFolder(id, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentFolderApi - object-oriented interface
 * @export
 * @class DocumentFolderApi
 * @extends {BaseAPI}
 */
export class DocumentFolderApi extends BaseAPI {
    /**
     * Calls DocumentFolder.php
     * @summary Create a new document folder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public addDocumentFolder(options?: any) {
        return DocumentFolderApiFp(this.configuration).addDocumentFolder(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in DocumentFolder.php
     * @summary Delete an existing document folder
     * @param {number} id id of document folder you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public deleteDocumentFolder(id: number, options?: any) {
        return DocumentFolderApiFp(this.configuration).deleteDocumentFolder(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the emptyBin() function in DocumentFolder.php
     * @summary Delete all objects in the bin
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public emptyBin(options?: any) {
        return DocumentFolderApiFp(this.configuration).emptyBin(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getChildren() in DocumentFolder.php to get necessary variables
     * @summary Returns children (documents and document folders) as 'nodes' and count of all children as 'total'
     * @param {number} id Document folder of which you want to get the children
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned children start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public getDocumentFolderChildren(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return DocumentFolderApiFp(this.configuration).getDocumentFolderChildren(id, limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDocuments() in DocumentFolder.php to get necessary variables
     * @summary Get an overview of all documents in a document folder
     * @param {number} id Document folder of which you want to get the containing documents
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned documents start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public getDocumentFolderDocuments(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return DocumentFolderApiFp(this.configuration).getDocumentFolderDocuments(id, limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getFolders() in DocumentFolder.php to get necessary variables
     * @summary Get an overview of all folders in a document folder
     * @param {number} id Document folder of which you want to get the containing folders
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned folders start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public getDocumentFolderFolders(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return DocumentFolderApiFp(this.configuration).getDocumentFolderFolders(id, limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPath() in DocumentFolder.php to get necessary variables
     * @summary Get path (all parent folders) of this folder
     * @param {number} id Document folder of which you want to get the path
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public getDocumentFolderPath(id: number, options?: any) {
        return DocumentFolderApiFp(this.configuration).getDocumentFolderPath(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls DocumentFolder.php to get necessary variables
     * @summary Get an overview of all document folders
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned document folders start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public getDocumentFolders(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return DocumentFolderApiFp(this.configuration).getDocumentFolders(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls trash() in DocumentFolder.php
     * @summary Trash an existing document folder
     * @param {number} id id of document folder you want to trash
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public trashDocumentFolder(id: number, options?: any) {
        return DocumentFolderApiFp(this.configuration).trashDocumentFolder(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls DocumentFolder.php
     * @summary Update an existing document folder
     * @param {number} id id of document folder you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentFolderApi
     */
    public updateDocumentFolder(id: number, options?: any) {
        return DocumentFolderApiFp(this.configuration).updateDocumentFolder(id, options)(this.fetch, this.basePath);
    }

}
/**
 * DocumentIndexApi - fetch parameter creator
 * @export
 */
export const DocumentIndexApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls DocumentIndex.php to get necessary variables.
         * @summary Get an overview of all document indexes
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned document indexes start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentIndexes(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/DocumentIndex`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * DocumentIndexApi - functional programming interface
 * @export
 */
export const DocumentIndexApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls DocumentIndex.php to get necessary variables.
         * @summary Get an overview of all document indexes
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned document indexes start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentIndexes(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDocumentIndex> {
            const localVarFetchArgs = DocumentIndexApiFetchParamCreator(configuration).getDocumentIndexes(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * DocumentIndexApi - factory interface
 * @export
 */
export const DocumentIndexApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls DocumentIndex.php to get necessary variables.
         * @summary Get an overview of all document indexes
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned document indexes start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getDocumentIndexes(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return DocumentIndexApiFp(configuration).getDocumentIndexes(limit, offset, embed, options)(fetch, basePath);
        },
    };
};

/**
 * DocumentIndexApi - object-oriented interface
 * @export
 * @class DocumentIndexApi
 * @extends {BaseAPI}
 */
export class DocumentIndexApi extends BaseAPI {
    /**
     * Calls DocumentIndex.php to get necessary variables.
     * @summary Get an overview of all document indexes
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned document indexes start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof DocumentIndexApi
     */
    public getDocumentIndexes(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return DocumentIndexApiFp(this.configuration).getDocumentIndexes(limit, offset, embed, options)(this.fetch, this.basePath);
    }

}
/**
 * EmailApi - fetch parameter creator
 * @export
 */
export const EmailApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Email.php
         * @summary Create a new email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail(options: any = {}): FetchArgs {
            const localVarPath = `/Email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Email.php
         * @summary Delete an existing email
         * @param {number} id id of email you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteEmail.');
            }
            const localVarPath = `/Email/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Email.php to get necessary variables
         * @summary Get an overview of all emails
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned emails start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Email`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Email.php
         * @summary Update an existing email
         * @param {number} id id of email you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateEmail.');
            }
            const localVarPath = `/Email/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EmailApi - functional programming interface
 * @export
 */
export const EmailApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Email.php
         * @summary Create a new email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEmail> {
            const localVarFetchArgs = EmailApiFetchParamCreator(configuration).addEmail(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Email.php
         * @summary Delete an existing email
         * @param {number} id id of email you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EmailApiFetchParamCreator(configuration).deleteEmail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Email.php to get necessary variables
         * @summary Get an overview of all emails
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned emails start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEmail> {
            const localVarFetchArgs = EmailApiFetchParamCreator(configuration).getEmails(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Email.php
         * @summary Update an existing email
         * @param {number} id id of email you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEmail> {
            const localVarFetchArgs = EmailApiFetchParamCreator(configuration).updateEmail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EmailApi - factory interface
 * @export
 */
export const EmailApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Email.php
         * @summary Create a new email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEmail(options?: any) {
            return EmailApiFp(configuration).addEmail(options)(fetch, basePath);
        },
        /**
         * Calls Email.php
         * @summary Delete an existing email
         * @param {number} id id of email you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEmail(id: number, options?: any) {
            return EmailApiFp(configuration).deleteEmail(id, options)(fetch, basePath);
        },
        /**
         * Calls Email.php to get necessary variables
         * @summary Get an overview of all emails
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned emails start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEmails(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return EmailApiFp(configuration).getEmails(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls Email.php
         * @summary Update an existing email
         * @param {number} id id of email you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEmail(id: number, options?: any) {
            return EmailApiFp(configuration).updateEmail(id, options)(fetch, basePath);
        },
    };
};

/**
 * EmailApi - object-oriented interface
 * @export
 * @class EmailApi
 * @extends {BaseAPI}
 */
export class EmailApi extends BaseAPI {
    /**
     * Calls Email.php
     * @summary Create a new email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public addEmail(options?: any) {
        return EmailApiFp(this.configuration).addEmail(options)(this.fetch, this.basePath);
    }

    /**
     * Calls Email.php
     * @summary Delete an existing email
     * @param {number} id id of email you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public deleteEmail(id: number, options?: any) {
        return EmailApiFp(this.configuration).deleteEmail(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Email.php to get necessary variables
     * @summary Get an overview of all emails
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned emails start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public getEmails(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return EmailApiFp(this.configuration).getEmails(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Email.php
     * @summary Update an existing email
     * @param {number} id id of email you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EmailApi
     */
    public updateEmail(id: number, options?: any) {
        return EmailApiFp(this.configuration).updateEmail(id, options)(this.fetch, this.basePath);
    }

}
/**
 * EntryTypeApi - fetch parameter creator
 * @export
 */
export const EntryTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls EntryType.php to create an entry type
         * @summary Create a new entry type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntryType(options: any = {}): FetchArgs {
            const localVarPath = `/EntryType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls EntryType.php to delete an entry type
         * @summary Delete an existing entry type
         * @param {number} id id of entry type you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntryType(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteEntryType.');
            }
            const localVarPath = `/EntryType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Tries to delete all objects bound to the specified entry type if they are not in use
         * @summary Delete all objects bound to the specified entry type
         * @param {number} id Id of entry type you want to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryTypeDeleteReferencedObjects(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling entryTypeDeleteReferencedObjects.');
            }
            const localVarPath = `/EntryType/{id}/deleteReferencedObjects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls EntryType.php to get necessary variables.
         * @summary Get an overview of all entry types
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned entry types start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntryTypes(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/EntryType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls EntryType.php to update an entry type
         * @summary Update an existing entry type
         * @param {number} id id of entry type you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntryType(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateEntryType.');
            }
            const localVarPath = `/EntryType/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * EntryTypeApi - functional programming interface
 * @export
 */
export const EntryTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls EntryType.php to create an entry type
         * @summary Create a new entry type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntryType(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEntryType> {
            const localVarFetchArgs = EntryTypeApiFetchParamCreator(configuration).addEntryType(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls EntryType.php to delete an entry type
         * @summary Delete an existing entry type
         * @param {number} id id of entry type you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntryType(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntryTypeApiFetchParamCreator(configuration).deleteEntryType(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Tries to delete all objects bound to the specified entry type if they are not in use
         * @summary Delete all objects bound to the specified entry type
         * @param {number} id Id of entry type you want to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryTypeDeleteReferencedObjects(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = EntryTypeApiFetchParamCreator(configuration).entryTypeDeleteReferencedObjects(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls EntryType.php to get necessary variables.
         * @summary Get an overview of all entry types
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned entry types start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntryTypes(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEntryType> {
            const localVarFetchArgs = EntryTypeApiFetchParamCreator(configuration).getEntryTypes(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls EntryType.php to update an entry type
         * @summary Update an existing entry type
         * @param {number} id id of entry type you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntryType(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEntryType> {
            const localVarFetchArgs = EntryTypeApiFetchParamCreator(configuration).updateEntryType(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * EntryTypeApi - factory interface
 * @export
 */
export const EntryTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls EntryType.php to create an entry type
         * @summary Create a new entry type
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addEntryType(options?: any) {
            return EntryTypeApiFp(configuration).addEntryType(options)(fetch, basePath);
        },
        /**
         * Calls EntryType.php to delete an entry type
         * @summary Delete an existing entry type
         * @param {number} id id of entry type you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteEntryType(id: number, options?: any) {
            return EntryTypeApiFp(configuration).deleteEntryType(id, options)(fetch, basePath);
        },
        /**
         * Tries to delete all objects bound to the specified entry type if they are not in use
         * @summary Delete all objects bound to the specified entry type
         * @param {number} id Id of entry type you want to use
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        entryTypeDeleteReferencedObjects(id: number, options?: any) {
            return EntryTypeApiFp(configuration).entryTypeDeleteReferencedObjects(id, options)(fetch, basePath);
        },
        /**
         * Calls EntryType.php to get necessary variables.
         * @summary Get an overview of all entry types
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned entry types start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getEntryTypes(limit?: number, offset?: number, options?: any) {
            return EntryTypeApiFp(configuration).getEntryTypes(limit, offset, options)(fetch, basePath);
        },
        /**
         * Calls EntryType.php to update an entry type
         * @summary Update an existing entry type
         * @param {number} id id of entry type you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateEntryType(id: number, options?: any) {
            return EntryTypeApiFp(configuration).updateEntryType(id, options)(fetch, basePath);
        },
    };
};

/**
 * EntryTypeApi - object-oriented interface
 * @export
 * @class EntryTypeApi
 * @extends {BaseAPI}
 */
export class EntryTypeApi extends BaseAPI {
    /**
     * Calls EntryType.php to create an entry type
     * @summary Create a new entry type
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryTypeApi
     */
    public addEntryType(options?: any) {
        return EntryTypeApiFp(this.configuration).addEntryType(options)(this.fetch, this.basePath);
    }

    /**
     * Calls EntryType.php to delete an entry type
     * @summary Delete an existing entry type
     * @param {number} id id of entry type you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryTypeApi
     */
    public deleteEntryType(id: number, options?: any) {
        return EntryTypeApiFp(this.configuration).deleteEntryType(id, options)(this.fetch, this.basePath);
    }

    /**
     * Tries to delete all objects bound to the specified entry type if they are not in use
     * @summary Delete all objects bound to the specified entry type
     * @param {number} id Id of entry type you want to use
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryTypeApi
     */
    public entryTypeDeleteReferencedObjects(id: number, options?: any) {
        return EntryTypeApiFp(this.configuration).entryTypeDeleteReferencedObjects(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls EntryType.php to get necessary variables.
     * @summary Get an overview of all entry types
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned entry types start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryTypeApi
     */
    public getEntryTypes(limit?: number, offset?: number, options?: any) {
        return EntryTypeApiFp(this.configuration).getEntryTypes(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls EntryType.php to update an entry type
     * @summary Update an existing entry type
     * @param {number} id id of entry type you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof EntryTypeApi
     */
    public updateEntryType(id: number, options?: any) {
        return EntryTypeApiFp(this.configuration).updateEntryType(id, options)(this.fetch, this.basePath);
    }

}
/**
 * ExportApi - fetch parameter creator
 * @export
 */
export const ExportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls contactCsv() in Export.php to export the specified contact as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the specified contact as csv
         * @param {number} contactId Id of the contact you want to export
         * @param {string} contactObjectName Model name which is exported
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContactCsv(contactId: number, contactObjectName: string, download?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId','Required parameter contactId was null or undefined when calling exportContactCsv.');
            }
            // verify required parameter 'contactObjectName' is not null or undefined
            if (contactObjectName === null || contactObjectName === undefined) {
                throw new RequiredError('contactObjectName','Required parameter contactObjectName was null or undefined when calling exportContactCsv.');
            }
            const localVarPath = `/Export/contactCsv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (contactId !== undefined) {
                localVarQueryParameter['contact[id]'] = contactId;
            }

            if (contactObjectName !== undefined) {
                localVarQueryParameter['contact[objectName]'] = contactObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls contactListCsv() in Export.php to export the contact list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported contacts
         * @param {boolean} [sevQueryFilterDepth] Specify if companies and persons (true) or only persons (false) should be exported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContactListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterDepth?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportContactListCsv.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportContactListCsv.');
            }
            const localVarPath = `/Export/contactListCsv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryFilterDepth !== undefined) {
                localVarQueryParameter['sevQuery[filter][depth]'] = sevQueryFilterDepth;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls datev() in Export.php to export the datev as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Datev export as zip with csv´s
         * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the datev export
         * @param {string} end Specify the end date for the datev export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDatev(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling exportDatev.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling exportDatev.');
            }
            // verify required parameter 'end' is not null or undefined
            if (end === null || end === undefined) {
                throw new RequiredError('end','Required parameter end was null or undefined when calling exportDatev.');
            }
            // verify required parameter 'withEnshrined' is not null or undefined
            if (withEnshrined === null || withEnshrined === undefined) {
                throw new RequiredError('withEnshrined','Required parameter withEnshrined was null or undefined when calling exportDatev.');
            }
            // verify required parameter 'enshrine' is not null or undefined
            if (enshrine === null || enshrine === undefined) {
                throw new RequiredError('enshrine','Required parameter enshrine was null or undefined when calling exportDatev.');
            }
            const localVarPath = `/Export/datev`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (withEnshrined !== undefined) {
                localVarQueryParameter['withEnshrined'] = withEnshrined;
            }

            if (enshrine !== undefined) {
                localVarQueryParameter['enshrine'] = enshrine;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls datevZip() in Export.php to export the zip for voucher upload.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export zip for voucher upload
         * @param {string} scope Define what you want to include in the zip export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the zip export
         * @param {string} end Specify the end date for the zip export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDatevZip(scope: string, start: string, end: string, withEnshrined: boolean, download?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling exportDatevZip.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling exportDatevZip.');
            }
            // verify required parameter 'end' is not null or undefined
            if (end === null || end === undefined) {
                throw new RequiredError('end','Required parameter end was null or undefined when calling exportDatevZip.');
            }
            // verify required parameter 'withEnshrined' is not null or undefined
            if (withEnshrined === null || withEnshrined === undefined) {
                throw new RequiredError('withEnshrined','Required parameter withEnshrined was null or undefined when calling exportDatevZip.');
            }
            const localVarPath = `/Export/datevZip`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (withEnshrined !== undefined) {
                localVarQueryParameter['withEnshrined'] = withEnshrined;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls inventoryPartLogListCsv() in Export.php to export the inventory part log list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the inventory part log as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported part log
         * @param {number} [sevQueryFilterPartId] Id of the part for which you want to export the part log
         * @param {string} [sevQueryFilterPartObjectName] Object name of part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInventoryPartLogList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterPartId?: number, sevQueryFilterPartObjectName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportInventoryPartLogList.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportInventoryPartLogList.');
            }
            const localVarPath = `/Export/inventoryPartLogListCsv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryFilterPartId !== undefined) {
                localVarQueryParameter['sevQuery[filter][part][id]'] = sevQueryFilterPartId;
            }

            if (sevQueryFilterPartObjectName !== undefined) {
                localVarQueryParameter['sevQuery[filter][part][objectName]'] = sevQueryFilterPartObjectName;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls invoiceCsv() in Export.php to export the invoice list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoice list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoiceCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportInvoiceCsv.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportInvoiceCsv.');
            }
            const localVarPath = `/Export/invoiceCsv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls invoiceZip() in Export.php to export the invoice list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoice list as zip with csv´s
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoiceZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportInvoiceZip.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportInvoiceZip.');
            }
            const localVarPath = `/Export/invoiceZip`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls partCsv() in Export.php to export the parts as csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the parts as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPartCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportPartCsv.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportPartCsv.');
            }
            const localVarPath = `/Export/partCsv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls pebe() in Export.php to export the pebe zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Pebe export as zip with csv´s
         * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the pebe export
         * @param {string} end Specify the end date for the pebe export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPebe(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'scope' is not null or undefined
            if (scope === null || scope === undefined) {
                throw new RequiredError('scope','Required parameter scope was null or undefined when calling exportPebe.');
            }
            // verify required parameter 'start' is not null or undefined
            if (start === null || start === undefined) {
                throw new RequiredError('start','Required parameter start was null or undefined when calling exportPebe.');
            }
            // verify required parameter 'end' is not null or undefined
            if (end === null || end === undefined) {
                throw new RequiredError('end','Required parameter end was null or undefined when calling exportPebe.');
            }
            // verify required parameter 'withEnshrined' is not null or undefined
            if (withEnshrined === null || withEnshrined === undefined) {
                throw new RequiredError('withEnshrined','Required parameter withEnshrined was null or undefined when calling exportPebe.');
            }
            // verify required parameter 'enshrine' is not null or undefined
            if (enshrine === null || enshrine === undefined) {
                throw new RequiredError('enshrine','Required parameter enshrine was null or undefined when calling exportPebe.');
            }
            const localVarPath = `/Export/pebe`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (scope !== undefined) {
                localVarQueryParameter['scope'] = scope;
            }

            if (start !== undefined) {
                localVarQueryParameter['start'] = start;
            }

            if (end !== undefined) {
                localVarQueryParameter['end'] = end;
            }

            if (withEnshrined !== undefined) {
                localVarQueryParameter['withEnshrined'] = withEnshrined;
            }

            if (enshrine !== undefined) {
                localVarQueryParameter['enshrine'] = enshrine;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls transactionsCsv() in Export.php to export the transactions as csv. Optionally you can provide a specific check account.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the transactions as csv
         * @param {boolean} sevQueryFilterRegister Specifies if the register is included
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {string} sevQueryOrderEntryDate Order in which you want to have the transactions listed
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [checkAccountId] Specify check account for which you want the transactions. Otherwise all transactions will be used
         * @param {string} [checkAccountObjectName] Check account model name
         * @param {number} [sevQueryLimit] Limit exported transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactionsCsv(sevQueryFilterRegister: boolean, sevQueryModelName: string, sevQueryObjectName: string, sevQueryOrderEntryDate: string, download?: boolean, checkAccountId?: number, checkAccountObjectName?: string, sevQueryLimit?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryFilterRegister' is not null or undefined
            if (sevQueryFilterRegister === null || sevQueryFilterRegister === undefined) {
                throw new RequiredError('sevQueryFilterRegister','Required parameter sevQueryFilterRegister was null or undefined when calling exportTransactionsCsv.');
            }
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportTransactionsCsv.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportTransactionsCsv.');
            }
            // verify required parameter 'sevQueryOrderEntryDate' is not null or undefined
            if (sevQueryOrderEntryDate === null || sevQueryOrderEntryDate === undefined) {
                throw new RequiredError('sevQueryOrderEntryDate','Required parameter sevQueryOrderEntryDate was null or undefined when calling exportTransactionsCsv.');
            }
            const localVarPath = `/Export/transactionsCsv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (checkAccountId !== undefined) {
                localVarQueryParameter['checkAccount[id]'] = checkAccountId;
            }

            if (checkAccountObjectName !== undefined) {
                localVarQueryParameter['checkAccount[objectName]'] = checkAccountObjectName;
            }

            if (sevQueryFilterRegister !== undefined) {
                localVarQueryParameter['sevQuery[filter][register]'] = sevQueryFilterRegister;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            if (sevQueryOrderEntryDate !== undefined) {
                localVarQueryParameter['sevQuery[order][entryDate]'] = sevQueryOrderEntryDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls voucherListCsv() in Export.php to export the voucher list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
         * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportVoucherListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportVoucherListCsv.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportVoucherListCsv.');
            }
            const localVarPath = `/Export/voucherListCsv`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryFilterStartDate !== undefined) {
                localVarQueryParameter['sevQuery[filter][startDate]'] = sevQueryFilterStartDate;
            }

            if (sevQueryFilterVoucherType !== undefined) {
                localVarQueryParameter['sevQuery[filter][voucherType]'] = sevQueryFilterVoucherType;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls voucherZip() in Export.php to export the voucher list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list as zip with csv´s
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
         * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportVoucherZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling exportVoucherZip.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling exportVoucherZip.');
            }
            const localVarPath = `/Export/voucherZip`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryFilterStartDate !== undefined) {
                localVarQueryParameter['sevQuery[filter][startDate]'] = sevQueryFilterStartDate;
            }

            if (sevQueryFilterVoucherType !== undefined) {
                localVarQueryParameter['sevQuery[filter][voucherType]'] = sevQueryFilterVoucherType;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ExportApi - functional programming interface
 * @export
 */
export const ExportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls contactCsv() in Export.php to export the specified contact as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the specified contact as csv
         * @param {number} contactId Id of the contact you want to export
         * @param {string} contactObjectName Model name which is exported
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContactCsv(contactId: number, contactObjectName: string, download?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportContactCsv(contactId, contactObjectName, download, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls contactListCsv() in Export.php to export the contact list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported contacts
         * @param {boolean} [sevQueryFilterDepth] Specify if companies and persons (true) or only persons (false) should be exported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContactListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterDepth?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportContactListCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterDepth, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls datev() in Export.php to export the datev as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Datev export as zip with csv´s
         * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the datev export
         * @param {string} end Specify the end date for the datev export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDatev(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportDatev(scope, start, end, withEnshrined, enshrine, download, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls datevZip() in Export.php to export the zip for voucher upload.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export zip for voucher upload
         * @param {string} scope Define what you want to include in the zip export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the zip export
         * @param {string} end Specify the end date for the zip export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDatevZip(scope: string, start: string, end: string, withEnshrined: boolean, download?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportDatevZip(scope, start, end, withEnshrined, download, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls inventoryPartLogListCsv() in Export.php to export the inventory part log list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the inventory part log as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported part log
         * @param {number} [sevQueryFilterPartId] Id of the part for which you want to export the part log
         * @param {string} [sevQueryFilterPartObjectName] Object name of part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInventoryPartLogList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterPartId?: number, sevQueryFilterPartObjectName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportInventoryPartLogList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterPartId, sevQueryFilterPartObjectName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls invoiceCsv() in Export.php to export the invoice list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoice list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoiceCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportInvoiceCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls invoiceZip() in Export.php to export the invoice list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoice list as zip with csv´s
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoiceZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportInvoiceZip(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls partCsv() in Export.php to export the parts as csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the parts as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPartCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportPartCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls pebe() in Export.php to export the pebe zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Pebe export as zip with csv´s
         * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the pebe export
         * @param {string} end Specify the end date for the pebe export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPebe(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportPebe(scope, start, end, withEnshrined, enshrine, download, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls transactionsCsv() in Export.php to export the transactions as csv. Optionally you can provide a specific check account.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the transactions as csv
         * @param {boolean} sevQueryFilterRegister Specifies if the register is included
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {string} sevQueryOrderEntryDate Order in which you want to have the transactions listed
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [checkAccountId] Specify check account for which you want the transactions. Otherwise all transactions will be used
         * @param {string} [checkAccountObjectName] Check account model name
         * @param {number} [sevQueryLimit] Limit exported transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactionsCsv(sevQueryFilterRegister: boolean, sevQueryModelName: string, sevQueryObjectName: string, sevQueryOrderEntryDate: string, download?: boolean, checkAccountId?: number, checkAccountObjectName?: string, sevQueryLimit?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportTransactionsCsv(sevQueryFilterRegister, sevQueryModelName, sevQueryObjectName, sevQueryOrderEntryDate, download, checkAccountId, checkAccountObjectName, sevQueryLimit, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls voucherListCsv() in Export.php to export the voucher list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
         * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportVoucherListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportVoucherListCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterStartDate, sevQueryFilterVoucherType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls voucherZip() in Export.php to export the voucher list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list as zip with csv´s
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
         * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportVoucherZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ExportApiFetchParamCreator(configuration).exportVoucherZip(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterStartDate, sevQueryFilterVoucherType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ExportApi - factory interface
 * @export
 */
export const ExportApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls contactCsv() in Export.php to export the specified contact as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the specified contact as csv
         * @param {number} contactId Id of the contact you want to export
         * @param {string} contactObjectName Model name which is exported
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContactCsv(contactId: number, contactObjectName: string, download?: boolean, options?: any) {
            return ExportApiFp(configuration).exportContactCsv(contactId, contactObjectName, download, options)(fetch, basePath);
        },
        /**
         * Calls contactListCsv() in Export.php to export the contact list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported contacts
         * @param {boolean} [sevQueryFilterDepth] Specify if companies and persons (true) or only persons (false) should be exported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportContactListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterDepth?: boolean, options?: any) {
            return ExportApiFp(configuration).exportContactListCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterDepth, options)(fetch, basePath);
        },
        /**
         * Calls datev() in Export.php to export the datev as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Datev export as zip with csv´s
         * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the datev export
         * @param {string} end Specify the end date for the datev export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDatev(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options?: any) {
            return ExportApiFp(configuration).exportDatev(scope, start, end, withEnshrined, enshrine, download, options)(fetch, basePath);
        },
        /**
         * Calls datevZip() in Export.php to export the zip for voucher upload.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export zip for voucher upload
         * @param {string} scope Define what you want to include in the zip export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the zip export
         * @param {string} end Specify the end date for the zip export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportDatevZip(scope: string, start: string, end: string, withEnshrined: boolean, download?: boolean, options?: any) {
            return ExportApiFp(configuration).exportDatevZip(scope, start, end, withEnshrined, download, options)(fetch, basePath);
        },
        /**
         * Calls inventoryPartLogListCsv() in Export.php to export the inventory part log list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the inventory part log as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported part log
         * @param {number} [sevQueryFilterPartId] Id of the part for which you want to export the part log
         * @param {string} [sevQueryFilterPartObjectName] Object name of part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInventoryPartLogList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterPartId?: number, sevQueryFilterPartObjectName?: string, options?: any) {
            return ExportApiFp(configuration).exportInventoryPartLogList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterPartId, sevQueryFilterPartObjectName, options)(fetch, basePath);
        },
        /**
         * Calls invoiceCsv() in Export.php to export the invoice list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoice list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoiceCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any) {
            return ExportApiFp(configuration).exportInvoiceCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options)(fetch, basePath);
        },
        /**
         * Calls invoiceZip() in Export.php to export the invoice list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoice list as zip with csv´s
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportInvoiceZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any) {
            return ExportApiFp(configuration).exportInvoiceZip(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options)(fetch, basePath);
        },
        /**
         * Calls partCsv() in Export.php to export the parts as csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the parts as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPartCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any) {
            return ExportApiFp(configuration).exportPartCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options)(fetch, basePath);
        },
        /**
         * Calls pebe() in Export.php to export the pebe zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Pebe export as zip with csv´s
         * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
         * @param {string} start Specify the start date for the pebe export
         * @param {string} end Specify the end date for the pebe export
         * @param {boolean} withEnshrined Specify if you want to include enshrined models
         * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportPebe(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options?: any) {
            return ExportApiFp(configuration).exportPebe(scope, start, end, withEnshrined, enshrine, download, options)(fetch, basePath);
        },
        /**
         * Calls transactionsCsv() in Export.php to export the transactions as csv. Optionally you can provide a specific check account.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the transactions as csv
         * @param {boolean} sevQueryFilterRegister Specifies if the register is included
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {string} sevQueryOrderEntryDate Order in which you want to have the transactions listed
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [checkAccountId] Specify check account for which you want the transactions. Otherwise all transactions will be used
         * @param {string} [checkAccountObjectName] Check account model name
         * @param {number} [sevQueryLimit] Limit exported transactions
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportTransactionsCsv(sevQueryFilterRegister: boolean, sevQueryModelName: string, sevQueryObjectName: string, sevQueryOrderEntryDate: string, download?: boolean, checkAccountId?: number, checkAccountObjectName?: string, sevQueryLimit?: number, options?: any) {
            return ExportApiFp(configuration).exportTransactionsCsv(sevQueryFilterRegister, sevQueryModelName, sevQueryObjectName, sevQueryOrderEntryDate, download, checkAccountId, checkAccountObjectName, sevQueryLimit, options)(fetch, basePath);
        },
        /**
         * Calls voucherListCsv() in Export.php to export the voucher list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list as csv
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
         * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportVoucherListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options?: any) {
            return ExportApiFp(configuration).exportVoucherListCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterStartDate, sevQueryFilterVoucherType, options)(fetch, basePath);
        },
        /**
         * Calls voucherZip() in Export.php to export the voucher list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list as zip with csv´s
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
         * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        exportVoucherZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options?: any) {
            return ExportApiFp(configuration).exportVoucherZip(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterStartDate, sevQueryFilterVoucherType, options)(fetch, basePath);
        },
    };
};

/**
 * ExportApi - object-oriented interface
 * @export
 * @class ExportApi
 * @extends {BaseAPI}
 */
export class ExportApi extends BaseAPI {
    /**
     * Calls contactCsv() in Export.php to export the specified contact as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the specified contact as csv
     * @param {number} contactId Id of the contact you want to export
     * @param {string} contactObjectName Model name which is exported
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportContactCsv(contactId: number, contactObjectName: string, download?: boolean, options?: any) {
        return ExportApiFp(this.configuration).exportContactCsv(contactId, contactObjectName, download, options)(this.fetch, this.basePath);
    }

    /**
     * Calls contactListCsv() in Export.php to export the contact list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the contact list as csv
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported contacts
     * @param {boolean} [sevQueryFilterDepth] Specify if companies and persons (true) or only persons (false) should be exported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportContactListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterDepth?: boolean, options?: any) {
        return ExportApiFp(this.configuration).exportContactListCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterDepth, options)(this.fetch, this.basePath);
    }

    /**
     * Calls datev() in Export.php to export the datev as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Datev export as zip with csv´s
     * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
     * @param {string} start Specify the start date for the datev export
     * @param {string} end Specify the end date for the datev export
     * @param {boolean} withEnshrined Specify if you want to include enshrined models
     * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportDatev(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options?: any) {
        return ExportApiFp(this.configuration).exportDatev(scope, start, end, withEnshrined, enshrine, download, options)(this.fetch, this.basePath);
    }

    /**
     * Calls datevZip() in Export.php to export the zip for voucher upload.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export zip for voucher upload
     * @param {string} scope Define what you want to include in the zip export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
     * @param {string} start Specify the start date for the zip export
     * @param {string} end Specify the end date for the zip export
     * @param {boolean} withEnshrined Specify if you want to include enshrined models
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportDatevZip(scope: string, start: string, end: string, withEnshrined: boolean, download?: boolean, options?: any) {
        return ExportApiFp(this.configuration).exportDatevZip(scope, start, end, withEnshrined, download, options)(this.fetch, this.basePath);
    }

    /**
     * Calls inventoryPartLogListCsv() in Export.php to export the inventory part log list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the inventory part log as csv
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported part log
     * @param {number} [sevQueryFilterPartId] Id of the part for which you want to export the part log
     * @param {string} [sevQueryFilterPartObjectName] Object name of part
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportInventoryPartLogList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterPartId?: number, sevQueryFilterPartObjectName?: string, options?: any) {
        return ExportApiFp(this.configuration).exportInventoryPartLogList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterPartId, sevQueryFilterPartObjectName, options)(this.fetch, this.basePath);
    }

    /**
     * Calls invoiceCsv() in Export.php to export the invoice list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the invoice list as csv
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportInvoiceCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any) {
        return ExportApiFp(this.configuration).exportInvoiceCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options)(this.fetch, this.basePath);
    }

    /**
     * Calls invoiceZip() in Export.php to export the invoice list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the invoice list as zip with csv´s
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportInvoiceZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any) {
        return ExportApiFp(this.configuration).exportInvoiceZip(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options)(this.fetch, this.basePath);
    }

    /**
     * Calls partCsv() in Export.php to export the parts as csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the parts as csv
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported part
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportPartCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, options?: any) {
        return ExportApiFp(this.configuration).exportPartCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, options)(this.fetch, this.basePath);
    }

    /**
     * Calls pebe() in Export.php to export the pebe zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Pebe export as zip with csv´s
     * @param {string} scope Define what you want to include in the datev export. This parameter takes a string of 4 letters. Each stands for a model that should be included.    Possible letters are: **&#x27;I&#x27;** (Invoices), **&#x27;V&#x27;** (Vouchers), **&#x27;D&#x27;** (Depreciations), **&#x27;T&#x27;** (Transactions).    By providing one of those letter you specify that it should be included in the datev export. Some combinations are: &#x27;IVDT&#x27;, &#x27;IVT&#x27; ...
     * @param {string} start Specify the start date for the pebe export
     * @param {string} end Specify the end date for the pebe export
     * @param {boolean} withEnshrined Specify if you want to include enshrined models
     * @param {ModelObject} enshrine Specify if you want to enshrine all models which were included in the export
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportPebe(scope: string, start: string, end: string, withEnshrined: boolean, enshrine: ModelObject, download?: boolean, options?: any) {
        return ExportApiFp(this.configuration).exportPebe(scope, start, end, withEnshrined, enshrine, download, options)(this.fetch, this.basePath);
    }

    /**
     * Calls transactionsCsv() in Export.php to export the transactions as csv. Optionally you can provide a specific check account.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the transactions as csv
     * @param {boolean} sevQueryFilterRegister Specifies if the register is included
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {string} sevQueryOrderEntryDate Order in which you want to have the transactions listed
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [checkAccountId] Specify check account for which you want the transactions. Otherwise all transactions will be used
     * @param {string} [checkAccountObjectName] Check account model name
     * @param {number} [sevQueryLimit] Limit exported transactions
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportTransactionsCsv(sevQueryFilterRegister: boolean, sevQueryModelName: string, sevQueryObjectName: string, sevQueryOrderEntryDate: string, download?: boolean, checkAccountId?: number, checkAccountObjectName?: string, sevQueryLimit?: number, options?: any) {
        return ExportApiFp(this.configuration).exportTransactionsCsv(sevQueryFilterRegister, sevQueryModelName, sevQueryObjectName, sevQueryOrderEntryDate, download, checkAccountId, checkAccountObjectName, sevQueryLimit, options)(this.fetch, this.basePath);
    }

    /**
     * Calls voucherListCsv() in Export.php to export the voucher list as a csv.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the voucher list as csv
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported vouchers
     * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
     * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportVoucherListCsv(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options?: any) {
        return ExportApiFp(this.configuration).exportVoucherListCsv(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterStartDate, sevQueryFilterVoucherType, options)(this.fetch, this.basePath);
    }

    /**
     * Calls voucherZip() in Export.php to export the voucher list as a zip with csv´s.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the voucher list as zip with csv´s
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported vouchers
     * @param {string} [sevQueryFilterStartDate] Start date of the voucher list
     * @param {string} [sevQueryFilterVoucherType] Type of vouchers you want to export
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ExportApi
     */
    public exportVoucherZip(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryFilterStartDate?: string, sevQueryFilterVoucherType?: string, options?: any) {
        return ExportApiFp(this.configuration).exportVoucherZip(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryFilterStartDate, sevQueryFilterVoucherType, options)(this.fetch, this.basePath);
    }

}
/**
 * FeedApi - fetch parameter creator
 * @export
 */
export const FeedApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Feed.php to add an action to the feed
         * @summary Create a new action which will be displayed in the feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeed(options: any = {}): FetchArgs {
            const localVarPath = `/Feed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Deletes a feed action
         * @summary Delete an existing feed action
         * @param {number} id id of feed action you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeed(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteFeed.');
            }
            const localVarPath = `/Feed/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Feed.php to get necessary variables.
         * @summary Get an overview of all actions from everyone, which will be displayed in the dashboard
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned feeds start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Feed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getParsedObjectAction() in Feed.php to get more information about the specified object
         * @summary Get more information about the specific feed object
         * @param {number} id Feed id of the object you want to get more information about
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParsedObjectAction(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getParsedObjectAction.');
            }
            const localVarPath = `/Feed/{id}/getParsedObjectAction`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Feed action
         * @param {number} id id of feed action you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeed(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateFeed.');
            }
            const localVarPath = `/Feed/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * FeedApi - functional programming interface
 * @export
 */
export const FeedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Feed.php to add an action to the feed
         * @summary Create a new action which will be displayed in the feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeed(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelFeed> {
            const localVarFetchArgs = FeedApiFetchParamCreator(configuration).addFeed(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Deletes a feed action
         * @summary Delete an existing feed action
         * @param {number} id id of feed action you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeed(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FeedApiFetchParamCreator(configuration).deleteFeed(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Feed.php to get necessary variables.
         * @summary Get an overview of all actions from everyone, which will be displayed in the dashboard
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned feeds start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelFeed> {
            const localVarFetchArgs = FeedApiFetchParamCreator(configuration).getFeeds(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getParsedObjectAction() in Feed.php to get more information about the specified object
         * @summary Get more information about the specific feed object
         * @param {number} id Feed id of the object you want to get more information about
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParsedObjectAction(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = FeedApiFetchParamCreator(configuration).getParsedObjectAction(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Feed action
         * @param {number} id id of feed action you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeed(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelFeed> {
            const localVarFetchArgs = FeedApiFetchParamCreator(configuration).updateFeed(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * FeedApi - factory interface
 * @export
 */
export const FeedApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Feed.php to add an action to the feed
         * @summary Create a new action which will be displayed in the feed
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addFeed(options?: any) {
            return FeedApiFp(configuration).addFeed(options)(fetch, basePath);
        },
        /**
         * Deletes a feed action
         * @summary Delete an existing feed action
         * @param {number} id id of feed action you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteFeed(id: number, options?: any) {
            return FeedApiFp(configuration).deleteFeed(id, options)(fetch, basePath);
        },
        /**
         * Calls Feed.php to get necessary variables.
         * @summary Get an overview of all actions from everyone, which will be displayed in the dashboard
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned feeds start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getFeeds(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return FeedApiFp(configuration).getFeeds(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getParsedObjectAction() in Feed.php to get more information about the specified object
         * @summary Get more information about the specific feed object
         * @param {number} id Feed id of the object you want to get more information about
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParsedObjectAction(id: number, options?: any) {
            return FeedApiFp(configuration).getParsedObjectAction(id, options)(fetch, basePath);
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Feed action
         * @param {number} id id of feed action you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateFeed(id: number, options?: any) {
            return FeedApiFp(configuration).updateFeed(id, options)(fetch, basePath);
        },
    };
};

/**
 * FeedApi - object-oriented interface
 * @export
 * @class FeedApi
 * @extends {BaseAPI}
 */
export class FeedApi extends BaseAPI {
    /**
     * Calls Feed.php to add an action to the feed
     * @summary Create a new action which will be displayed in the feed
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public addFeed(options?: any) {
        return FeedApiFp(this.configuration).addFeed(options)(this.fetch, this.basePath);
    }

    /**
     * Deletes a feed action
     * @summary Delete an existing feed action
     * @param {number} id id of feed action you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public deleteFeed(id: number, options?: any) {
        return FeedApiFp(this.configuration).deleteFeed(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Feed.php to get necessary variables.
     * @summary Get an overview of all actions from everyone, which will be displayed in the dashboard
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned feeds start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public getFeeds(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return FeedApiFp(this.configuration).getFeeds(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getParsedObjectAction() in Feed.php to get more information about the specified object
     * @summary Get more information about the specific feed object
     * @param {number} id Feed id of the object you want to get more information about
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public getParsedObjectAction(id: number, options?: any) {
        return FeedApiFp(this.configuration).getParsedObjectAction(id, options)(this.fetch, this.basePath);
    }

    /**
     * TODO: Enter short backend documentation here
     * @summary Update an existing Feed action
     * @param {number} id id of feed action you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof FeedApi
     */
    public updateFeed(id: number, options?: any) {
        return FeedApiFp(this.configuration).updateFeed(id, options)(this.fetch, this.basePath);
    }

}
/**
 * HelpApi - fetch parameter creator
 * @export
 */
export const HelpApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls getArticle() in Help.php to get a specified help article
         * @summary Get a specified article
         * @param {number} articleId Id of the article you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetArticle(articleId: number, options: any = {}): FetchArgs {
            // verify required parameter 'articleId' is not null or undefined
            if (articleId === null || articleId === undefined) {
                throw new RequiredError('articleId','Required parameter articleId was null or undefined when calling helpGetArticle.');
            }
            const localVarPath = `/Help/getArticle`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (articleId !== undefined) {
                localVarQueryParameter['articleId'] = articleId;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getArticles() in Help.php to get all help articles for a specified section
         * @summary Get all help articles for a specified section
         * @param {number} sectionId Section id you want to get help articles about
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned help articles start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetArticles(sectionId: number, limit?: number, offset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sectionId' is not null or undefined
            if (sectionId === null || sectionId === undefined) {
                throw new RequiredError('sectionId','Required parameter sectionId was null or undefined when calling helpGetArticles.');
            }
            const localVarPath = `/Help/getArticles`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sectionId !== undefined) {
                localVarQueryParameter['sectionId'] = sectionId;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCategories() in Help.php to get all categories available for searching help articles
         * @summary Get all categories of help articles
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sections start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetCategories(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Help/getCategories`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getSections() in Help.php to get all sections available for searching help articles
         * @summary Get all sections of help articles
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sections start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetSections(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Help/getSections`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls search() in Help.php to search for articles
         * @summary Search for articles
         * @param {string} [name] String to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpSearchArticles(name?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Help/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (name !== undefined) {
                localVarQueryParameter['name'] = name;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * HelpApi - functional programming interface
 * @export
 */
export const HelpApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls getArticle() in Help.php to get a specified help article
         * @summary Get a specified article
         * @param {number} articleId Id of the article you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetArticle(articleId: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelHelp> {
            const localVarFetchArgs = HelpApiFetchParamCreator(configuration).helpGetArticle(articleId, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getArticles() in Help.php to get all help articles for a specified section
         * @summary Get all help articles for a specified section
         * @param {number} sectionId Section id you want to get help articles about
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned help articles start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetArticles(sectionId: number, limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelHelp> {
            const localVarFetchArgs = HelpApiFetchParamCreator(configuration).helpGetArticles(sectionId, limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCategories() in Help.php to get all categories available for searching help articles
         * @summary Get all categories of help articles
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sections start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetCategories(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelHelp> {
            const localVarFetchArgs = HelpApiFetchParamCreator(configuration).helpGetCategories(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getSections() in Help.php to get all sections available for searching help articles
         * @summary Get all sections of help articles
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sections start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetSections(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelHelp> {
            const localVarFetchArgs = HelpApiFetchParamCreator(configuration).helpGetSections(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls search() in Help.php to search for articles
         * @summary Search for articles
         * @param {string} [name] String to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpSearchArticles(name?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelHelp> {
            const localVarFetchArgs = HelpApiFetchParamCreator(configuration).helpSearchArticles(name, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * HelpApi - factory interface
 * @export
 */
export const HelpApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls getArticle() in Help.php to get a specified help article
         * @summary Get a specified article
         * @param {number} articleId Id of the article you want to get
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetArticle(articleId: number, options?: any) {
            return HelpApiFp(configuration).helpGetArticle(articleId, options)(fetch, basePath);
        },
        /**
         * Calls getArticles() in Help.php to get all help articles for a specified section
         * @summary Get all help articles for a specified section
         * @param {number} sectionId Section id you want to get help articles about
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned help articles start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetArticles(sectionId: number, limit?: number, offset?: number, options?: any) {
            return HelpApiFp(configuration).helpGetArticles(sectionId, limit, offset, options)(fetch, basePath);
        },
        /**
         * Calls getCategories() in Help.php to get all categories available for searching help articles
         * @summary Get all categories of help articles
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sections start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetCategories(limit?: number, offset?: number, options?: any) {
            return HelpApiFp(configuration).helpGetCategories(limit, offset, options)(fetch, basePath);
        },
        /**
         * Calls getSections() in Help.php to get all sections available for searching help articles
         * @summary Get all sections of help articles
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sections start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpGetSections(limit?: number, offset?: number, options?: any) {
            return HelpApiFp(configuration).helpGetSections(limit, offset, options)(fetch, basePath);
        },
        /**
         * Calls search() in Help.php to search for articles
         * @summary Search for articles
         * @param {string} [name] String to search for
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        helpSearchArticles(name?: string, options?: any) {
            return HelpApiFp(configuration).helpSearchArticles(name, options)(fetch, basePath);
        },
    };
};

/**
 * HelpApi - object-oriented interface
 * @export
 * @class HelpApi
 * @extends {BaseAPI}
 */
export class HelpApi extends BaseAPI {
    /**
     * Calls getArticle() in Help.php to get a specified help article
     * @summary Get a specified article
     * @param {number} articleId Id of the article you want to get
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpApi
     */
    public helpGetArticle(articleId: number, options?: any) {
        return HelpApiFp(this.configuration).helpGetArticle(articleId, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getArticles() in Help.php to get all help articles for a specified section
     * @summary Get all help articles for a specified section
     * @param {number} sectionId Section id you want to get help articles about
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned help articles start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpApi
     */
    public helpGetArticles(sectionId: number, limit?: number, offset?: number, options?: any) {
        return HelpApiFp(this.configuration).helpGetArticles(sectionId, limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCategories() in Help.php to get all categories available for searching help articles
     * @summary Get all categories of help articles
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned sections start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpApi
     */
    public helpGetCategories(limit?: number, offset?: number, options?: any) {
        return HelpApiFp(this.configuration).helpGetCategories(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getSections() in Help.php to get all sections available for searching help articles
     * @summary Get all sections of help articles
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned sections start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpApi
     */
    public helpGetSections(limit?: number, offset?: number, options?: any) {
        return HelpApiFp(this.configuration).helpGetSections(limit, offset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls search() in Help.php to search for articles
     * @summary Search for articles
     * @param {string} [name] String to search for
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof HelpApi
     */
    public helpSearchArticles(name?: string, options?: any) {
        return HelpApiFp(this.configuration).helpSearchArticles(name, options)(this.fetch, this.basePath);
    }

}
/**
 * InventoryPartLogApi - fetch parameter creator
 * @export
 */
export const InventoryPartLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls InventoryPartLog.php
         * @summary Create a new inventory part log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInventoryPartLog(options: any = {}): FetchArgs {
            const localVarPath = `/InventoryPartLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in InventoryPartLog.php    Be aware that this operations sets the stock of your part to the value it had before the acquisition/dispatch and deletes the corresponding feed!
         * @summary Delete an existing inventory part log
         * @param {number} id id of inventory part log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInventoryPartLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteInventoryPartLog.');
            }
            const localVarPath = `/InventoryPartLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls InventoryPartLog.php to get necessary variables
         * @summary Get an overview of InventoryPartLog
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryPartLog(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/InventoryPartLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getStock() in InventoryPartLog.php to get the stock of the part involved in the part log
         * @summary Get stock of inventory part involved in part log
         * @param {number} id Id of inventory part log you want to get the stock from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryPartLogStock(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInventoryPartLogStock.');
            }
            const localVarPath = `/InventoryPartLog/{id}/getStock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls InventoryPartLog.php
         * @summary Update an existing inventory part log
         * @param {number} id id of inventory part log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventoryPartLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateInventoryPartLog.');
            }
            const localVarPath = `/InventoryPartLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InventoryPartLogApi - functional programming interface
 * @export
 */
export const InventoryPartLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls InventoryPartLog.php
         * @summary Create a new inventory part log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInventoryPartLog(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInventoryPartLog> {
            const localVarFetchArgs = InventoryPartLogApiFetchParamCreator(configuration).addInventoryPartLog(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in InventoryPartLog.php    Be aware that this operations sets the stock of your part to the value it had before the acquisition/dispatch and deletes the corresponding feed!
         * @summary Delete an existing inventory part log
         * @param {number} id id of inventory part log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInventoryPartLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InventoryPartLogApiFetchParamCreator(configuration).deleteInventoryPartLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls InventoryPartLog.php to get necessary variables
         * @summary Get an overview of InventoryPartLog
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryPartLog(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInventoryPartLog> {
            const localVarFetchArgs = InventoryPartLogApiFetchParamCreator(configuration).getInventoryPartLog(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getStock() in InventoryPartLog.php to get the stock of the part involved in the part log
         * @summary Get stock of inventory part involved in part log
         * @param {number} id Id of inventory part log you want to get the stock from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryPartLogStock(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InventoryPartLogApiFetchParamCreator(configuration).getInventoryPartLogStock(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls InventoryPartLog.php
         * @summary Update an existing inventory part log
         * @param {number} id id of inventory part log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventoryPartLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInventoryPartLog> {
            const localVarFetchArgs = InventoryPartLogApiFetchParamCreator(configuration).updateInventoryPartLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InventoryPartLogApi - factory interface
 * @export
 */
export const InventoryPartLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls InventoryPartLog.php
         * @summary Create a new inventory part log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInventoryPartLog(options?: any) {
            return InventoryPartLogApiFp(configuration).addInventoryPartLog(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in InventoryPartLog.php    Be aware that this operations sets the stock of your part to the value it had before the acquisition/dispatch and deletes the corresponding feed!
         * @summary Delete an existing inventory part log
         * @param {number} id id of inventory part log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInventoryPartLog(id: number, options?: any) {
            return InventoryPartLogApiFp(configuration).deleteInventoryPartLog(id, options)(fetch, basePath);
        },
        /**
         * Calls InventoryPartLog.php to get necessary variables
         * @summary Get an overview of InventoryPartLog
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryPartLog(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return InventoryPartLogApiFp(configuration).getInventoryPartLog(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getStock() in InventoryPartLog.php to get the stock of the part involved in the part log
         * @summary Get stock of inventory part involved in part log
         * @param {number} id Id of inventory part log you want to get the stock from
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInventoryPartLogStock(id: number, options?: any) {
            return InventoryPartLogApiFp(configuration).getInventoryPartLogStock(id, options)(fetch, basePath);
        },
        /**
         * Calls InventoryPartLog.php
         * @summary Update an existing inventory part log
         * @param {number} id id of inventory part log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInventoryPartLog(id: number, options?: any) {
            return InventoryPartLogApiFp(configuration).updateInventoryPartLog(id, options)(fetch, basePath);
        },
    };
};

/**
 * InventoryPartLogApi - object-oriented interface
 * @export
 * @class InventoryPartLogApi
 * @extends {BaseAPI}
 */
export class InventoryPartLogApi extends BaseAPI {
    /**
     * Calls InventoryPartLog.php
     * @summary Create a new inventory part log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryPartLogApi
     */
    public addInventoryPartLog(options?: any) {
        return InventoryPartLogApiFp(this.configuration).addInventoryPartLog(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in InventoryPartLog.php    Be aware that this operations sets the stock of your part to the value it had before the acquisition/dispatch and deletes the corresponding feed!
     * @summary Delete an existing inventory part log
     * @param {number} id id of inventory part log you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryPartLogApi
     */
    public deleteInventoryPartLog(id: number, options?: any) {
        return InventoryPartLogApiFp(this.configuration).deleteInventoryPartLog(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls InventoryPartLog.php to get necessary variables
     * @summary Get an overview of InventoryPartLog
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned part logs start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryPartLogApi
     */
    public getInventoryPartLog(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return InventoryPartLogApiFp(this.configuration).getInventoryPartLog(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getStock() in InventoryPartLog.php to get the stock of the part involved in the part log
     * @summary Get stock of inventory part involved in part log
     * @param {number} id Id of inventory part log you want to get the stock from
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryPartLogApi
     */
    public getInventoryPartLogStock(id: number, options?: any) {
        return InventoryPartLogApiFp(this.configuration).getInventoryPartLogStock(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls InventoryPartLog.php
     * @summary Update an existing inventory part log
     * @param {number} id id of inventory part log you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InventoryPartLogApi
     */
    public updateInventoryPartLog(id: number, options?: any) {
        return InventoryPartLogApiFp(this.configuration).updateInventoryPartLog(id, options)(this.fetch, this.basePath);
    }

}
/**
 * InvoiceApi - fetch parameter creator
 * @export
 */
export const InvoiceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Invoice.php 
         * @summary Create a new invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoice(options: any = {}): FetchArgs {
            const localVarPath = `/Invoice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls cancel() in Invoice.php to cancel an invoice and creates a cancellation invoice  
         * @summary Cancel an invoice
         * @param {number} id Id of invoice which you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling cancelInvoice.');
            }
            const localVarPath = `/Invoice/{id}/cancel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create an new invoice from an existing order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceFromOrder(options: any = {}): FetchArgs {
            const localVarPath = `/Invoice/Factory/createInvoiceFromOrder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create an invoice reminder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceReminder(options: any = {}): FetchArgs {
            const localVarPath = `/Invoice/Factory/createInvoiceReminder`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Invoice.php
         * @summary Delete an existing invoice
         * @param {number} id id of invoice you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteInvoice.');
            }
            const localVarPath = `/Invoice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls duplicate() in Invoice.php to duplicate an existing invoice
         * @summary Duplicate an existing invoice
         * @param {number} id id of invoice you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateInvoice(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling duplicateInvoice.');
            }
            const localVarPath = `/Invoice/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the getTotalInvoiceReminderAndInvoiceAmount function in /Invoice/Factory/ to get the amount of the invoice including its reminders.
         * @summary Get amount of an invoice including reminders
         * @param {number} invoiceId id of the invoice you want to get the total amount for
         * @param {string} invoiceObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAndReminderAmount(invoiceId: number, invoiceObjectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoiceAndReminderAmount.');
            }
            // verify required parameter 'invoiceObjectName' is not null or undefined
            if (invoiceObjectName === null || invoiceObjectName === undefined) {
                throw new RequiredError('invoiceObjectName','Required parameter invoiceObjectName was null or undefined when calling getInvoiceAndReminderAmount.');
            }
            const localVarPath = `/Invoice/Factory/getTotalInvoiceReminderAndInvoiceAmount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (invoiceId !== undefined) {
                localVarQueryParameter['invoice[id]'] = invoiceId;
            }

            if (invoiceObjectName !== undefined) {
                localVarQueryParameter['invoice[objectName]'] = invoiceObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPdf in Invoice.php
         * @summary Get the invoice as a PDF
         * @param {number} id Id of invoice of which you want to get the PDF
         * @param {boolean} download If true PDF will return as filestream otherwise as json object the content base64 encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsPdf(id: number, download: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getInvoiceAsPdf.');
            }
            // verify required parameter 'download' is not null or undefined
            if (download === null || download === undefined) {
                throw new RequiredError('download','Required parameter download was null or undefined when calling getInvoiceAsPdf.');
            }
            const localVarPath = `/Invoice/{id}/getPdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the getTotalInvoiceReminderAmount function in /Invoice/Factory/ to get the amount of all reminders of an invoice.
         * @summary Get (monetary) amount of all reminders of an invoice
         * @param {number} invoiceId id of the invoice you want to get the reminder amount for
         * @param {string} invoiceObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceReminderAmount(invoiceId: number, invoiceObjectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceId' is not null or undefined
            if (invoiceId === null || invoiceId === undefined) {
                throw new RequiredError('invoiceId','Required parameter invoiceId was null or undefined when calling getInvoiceReminderAmount.');
            }
            // verify required parameter 'invoiceObjectName' is not null or undefined
            if (invoiceObjectName === null || invoiceObjectName === undefined) {
                throw new RequiredError('invoiceObjectName','Required parameter invoiceObjectName was null or undefined when calling getInvoiceReminderAmount.');
            }
            const localVarPath = `/Invoice/Factory/getTotalInvoiceReminderAmount`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (invoiceId !== undefined) {
                localVarQueryParameter['invoice[id]'] = invoiceId;
            }

            if (invoiceObjectName !== undefined) {
                localVarQueryParameter['invoice[objectName]'] = invoiceObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Invoice.php to get necessary variables. However, not all variables get their value from Invoice.php directly but from other models like Model_InvoicePos or Model_Part
         * @summary Get an overview of all invoices
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoices start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Invoice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the next invoice number
         * @param {string} invoiceType defines the type of invoice you want to get the next number from
         * @param {boolean} useNextNumber By default this is true, so the invoiceNumber will increase by one otherwise the invoiceNumber will not change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextInvoiceNumber(invoiceType: string, useNextNumber: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'invoiceType' is not null or undefined
            if (invoiceType === null || invoiceType === undefined) {
                throw new RequiredError('invoiceType','Required parameter invoiceType was null or undefined when calling getNextInvoiceNumber.');
            }
            // verify required parameter 'useNextNumber' is not null or undefined
            if (useNextNumber === null || useNextNumber === undefined) {
                throw new RequiredError('useNextNumber','Required parameter useNextNumber was null or undefined when calling getNextInvoiceNumber.');
            }
            const localVarPath = `/Invoice/Factory/getNextInvoiceNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (invoiceType !== undefined) {
                localVarQueryParameter['invoiceType'] = invoiceType;
            }

            if (useNextNumber !== undefined) {
                localVarQueryParameter['useNextNumber'] = useNextNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls addPosition() in Invoice.php to add a position to an invoice.    This function is not required anymore as there is a function for creating Invoices in Invoice/Factory which includes adding the position.
         * @summary Add a position to an existing invoice
         * @param {number} id id of invoice you want to add a position to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceAddPosition(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceAddPosition.');
            }
            const localVarPath = `/Invoice/{id}/addPosition`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls bookAmmount() in Invoice.php to book an invoice amount
         * @summary Book amount for an invoice
         * @param {number} id Id of invoice of which you want to book an amount
         * @param {number} ammount amount which should be booked
         * @param {string} date booking date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceBookAmount(id: number, ammount: number, date: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceBookAmount.');
            }
            // verify required parameter 'ammount' is not null or undefined
            if (ammount === null || ammount === undefined) {
                throw new RequiredError('ammount','Required parameter ammount was null or undefined when calling invoiceBookAmount.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling invoiceBookAmount.');
            }
            const localVarPath = `/Invoice/{id}/bookAmmount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ammount !== undefined) {
                localVarQueryParameter['ammount'] = ammount;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls calcTotalDebit() in Invoice.php to calculate total sum of all invoices of current query
         * @summary Calculate total sum of all invoices of current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCalcTotalDebit(options: any = {}): FetchArgs {
            const localVarPath = `/Invoice/calcTotalDebit`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls calculateDunningLevel() in Invoice.php to get the dunning level of an invoice
         * @summary Get dunning level of an invoice
         * @param {number} id Id of invoice of which you want to get the dunning level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCalculateDunningLevel(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceCalculateDunningLevel.');
            }
            const localVarPath = `/Invoice/{id}/calculateDunningLevel`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls changeStatus() in Invoice.php to book an invoice amount
         * @summary Change status of an invoice
         * @param {number} id Id of invoice of which you want to book an amount
         * @param {number} value desired status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceChangeStatus(id: number, value: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceChangeStatus.');
            }
            // verify required parameter 'value' is not null or undefined
            if (value === null || value === undefined) {
                throw new RequiredError('value','Required parameter value was null or undefined when calling invoiceChangeStatus.');
            }
            const localVarPath = `/Invoice/{id}/changeStatus`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (value !== undefined) {
                localVarQueryParameter['value'] = value;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCancled() in Invoice.php to know if an invoice is cancled
         * @summary Returns if an invoice is cancled
         * @param {number} id Id of invoice of which you want to know if it is cancled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCancled(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetCancled.');
            }
            const localVarPath = `/Invoice/{id}/getCancled`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCheckAccountTransactionLogs() in Invoice.php to get check account transaction logs about the invoice
         * @summary Get check account transaction logs about a specified invoice
         * @param {number} id Id of the invoice of which you want to get the check account transaction logs
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetCheckAccountTransactionLogs.');
            }
            const localVarPath = `/Invoice/{id}/getCheckAccountTransactionLogs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCheckAccountTransactions() in Invoice.php to get check account transactions of the invoice
         * @summary Get check account transactions of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the check account transactions
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCheckAccountTransactions(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetCheckAccountTransactions.');
            }
            const localVarPath = `/Invoice/{id}/getCheckAccountTransactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDebit() in Invoice.php to get debit of an invoice
         * @summary Get debit of an invoice
         * @param {number} id Id of invoice of which you want to get the debit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDebit(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetDebit.');
            }
            const localVarPath = `/Invoice/{id}/getDebit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDelinquent() in Invoice.php to get if an invoice is delinquent
         * @summary Get if an invoice is delinquent
         * @param {number} id Id of invoice of which you want to know if its delinquent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDelinquent(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetDelinquent.');
            }
            const localVarPath = `/Invoice/{id}/getDelinquent`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDiscounts() in Invoice.php
         * @summary Get the discounts of a specified invoice
         * @param {number} id Id of invoice of which you want to get the discounts
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDiscounts(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetDiscounts.');
            }
            const localVarPath = `/Invoice/{id}/getDiscounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDocument() in Invoice.php to get the document of an invoice
         * @summary Get document of an invoice
         * @param {number} id Id of invoice of which you want to get the document
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDocument(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetDocument.');
            }
            const localVarPath = `/Invoice/{id}/getDocument`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDunnings() in Invoice.php to get the dunnings of an invoice
         * @summary Get invoice dunnings
         * @param {number} id Id of invoice of which you want to get the dunnings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDunnings(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetDunnings.');
            }
            const localVarPath = `/Invoice/{id}/getDunnings`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getFeed() in Invoice.php
         * @summary Get the feed of a specified invoice
         * @param {number} id Id of invoice of which you want to get the feed
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetFeed(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetFeed.');
            }
            const localVarPath = `/Invoice/{id}/getFeed`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getFinalInvoiceId() in Invoice.php to get final invoice id of the invoice chain
         * @summary Get final invoice id
         * @param {number} id Id of the invoice of which you want to get the final invoice id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetFinalInvoiceId(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetFinalInvoiceId.');
            }
            const localVarPath = `/Invoice/{id}/getFinalInvoiceId`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getIsPartiallyPaid() in Invoice.php
         * @summary Returns if the invoice is partially payed
         * @param {number} id Id of invoice of which you want to know if it is partially paid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetIsPartiallyPaid(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetIsPartiallyPaid.');
            }
            const localVarPath = `/Invoice/{id}/getIsPartiallyPaid`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getLastDunningDate() in Invoice.php to get the date of the last dunning of an invoice
         * @summary Get last dunning date of invoice as timestamp
         * @param {number} id Id of invoice of which you want to get the date of the last dunning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetLastDunningDate(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetLastDunningDate.');
            }
            const localVarPath = `/Invoice/{id}/getLastDunningDate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPartialInvoices() in Invoice.php to get partial invoices of the invoice
         * @summary Get partial invoices of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the partial invoices
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetPartialInvoices(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetPartialInvoices.');
            }
            const localVarPath = `/Invoice/{id}/getPartialInvoices`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPositions() in Invoice.php
         * @summary Get the positions of a specified invoice
         * @param {number} id Id of invoice of which you want to get the positions
         * @param {number} [limit] limits the number of entries returned
         * @param {number} [offset] set the index where the returned entries start
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetPositions(id: number, limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetPositions.');
            }
            const localVarPath = `/Invoice/{id}/getPositions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getRelatedObjects() in Invoice.php to get related objects of the invoice
         * @summary Get related objects of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the related objects
         * @param {boolean} [includeItself] Define if the related objects include the invoice itself
         * @param {boolean} [sortByType] Define if you want the related objects sorted by type
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetRelatedObjects.');
            }
            const localVarPath = `/Invoice/{id}/getRelatedObjects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (includeItself !== undefined) {
                localVarQueryParameter['includeItself'] = includeItself;
            }

            if (sortByType !== undefined) {
                localVarQueryParameter['sortByType'] = sortByType;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getSwissEsr() in Invoice.php to get the swiss esr
         * @summary Get swiss esr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetSwissEsr(options: any = {}): FetchArgs {
            const localVarPath = `/Invoice/getSwissEsr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getSwissEsrData() in Invoice.php to get the swiss esr data
         * @summary Get swiss esr data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetSwissEsrData(options: any = {}): FetchArgs {
            const localVarPath = `/Invoice/getSwissEsrData`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTags() in Invoice.php
         * @summary Get the tags of a specified invoice
         * @param {number} id Id of invoice of which you want to get the tags
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTags(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetTags.');
            }
            const localVarPath = `/Invoice/{id}/getTags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTax() in Invoice.php to get tax amount of invoice
         * @summary Get invoice tax amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the invoice tax amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumTax from invoice or sumTaxAccounting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTax(id: number, invoiceAmount?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetTax.');
            }
            const localVarPath = `/Invoice/{id}/getTax`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (invoiceAmount !== undefined) {
                localVarQueryParameter['invoiceAmount'] = invoiceAmount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTaxGroupes() in Invoice.php to get tax groups
         * @summary Get tax groups of invoice
         * @param {number} id Id of invoice of which you want to get the tax groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTaxGroups(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetTaxGroups.');
            }
            const localVarPath = `/Invoice/{id}/getTaxGroupes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTotal() in Invoice.php to get gross amount of invoice
         * @summary Get gross invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the gross invoice amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumGross from invoice or sumGrossAccounting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotal(id: number, invoiceAmount?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetTotal.');
            }
            const localVarPath = `/Invoice/{id}/getTotal`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (invoiceAmount !== undefined) {
                localVarQueryParameter['invoiceAmount'] = invoiceAmount;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTotalCalc() in Invoice.php to get tax groups
         * @summary Get total invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the invoice amount in invoice currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotalCalc(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetTotalCalc.');
            }
            const localVarPath = `/Invoice/{id}/getTotalCalc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTotalNet() in Invoice.php to get total net amount of invoice
         * @summary Get total net invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the total net invoice amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumNet from invoice or sumNetAccounting
         * @param {boolean} [withoutDiscounts] Determines whether the total net is calculated with or without the discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotalNet(id: number, invoiceAmount?: boolean, withoutDiscounts?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceGetTotalNet.');
            }
            const localVarPath = `/Invoice/{id}/getTotalNet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (invoiceAmount !== undefined) {
                localVarQueryParameter['invoiceAmount'] = invoiceAmount;
            }

            if (withoutDiscounts !== undefined) {
                localVarQueryParameter['withoutDiscounts'] = withoutDiscounts;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls hasDiscounts() in Invoice.php
         * @summary Returns if the specified invoice has discounts
         * @param {number} id Id of invoice of which you want to know if it has discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceHasDiscounts(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceHasDiscounts.');
            }
            const localVarPath = `/Invoice/{id}/hasDiscounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls isOrigin() in Invoice.php to find out if the invoice is the origin of an order
         * @summary Returns if the specified invoice is the origin of an order
         * @param {number} id Id of invoice of which you want to know if it is the origin of an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceIsOrigin(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceIsOrigin.');
            }
            const localVarPath = `/Invoice/{id}/isOrigin`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls markAsSent() in Invoice.php to mark an invoice as sent
         * @summary Marks an invoice as sent
         * @param {number} id Id of invoice which you want to mark as sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceMarkAsSent(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceMarkAsSent.');
            }
            const localVarPath = `/Invoice/{id}/markAsSent`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls refundAmmount() in Invoice.php to refund an invoice amount
         * @summary Refund an already payed invoice amount
         * @param {number} id Id of invoice of which you want to refund the amount
         * @param {number} ammount amount which should be refunded
         * @param {string} date booking date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceRefundAmount(id: number, ammount: number, date: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceRefundAmount.');
            }
            // verify required parameter 'ammount' is not null or undefined
            if (ammount === null || ammount === undefined) {
                throw new RequiredError('ammount','Required parameter ammount was null or undefined when calling invoiceRefundAmount.');
            }
            // verify required parameter 'date' is not null or undefined
            if (date === null || date === undefined) {
                throw new RequiredError('date','Required parameter date was null or undefined when calling invoiceRefundAmount.');
            }
            const localVarPath = `/Invoice/{id}/refundAmmount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (ammount !== undefined) {
                localVarQueryParameter['ammount'] = ammount;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls render() in Invoice.php to render invoice document on docserver and return the metadata
         * @summary Render invoice document on docserver and return metadata
         * @param {number} id Id of invoice of which you want to render the document and get the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceRender(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceRender.');
            }
            const localVarPath = `/Invoice/{id}/render`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendBy() in Invoice.php to send an invoice by the desired method
         * @summary Send invoice by desired method
         * @param {number} id Id of invoice which you want to send
         * @param {string} sendType desired send type, available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceSendBy(id: number, sendType: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling invoiceSendBy.');
            }
            // verify required parameter 'sendType' is not null or undefined
            if (sendType === null || sendType === undefined) {
                throw new RequiredError('sendType','Required parameter sendType was null or undefined when calling invoiceSendBy.');
            }
            const localVarPath = `/Invoice/{id}/sendBy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sendType !== undefined) {
                localVarQueryParameter['sendType'] = sendType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create a new invoice (with / without invoice positions and discounts) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveInvoice(options: any = {}): FetchArgs {
            const localVarPath = `/Invoice/Factory/saveInvoice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendViaEmail in Invoice.php
         * @summary Send an invoice via Email
         * @param {number} id id of invoice you want to send via Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoiceViaEmail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendInvoiceViaEmail.');
            }
            const localVarPath = `/Invoice/{id}/sendViaEmail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendViaPost in Invoice.php
         * @summary Send an invoice via Letter
         * @param {number} id id of invoice you want to send via Letter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoiceViaPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendInvoiceViaPost.');
            }
            const localVarPath = `/Invoice/{id}/sendViaPost`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Invoice.php
         * @summary Update an existing invoice
         * @param {number} id id of invoice you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateInvoice.');
            }
            const localVarPath = `/Invoice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceApi - functional programming interface
 * @export
 */
export const InvoiceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Invoice.php 
         * @summary Create a new invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoice(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).addInvoice(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls cancel() in Invoice.php to cancel an invoice and creates a cancellation invoice  
         * @summary Cancel an invoice
         * @param {number} id Id of invoice which you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).cancelInvoice(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create an new invoice from an existing order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceFromOrder(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).createInvoiceFromOrder(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create an invoice reminder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceReminder(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).createInvoiceReminder(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Invoice.php
         * @summary Delete an existing invoice
         * @param {number} id id of invoice you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).deleteInvoice(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls duplicate() in Invoice.php to duplicate an existing invoice
         * @summary Duplicate an existing invoice
         * @param {number} id id of invoice you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateInvoice(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).duplicateInvoice(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the getTotalInvoiceReminderAndInvoiceAmount function in /Invoice/Factory/ to get the amount of the invoice including its reminders.
         * @summary Get amount of an invoice including reminders
         * @param {number} invoiceId id of the invoice you want to get the total amount for
         * @param {string} invoiceObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAndReminderAmount(invoiceId: number, invoiceObjectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).getInvoiceAndReminderAmount(invoiceId, invoiceObjectName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPdf in Invoice.php
         * @summary Get the invoice as a PDF
         * @param {number} id Id of invoice of which you want to get the PDF
         * @param {boolean} download If true PDF will return as filestream otherwise as json object the content base64 encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsPdf(id: number, download: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).getInvoiceAsPdf(id, download, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the getTotalInvoiceReminderAmount function in /Invoice/Factory/ to get the amount of all reminders of an invoice.
         * @summary Get (monetary) amount of all reminders of an invoice
         * @param {number} invoiceId id of the invoice you want to get the reminder amount for
         * @param {string} invoiceObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceReminderAmount(invoiceId: number, invoiceObjectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<any> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).getInvoiceReminderAmount(invoiceId, invoiceObjectName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Invoice.php to get necessary variables. However, not all variables get their value from Invoice.php directly but from other models like Model_InvoicePos or Model_Part
         * @summary Get an overview of all invoices
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoices start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).getInvoices(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the next invoice number
         * @param {string} invoiceType defines the type of invoice you want to get the next number from
         * @param {boolean} useNextNumber By default this is true, so the invoiceNumber will increase by one otherwise the invoiceNumber will not change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextInvoiceNumber(invoiceType: string, useNextNumber: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).getNextInvoiceNumber(invoiceType, useNextNumber, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls addPosition() in Invoice.php to add a position to an invoice.    This function is not required anymore as there is a function for creating Invoices in Invoice/Factory which includes adding the position.
         * @summary Add a position to an existing invoice
         * @param {number} id id of invoice you want to add a position to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceAddPosition(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceAddPosition(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls bookAmmount() in Invoice.php to book an invoice amount
         * @summary Book amount for an invoice
         * @param {number} id Id of invoice of which you want to book an amount
         * @param {number} ammount amount which should be booked
         * @param {string} date booking date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceBookAmount(id: number, ammount: number, date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoiceLog> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceBookAmount(id, ammount, date, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls calcTotalDebit() in Invoice.php to calculate total sum of all invoices of current query
         * @summary Calculate total sum of all invoices of current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCalcTotalDebit(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceCalcTotalDebit(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls calculateDunningLevel() in Invoice.php to get the dunning level of an invoice
         * @summary Get dunning level of an invoice
         * @param {number} id Id of invoice of which you want to get the dunning level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCalculateDunningLevel(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceCalculateDunningLevel(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls changeStatus() in Invoice.php to book an invoice amount
         * @summary Change status of an invoice
         * @param {number} id Id of invoice of which you want to book an amount
         * @param {number} value desired status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceChangeStatus(id: number, value: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceChangeStatus(id, value, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCancled() in Invoice.php to know if an invoice is cancled
         * @summary Returns if an invoice is cancled
         * @param {number} id Id of invoice of which you want to know if it is cancled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCancled(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetCancled(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCheckAccountTransactionLogs() in Invoice.php to get check account transaction logs about the invoice
         * @summary Get check account transaction logs about a specified invoice
         * @param {number} id Id of the invoice of which you want to get the check account transaction logs
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransactionLog> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetCheckAccountTransactionLogs(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCheckAccountTransactions() in Invoice.php to get check account transactions of the invoice
         * @summary Get check account transactions of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the check account transactions
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCheckAccountTransactions(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelCheckAccountTransaction> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetCheckAccountTransactions(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDebit() in Invoice.php to get debit of an invoice
         * @summary Get debit of an invoice
         * @param {number} id Id of invoice of which you want to get the debit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDebit(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetDebit(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDelinquent() in Invoice.php to get if an invoice is delinquent
         * @summary Get if an invoice is delinquent
         * @param {number} id Id of invoice of which you want to know if its delinquent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDelinquent(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetDelinquent(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDiscounts() in Invoice.php
         * @summary Get the discounts of a specified invoice
         * @param {number} id Id of invoice of which you want to get the discounts
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDiscounts(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDiscounts> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetDiscounts(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDocument() in Invoice.php to get the document of an invoice
         * @summary Get document of an invoice
         * @param {number} id Id of invoice of which you want to get the document
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDocument(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetDocument(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDunnings() in Invoice.php to get the dunnings of an invoice
         * @summary Get invoice dunnings
         * @param {number} id Id of invoice of which you want to get the dunnings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDunnings(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetDunnings(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getFeed() in Invoice.php
         * @summary Get the feed of a specified invoice
         * @param {number} id Id of invoice of which you want to get the feed
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetFeed(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelFeed> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetFeed(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getFinalInvoiceId() in Invoice.php to get final invoice id of the invoice chain
         * @summary Get final invoice id
         * @param {number} id Id of the invoice of which you want to get the final invoice id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetFinalInvoiceId(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetFinalInvoiceId(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getIsPartiallyPaid() in Invoice.php
         * @summary Returns if the invoice is partially payed
         * @param {number} id Id of invoice of which you want to know if it is partially paid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetIsPartiallyPaid(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetIsPartiallyPaid(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getLastDunningDate() in Invoice.php to get the date of the last dunning of an invoice
         * @summary Get last dunning date of invoice as timestamp
         * @param {number} id Id of invoice of which you want to get the date of the last dunning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetLastDunningDate(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetLastDunningDate(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPartialInvoices() in Invoice.php to get partial invoices of the invoice
         * @summary Get partial invoices of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the partial invoices
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetPartialInvoices(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetPartialInvoices(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPositions() in Invoice.php
         * @summary Get the positions of a specified invoice
         * @param {number} id Id of invoice of which you want to get the positions
         * @param {number} [limit] limits the number of entries returned
         * @param {number} [offset] set the index where the returned entries start
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetPositions(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoicePos> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetPositions(id, limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getRelatedObjects() in Invoice.php to get related objects of the invoice
         * @summary Get related objects of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the related objects
         * @param {boolean} [includeItself] Define if the related objects include the invoice itself
         * @param {boolean} [sortByType] Define if you want the related objects sorted by type
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetRelatedObjects(id, includeItself, sortByType, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getSwissEsr() in Invoice.php to get the swiss esr
         * @summary Get swiss esr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetSwissEsr(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetSwissEsr(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getSwissEsrData() in Invoice.php to get the swiss esr data
         * @summary Get swiss esr data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetSwissEsrData(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetSwissEsrData(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTags() in Invoice.php
         * @summary Get the tags of a specified invoice
         * @param {number} id Id of invoice of which you want to get the tags
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTags(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTag> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetTags(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTax() in Invoice.php to get tax amount of invoice
         * @summary Get invoice tax amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the invoice tax amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumTax from invoice or sumTaxAccounting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTax(id: number, invoiceAmount?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetTax(id, invoiceAmount, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTaxGroupes() in Invoice.php to get tax groups
         * @summary Get tax groups of invoice
         * @param {number} id Id of invoice of which you want to get the tax groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTaxGroups(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetTaxGroups(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTotal() in Invoice.php to get gross amount of invoice
         * @summary Get gross invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the gross invoice amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumGross from invoice or sumGrossAccounting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotal(id: number, invoiceAmount?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetTotal(id, invoiceAmount, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTotalCalc() in Invoice.php to get tax groups
         * @summary Get total invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the invoice amount in invoice currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotalCalc(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetTotalCalc(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTotalNet() in Invoice.php to get total net amount of invoice
         * @summary Get total net invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the total net invoice amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumNet from invoice or sumNetAccounting
         * @param {boolean} [withoutDiscounts] Determines whether the total net is calculated with or without the discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotalNet(id: number, invoiceAmount?: boolean, withoutDiscounts?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceGetTotalNet(id, invoiceAmount, withoutDiscounts, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls hasDiscounts() in Invoice.php
         * @summary Returns if the specified invoice has discounts
         * @param {number} id Id of invoice of which you want to know if it has discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceHasDiscounts(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceHasDiscounts(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls isOrigin() in Invoice.php to find out if the invoice is the origin of an order
         * @summary Returns if the specified invoice is the origin of an order
         * @param {number} id Id of invoice of which you want to know if it is the origin of an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceIsOrigin(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceIsOrigin(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls markAsSent() in Invoice.php to mark an invoice as sent
         * @summary Marks an invoice as sent
         * @param {number} id Id of invoice which you want to mark as sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceMarkAsSent(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceMarkAsSent(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls refundAmmount() in Invoice.php to refund an invoice amount
         * @summary Refund an already payed invoice amount
         * @param {number} id Id of invoice of which you want to refund the amount
         * @param {number} ammount amount which should be refunded
         * @param {string} date booking date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceRefundAmount(id: number, ammount: number, date: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceRefundAmount(id, ammount, date, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls render() in Invoice.php to render invoice document on docserver and return the metadata
         * @summary Render invoice document on docserver and return metadata
         * @param {number} id Id of invoice of which you want to render the document and get the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceRender(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceRender(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendBy() in Invoice.php to send an invoice by the desired method
         * @summary Send invoice by desired method
         * @param {number} id Id of invoice which you want to send
         * @param {string} sendType desired send type, available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceSendBy(id: number, sendType: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).invoiceSendBy(id, sendType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create a new invoice (with / without invoice positions and discounts) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveInvoice(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoiceFactory> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).saveInvoice(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendViaEmail in Invoice.php
         * @summary Send an invoice via Email
         * @param {number} id id of invoice you want to send via Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoiceViaEmail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEmail> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).sendInvoiceViaEmail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendViaPost in Invoice.php
         * @summary Send an invoice via Letter
         * @param {number} id id of invoice you want to send via Letter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoiceViaPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).sendInvoiceViaPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Invoice.php
         * @summary Update an existing invoice
         * @param {number} id id of invoice you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoice> {
            const localVarFetchArgs = InvoiceApiFetchParamCreator(configuration).updateInvoice(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvoiceApi - factory interface
 * @export
 */
export const InvoiceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Invoice.php 
         * @summary Create a new invoice
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoice(options?: any) {
            return InvoiceApiFp(configuration).addInvoice(options)(fetch, basePath);
        },
        /**
         * Calls cancel() in Invoice.php to cancel an invoice and creates a cancellation invoice  
         * @summary Cancel an invoice
         * @param {number} id Id of invoice which you want to cancel
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        cancelInvoice(id: number, options?: any) {
            return InvoiceApiFp(configuration).cancelInvoice(id, options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create an new invoice from an existing order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceFromOrder(options?: any) {
            return InvoiceApiFp(configuration).createInvoiceFromOrder(options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create an invoice reminder
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        createInvoiceReminder(options?: any) {
            return InvoiceApiFp(configuration).createInvoiceReminder(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Invoice.php
         * @summary Delete an existing invoice
         * @param {number} id id of invoice you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoice(id: number, options?: any) {
            return InvoiceApiFp(configuration).deleteInvoice(id, options)(fetch, basePath);
        },
        /**
         * Calls duplicate() in Invoice.php to duplicate an existing invoice
         * @summary Duplicate an existing invoice
         * @param {number} id id of invoice you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateInvoice(id: number, options?: any) {
            return InvoiceApiFp(configuration).duplicateInvoice(id, options)(fetch, basePath);
        },
        /**
         * Calls the getTotalInvoiceReminderAndInvoiceAmount function in /Invoice/Factory/ to get the amount of the invoice including its reminders.
         * @summary Get amount of an invoice including reminders
         * @param {number} invoiceId id of the invoice you want to get the total amount for
         * @param {string} invoiceObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAndReminderAmount(invoiceId: number, invoiceObjectName: string, options?: any) {
            return InvoiceApiFp(configuration).getInvoiceAndReminderAmount(invoiceId, invoiceObjectName, options)(fetch, basePath);
        },
        /**
         * Calls getPdf in Invoice.php
         * @summary Get the invoice as a PDF
         * @param {number} id Id of invoice of which you want to get the PDF
         * @param {boolean} download If true PDF will return as filestream otherwise as json object the content base64 encoded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceAsPdf(id: number, download: boolean, options?: any) {
            return InvoiceApiFp(configuration).getInvoiceAsPdf(id, download, options)(fetch, basePath);
        },
        /**
         * Calls the getTotalInvoiceReminderAmount function in /Invoice/Factory/ to get the amount of all reminders of an invoice.
         * @summary Get (monetary) amount of all reminders of an invoice
         * @param {number} invoiceId id of the invoice you want to get the reminder amount for
         * @param {string} invoiceObjectName 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceReminderAmount(invoiceId: number, invoiceObjectName: string, options?: any) {
            return InvoiceApiFp(configuration).getInvoiceReminderAmount(invoiceId, invoiceObjectName, options)(fetch, basePath);
        },
        /**
         * Calls Invoice.php to get necessary variables. However, not all variables get their value from Invoice.php directly but from other models like Model_InvoicePos or Model_Part
         * @summary Get an overview of all invoices
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoices start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoices(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).getInvoices(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the next invoice number
         * @param {string} invoiceType defines the type of invoice you want to get the next number from
         * @param {boolean} useNextNumber By default this is true, so the invoiceNumber will increase by one otherwise the invoiceNumber will not change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextInvoiceNumber(invoiceType: string, useNextNumber: boolean, options?: any) {
            return InvoiceApiFp(configuration).getNextInvoiceNumber(invoiceType, useNextNumber, options)(fetch, basePath);
        },
        /**
         * Calls addPosition() in Invoice.php to add a position to an invoice.    This function is not required anymore as there is a function for creating Invoices in Invoice/Factory which includes adding the position.
         * @summary Add a position to an existing invoice
         * @param {number} id id of invoice you want to add a position to
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceAddPosition(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceAddPosition(id, options)(fetch, basePath);
        },
        /**
         * Calls bookAmmount() in Invoice.php to book an invoice amount
         * @summary Book amount for an invoice
         * @param {number} id Id of invoice of which you want to book an amount
         * @param {number} ammount amount which should be booked
         * @param {string} date booking date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceBookAmount(id: number, ammount: number, date: string, options?: any) {
            return InvoiceApiFp(configuration).invoiceBookAmount(id, ammount, date, options)(fetch, basePath);
        },
        /**
         * Calls calcTotalDebit() in Invoice.php to calculate total sum of all invoices of current query
         * @summary Calculate total sum of all invoices of current query
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCalcTotalDebit(options?: any) {
            return InvoiceApiFp(configuration).invoiceCalcTotalDebit(options)(fetch, basePath);
        },
        /**
         * Calls calculateDunningLevel() in Invoice.php to get the dunning level of an invoice
         * @summary Get dunning level of an invoice
         * @param {number} id Id of invoice of which you want to get the dunning level
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceCalculateDunningLevel(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceCalculateDunningLevel(id, options)(fetch, basePath);
        },
        /**
         * Calls changeStatus() in Invoice.php to book an invoice amount
         * @summary Change status of an invoice
         * @param {number} id Id of invoice of which you want to book an amount
         * @param {number} value desired status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceChangeStatus(id: number, value: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceChangeStatus(id, value, options)(fetch, basePath);
        },
        /**
         * Calls getCancled() in Invoice.php to know if an invoice is cancled
         * @summary Returns if an invoice is cancled
         * @param {number} id Id of invoice of which you want to know if it is cancled
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCancled(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetCancled(id, options)(fetch, basePath);
        },
        /**
         * Calls getCheckAccountTransactionLogs() in Invoice.php to get check account transaction logs about the invoice
         * @summary Get check account transaction logs about a specified invoice
         * @param {number} id Id of the invoice of which you want to get the check account transaction logs
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetCheckAccountTransactionLogs(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getCheckAccountTransactions() in Invoice.php to get check account transactions of the invoice
         * @summary Get check account transactions of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the check account transactions
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetCheckAccountTransactions(id: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetCheckAccountTransactions(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getDebit() in Invoice.php to get debit of an invoice
         * @summary Get debit of an invoice
         * @param {number} id Id of invoice of which you want to get the debit
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDebit(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetDebit(id, options)(fetch, basePath);
        },
        /**
         * Calls getDelinquent() in Invoice.php to get if an invoice is delinquent
         * @summary Get if an invoice is delinquent
         * @param {number} id Id of invoice of which you want to know if its delinquent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDelinquent(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetDelinquent(id, options)(fetch, basePath);
        },
        /**
         * Calls getDiscounts() in Invoice.php
         * @summary Get the discounts of a specified invoice
         * @param {number} id Id of invoice of which you want to get the discounts
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDiscounts(id: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetDiscounts(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getDocument() in Invoice.php to get the document of an invoice
         * @summary Get document of an invoice
         * @param {number} id Id of invoice of which you want to get the document
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDocument(id: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetDocument(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getDunnings() in Invoice.php to get the dunnings of an invoice
         * @summary Get invoice dunnings
         * @param {number} id Id of invoice of which you want to get the dunnings
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetDunnings(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetDunnings(id, options)(fetch, basePath);
        },
        /**
         * Calls getFeed() in Invoice.php
         * @summary Get the feed of a specified invoice
         * @param {number} id Id of invoice of which you want to get the feed
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetFeed(id: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetFeed(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getFinalInvoiceId() in Invoice.php to get final invoice id of the invoice chain
         * @summary Get final invoice id
         * @param {number} id Id of the invoice of which you want to get the final invoice id
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetFinalInvoiceId(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetFinalInvoiceId(id, options)(fetch, basePath);
        },
        /**
         * Calls getIsPartiallyPaid() in Invoice.php
         * @summary Returns if the invoice is partially payed
         * @param {number} id Id of invoice of which you want to know if it is partially paid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetIsPartiallyPaid(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetIsPartiallyPaid(id, options)(fetch, basePath);
        },
        /**
         * Calls getLastDunningDate() in Invoice.php to get the date of the last dunning of an invoice
         * @summary Get last dunning date of invoice as timestamp
         * @param {number} id Id of invoice of which you want to get the date of the last dunning
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetLastDunningDate(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetLastDunningDate(id, options)(fetch, basePath);
        },
        /**
         * Calls getPartialInvoices() in Invoice.php to get partial invoices of the invoice
         * @summary Get partial invoices of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the partial invoices
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetPartialInvoices(id: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetPartialInvoices(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getPositions() in Invoice.php
         * @summary Get the positions of a specified invoice
         * @param {number} id Id of invoice of which you want to get the positions
         * @param {number} [limit] limits the number of entries returned
         * @param {number} [offset] set the index where the returned entries start
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetPositions(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetPositions(id, limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getRelatedObjects() in Invoice.php to get related objects of the invoice
         * @summary Get related objects of a specified invoice
         * @param {number} id Id of the invoice of which you want to get the related objects
         * @param {boolean} [includeItself] Define if the related objects include the invoice itself
         * @param {boolean} [sortByType] Define if you want the related objects sorted by type
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetRelatedObjects(id, includeItself, sortByType, embed, options)(fetch, basePath);
        },
        /**
         * Calls getSwissEsr() in Invoice.php to get the swiss esr
         * @summary Get swiss esr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetSwissEsr(options?: any) {
            return InvoiceApiFp(configuration).invoiceGetSwissEsr(options)(fetch, basePath);
        },
        /**
         * Calls getSwissEsrData() in Invoice.php to get the swiss esr data
         * @summary Get swiss esr data
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetSwissEsrData(options?: any) {
            return InvoiceApiFp(configuration).invoiceGetSwissEsrData(options)(fetch, basePath);
        },
        /**
         * Calls getTags() in Invoice.php
         * @summary Get the tags of a specified invoice
         * @param {number} id Id of invoice of which you want to get the tags
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTags(id: number, embed?: Array<string>, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetTags(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getTax() in Invoice.php to get tax amount of invoice
         * @summary Get invoice tax amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the invoice tax amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumTax from invoice or sumTaxAccounting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTax(id: number, invoiceAmount?: boolean, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetTax(id, invoiceAmount, options)(fetch, basePath);
        },
        /**
         * Calls getTaxGroupes() in Invoice.php to get tax groups
         * @summary Get tax groups of invoice
         * @param {number} id Id of invoice of which you want to get the tax groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTaxGroups(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetTaxGroups(id, options)(fetch, basePath);
        },
        /**
         * Calls getTotal() in Invoice.php to get gross amount of invoice
         * @summary Get gross invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the gross invoice amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumGross from invoice or sumGrossAccounting
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotal(id: number, invoiceAmount?: boolean, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetTotal(id, invoiceAmount, options)(fetch, basePath);
        },
        /**
         * Calls getTotalCalc() in Invoice.php to get tax groups
         * @summary Get total invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the invoice amount in invoice currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotalCalc(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetTotalCalc(id, options)(fetch, basePath);
        },
        /**
         * Calls getTotalNet() in Invoice.php to get total net amount of invoice
         * @summary Get total net invoice amount in invoice currency
         * @param {number} id Id of invoice of which you want to get the total net invoice amount
         * @param {boolean} [invoiceAmount] Determines whether to use sumNet from invoice or sumNetAccounting
         * @param {boolean} [withoutDiscounts] Determines whether the total net is calculated with or without the discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceGetTotalNet(id: number, invoiceAmount?: boolean, withoutDiscounts?: boolean, options?: any) {
            return InvoiceApiFp(configuration).invoiceGetTotalNet(id, invoiceAmount, withoutDiscounts, options)(fetch, basePath);
        },
        /**
         * Calls hasDiscounts() in Invoice.php
         * @summary Returns if the specified invoice has discounts
         * @param {number} id Id of invoice of which you want to know if it has discounts
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceHasDiscounts(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceHasDiscounts(id, options)(fetch, basePath);
        },
        /**
         * Calls isOrigin() in Invoice.php to find out if the invoice is the origin of an order
         * @summary Returns if the specified invoice is the origin of an order
         * @param {number} id Id of invoice of which you want to know if it is the origin of an order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceIsOrigin(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceIsOrigin(id, options)(fetch, basePath);
        },
        /**
         * Calls markAsSent() in Invoice.php to mark an invoice as sent
         * @summary Marks an invoice as sent
         * @param {number} id Id of invoice which you want to mark as sent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceMarkAsSent(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceMarkAsSent(id, options)(fetch, basePath);
        },
        /**
         * Calls refundAmmount() in Invoice.php to refund an invoice amount
         * @summary Refund an already payed invoice amount
         * @param {number} id Id of invoice of which you want to refund the amount
         * @param {number} ammount amount which should be refunded
         * @param {string} date booking date
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceRefundAmount(id: number, ammount: number, date: string, options?: any) {
            return InvoiceApiFp(configuration).invoiceRefundAmount(id, ammount, date, options)(fetch, basePath);
        },
        /**
         * Calls render() in Invoice.php to render invoice document on docserver and return the metadata
         * @summary Render invoice document on docserver and return metadata
         * @param {number} id Id of invoice of which you want to render the document and get the metadata
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceRender(id: number, options?: any) {
            return InvoiceApiFp(configuration).invoiceRender(id, options)(fetch, basePath);
        },
        /**
         * Calls sendBy() in Invoice.php to send an invoice by the desired method
         * @summary Send invoice by desired method
         * @param {number} id Id of invoice which you want to send
         * @param {string} sendType desired send type, available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        invoiceSendBy(id: number, sendType: string, options?: any) {
            return InvoiceApiFp(configuration).invoiceSendBy(id, sendType, options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
         * @summary Create a new invoice (with / without invoice positions and discounts) 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveInvoice(options?: any) {
            return InvoiceApiFp(configuration).saveInvoice(options)(fetch, basePath);
        },
        /**
         * Calls sendViaEmail in Invoice.php
         * @summary Send an invoice via Email
         * @param {number} id id of invoice you want to send via Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoiceViaEmail(id: number, options?: any) {
            return InvoiceApiFp(configuration).sendInvoiceViaEmail(id, options)(fetch, basePath);
        },
        /**
         * Calls sendViaPost in Invoice.php
         * @summary Send an invoice via Letter
         * @param {number} id id of invoice you want to send via Letter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendInvoiceViaPost(id: number, options?: any) {
            return InvoiceApiFp(configuration).sendInvoiceViaPost(id, options)(fetch, basePath);
        },
        /**
         * Calls Invoice.php
         * @summary Update an existing invoice
         * @param {number} id id of invoice you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoice(id: number, options?: any) {
            return InvoiceApiFp(configuration).updateInvoice(id, options)(fetch, basePath);
        },
    };
};

/**
 * InvoiceApi - object-oriented interface
 * @export
 * @class InvoiceApi
 * @extends {BaseAPI}
 */
export class InvoiceApi extends BaseAPI {
    /**
     * Calls Invoice.php 
     * @summary Create a new invoice
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public addInvoice(options?: any) {
        return InvoiceApiFp(this.configuration).addInvoice(options)(this.fetch, this.basePath);
    }

    /**
     * Calls cancel() in Invoice.php to cancel an invoice and creates a cancellation invoice  
     * @summary Cancel an invoice
     * @param {number} id Id of invoice which you want to cancel
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public cancelInvoice(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).cancelInvoice(id, options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
     * @summary Create an new invoice from an existing order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInvoiceFromOrder(options?: any) {
        return InvoiceApiFp(this.configuration).createInvoiceFromOrder(options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the Model.php itself still constructs the model however new instances of the model are created trough the Factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
     * @summary Create an invoice reminder
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public createInvoiceReminder(options?: any) {
        return InvoiceApiFp(this.configuration).createInvoiceReminder(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Invoice.php
     * @summary Delete an existing invoice
     * @param {number} id id of invoice you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public deleteInvoice(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).deleteInvoice(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls duplicate() in Invoice.php to duplicate an existing invoice
     * @summary Duplicate an existing invoice
     * @param {number} id id of invoice you want to duplicate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public duplicateInvoice(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).duplicateInvoice(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the getTotalInvoiceReminderAndInvoiceAmount function in /Invoice/Factory/ to get the amount of the invoice including its reminders.
     * @summary Get amount of an invoice including reminders
     * @param {number} invoiceId id of the invoice you want to get the total amount for
     * @param {string} invoiceObjectName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceAndReminderAmount(invoiceId: number, invoiceObjectName: string, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceAndReminderAmount(invoiceId, invoiceObjectName, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPdf in Invoice.php
     * @summary Get the invoice as a PDF
     * @param {number} id Id of invoice of which you want to get the PDF
     * @param {boolean} download If true PDF will return as filestream otherwise as json object the content base64 encoded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceAsPdf(id: number, download: boolean, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceAsPdf(id, download, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the getTotalInvoiceReminderAmount function in /Invoice/Factory/ to get the amount of all reminders of an invoice.
     * @summary Get (monetary) amount of all reminders of an invoice
     * @param {number} invoiceId id of the invoice you want to get the reminder amount for
     * @param {string} invoiceObjectName 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoiceReminderAmount(invoiceId: number, invoiceObjectName: string, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoiceReminderAmount(invoiceId, invoiceObjectName, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Invoice.php to get necessary variables. However, not all variables get their value from Invoice.php directly but from other models like Model_InvoicePos or Model_Part
     * @summary Get an overview of all invoices
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned invoices start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getInvoices(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).getInvoices(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the next invoice number
     * @param {string} invoiceType defines the type of invoice you want to get the next number from
     * @param {boolean} useNextNumber By default this is true, so the invoiceNumber will increase by one otherwise the invoiceNumber will not change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public getNextInvoiceNumber(invoiceType: string, useNextNumber: boolean, options?: any) {
        return InvoiceApiFp(this.configuration).getNextInvoiceNumber(invoiceType, useNextNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Calls addPosition() in Invoice.php to add a position to an invoice.    This function is not required anymore as there is a function for creating Invoices in Invoice/Factory which includes adding the position.
     * @summary Add a position to an existing invoice
     * @param {number} id id of invoice you want to add a position to
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceAddPosition(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceAddPosition(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls bookAmmount() in Invoice.php to book an invoice amount
     * @summary Book amount for an invoice
     * @param {number} id Id of invoice of which you want to book an amount
     * @param {number} ammount amount which should be booked
     * @param {string} date booking date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceBookAmount(id: number, ammount: number, date: string, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceBookAmount(id, ammount, date, options)(this.fetch, this.basePath);
    }

    /**
     * Calls calcTotalDebit() in Invoice.php to calculate total sum of all invoices of current query
     * @summary Calculate total sum of all invoices of current query
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceCalcTotalDebit(options?: any) {
        return InvoiceApiFp(this.configuration).invoiceCalcTotalDebit(options)(this.fetch, this.basePath);
    }

    /**
     * Calls calculateDunningLevel() in Invoice.php to get the dunning level of an invoice
     * @summary Get dunning level of an invoice
     * @param {number} id Id of invoice of which you want to get the dunning level
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceCalculateDunningLevel(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceCalculateDunningLevel(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls changeStatus() in Invoice.php to book an invoice amount
     * @summary Change status of an invoice
     * @param {number} id Id of invoice of which you want to book an amount
     * @param {number} value desired status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceChangeStatus(id: number, value: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceChangeStatus(id, value, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCancled() in Invoice.php to know if an invoice is cancled
     * @summary Returns if an invoice is cancled
     * @param {number} id Id of invoice of which you want to know if it is cancled
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetCancled(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetCancled(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCheckAccountTransactionLogs() in Invoice.php to get check account transaction logs about the invoice
     * @summary Get check account transaction logs about a specified invoice
     * @param {number} id Id of the invoice of which you want to get the check account transaction logs
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetCheckAccountTransactionLogs(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCheckAccountTransactions() in Invoice.php to get check account transactions of the invoice
     * @summary Get check account transactions of a specified invoice
     * @param {number} id Id of the invoice of which you want to get the check account transactions
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetCheckAccountTransactions(id: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetCheckAccountTransactions(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDebit() in Invoice.php to get debit of an invoice
     * @summary Get debit of an invoice
     * @param {number} id Id of invoice of which you want to get the debit
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetDebit(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetDebit(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDelinquent() in Invoice.php to get if an invoice is delinquent
     * @summary Get if an invoice is delinquent
     * @param {number} id Id of invoice of which you want to know if its delinquent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetDelinquent(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetDelinquent(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDiscounts() in Invoice.php
     * @summary Get the discounts of a specified invoice
     * @param {number} id Id of invoice of which you want to get the discounts
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetDiscounts(id: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetDiscounts(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDocument() in Invoice.php to get the document of an invoice
     * @summary Get document of an invoice
     * @param {number} id Id of invoice of which you want to get the document
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetDocument(id: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetDocument(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDunnings() in Invoice.php to get the dunnings of an invoice
     * @summary Get invoice dunnings
     * @param {number} id Id of invoice of which you want to get the dunnings
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetDunnings(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetDunnings(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getFeed() in Invoice.php
     * @summary Get the feed of a specified invoice
     * @param {number} id Id of invoice of which you want to get the feed
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetFeed(id: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetFeed(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getFinalInvoiceId() in Invoice.php to get final invoice id of the invoice chain
     * @summary Get final invoice id
     * @param {number} id Id of the invoice of which you want to get the final invoice id
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetFinalInvoiceId(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetFinalInvoiceId(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getIsPartiallyPaid() in Invoice.php
     * @summary Returns if the invoice is partially payed
     * @param {number} id Id of invoice of which you want to know if it is partially paid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetIsPartiallyPaid(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetIsPartiallyPaid(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getLastDunningDate() in Invoice.php to get the date of the last dunning of an invoice
     * @summary Get last dunning date of invoice as timestamp
     * @param {number} id Id of invoice of which you want to get the date of the last dunning
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetLastDunningDate(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetLastDunningDate(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPartialInvoices() in Invoice.php to get partial invoices of the invoice
     * @summary Get partial invoices of a specified invoice
     * @param {number} id Id of the invoice of which you want to get the partial invoices
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetPartialInvoices(id: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetPartialInvoices(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPositions() in Invoice.php
     * @summary Get the positions of a specified invoice
     * @param {number} id Id of invoice of which you want to get the positions
     * @param {number} [limit] limits the number of entries returned
     * @param {number} [offset] set the index where the returned entries start
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetPositions(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetPositions(id, limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getRelatedObjects() in Invoice.php to get related objects of the invoice
     * @summary Get related objects of a specified invoice
     * @param {number} id Id of the invoice of which you want to get the related objects
     * @param {boolean} [includeItself] Define if the related objects include the invoice itself
     * @param {boolean} [sortByType] Define if you want the related objects sorted by type
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetRelatedObjects(id, includeItself, sortByType, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getSwissEsr() in Invoice.php to get the swiss esr
     * @summary Get swiss esr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetSwissEsr(options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetSwissEsr(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getSwissEsrData() in Invoice.php to get the swiss esr data
     * @summary Get swiss esr data
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetSwissEsrData(options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetSwissEsrData(options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTags() in Invoice.php
     * @summary Get the tags of a specified invoice
     * @param {number} id Id of invoice of which you want to get the tags
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetTags(id: number, embed?: Array<string>, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetTags(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTax() in Invoice.php to get tax amount of invoice
     * @summary Get invoice tax amount in invoice currency
     * @param {number} id Id of invoice of which you want to get the invoice tax amount
     * @param {boolean} [invoiceAmount] Determines whether to use sumTax from invoice or sumTaxAccounting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetTax(id: number, invoiceAmount?: boolean, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetTax(id, invoiceAmount, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTaxGroupes() in Invoice.php to get tax groups
     * @summary Get tax groups of invoice
     * @param {number} id Id of invoice of which you want to get the tax groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetTaxGroups(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetTaxGroups(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTotal() in Invoice.php to get gross amount of invoice
     * @summary Get gross invoice amount in invoice currency
     * @param {number} id Id of invoice of which you want to get the gross invoice amount
     * @param {boolean} [invoiceAmount] Determines whether to use sumGross from invoice or sumGrossAccounting
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetTotal(id: number, invoiceAmount?: boolean, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetTotal(id, invoiceAmount, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTotalCalc() in Invoice.php to get tax groups
     * @summary Get total invoice amount in invoice currency
     * @param {number} id Id of invoice of which you want to get the invoice amount in invoice currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetTotalCalc(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetTotalCalc(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTotalNet() in Invoice.php to get total net amount of invoice
     * @summary Get total net invoice amount in invoice currency
     * @param {number} id Id of invoice of which you want to get the total net invoice amount
     * @param {boolean} [invoiceAmount] Determines whether to use sumNet from invoice or sumNetAccounting
     * @param {boolean} [withoutDiscounts] Determines whether the total net is calculated with or without the discounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceGetTotalNet(id: number, invoiceAmount?: boolean, withoutDiscounts?: boolean, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceGetTotalNet(id, invoiceAmount, withoutDiscounts, options)(this.fetch, this.basePath);
    }

    /**
     * Calls hasDiscounts() in Invoice.php
     * @summary Returns if the specified invoice has discounts
     * @param {number} id Id of invoice of which you want to know if it has discounts
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceHasDiscounts(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceHasDiscounts(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls isOrigin() in Invoice.php to find out if the invoice is the origin of an order
     * @summary Returns if the specified invoice is the origin of an order
     * @param {number} id Id of invoice of which you want to know if it is the origin of an order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceIsOrigin(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceIsOrigin(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls markAsSent() in Invoice.php to mark an invoice as sent
     * @summary Marks an invoice as sent
     * @param {number} id Id of invoice which you want to mark as sent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceMarkAsSent(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceMarkAsSent(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls refundAmmount() in Invoice.php to refund an invoice amount
     * @summary Refund an already payed invoice amount
     * @param {number} id Id of invoice of which you want to refund the amount
     * @param {number} ammount amount which should be refunded
     * @param {string} date booking date
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceRefundAmount(id: number, ammount: number, date: string, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceRefundAmount(id, ammount, date, options)(this.fetch, this.basePath);
    }

    /**
     * Calls render() in Invoice.php to render invoice document on docserver and return the metadata
     * @summary Render invoice document on docserver and return metadata
     * @param {number} id Id of invoice of which you want to render the document and get the metadata
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceRender(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceRender(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendBy() in Invoice.php to send an invoice by the desired method
     * @summary Send invoice by desired method
     * @param {number} id Id of invoice which you want to send
     * @param {string} sendType desired send type, available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public invoiceSendBy(id: number, sendType: string, options?: any) {
        return InvoiceApiFp(this.configuration).invoiceSendBy(id, sendType, options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the model.php directly but by calling the factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new invoice it wont be saved by a POST request with '/Invoice?para1=&...' but with the saveInvoice function in Factory.php 'Voucher/Factory/saveInvoice?para1='
     * @summary Create a new invoice (with / without invoice positions and discounts) 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public saveInvoice(options?: any) {
        return InvoiceApiFp(this.configuration).saveInvoice(options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendViaEmail in Invoice.php
     * @summary Send an invoice via Email
     * @param {number} id id of invoice you want to send via Email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public sendInvoiceViaEmail(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).sendInvoiceViaEmail(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendViaPost in Invoice.php
     * @summary Send an invoice via Letter
     * @param {number} id id of invoice you want to send via Letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public sendInvoiceViaPost(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).sendInvoiceViaPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Invoice.php
     * @summary Update an existing invoice
     * @param {number} id id of invoice you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceApi
     */
    public updateInvoice(id: number, options?: any) {
        return InvoiceApiFp(this.configuration).updateInvoice(id, options)(this.fetch, this.basePath);
    }

}
/**
 * InvoiceLogApi - fetch parameter creator
 * @export
 */
export const InvoiceLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls InvoiceLog.php
         * @summary Create a new invoice log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoiceLog(options: any = {}): FetchArgs {
            const localVarPath = `/InvoiceLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in InvoiceLog.php
         * @summary Delete an existing invoice log
         * @param {number} id Id of invoice log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteInvoiceLog.');
            }
            const localVarPath = `/InvoiceLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls InvoiceLog.php to get necessary variables
         * @summary Get an overview of invoice logs
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceLogs(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/InvoiceLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls InvoiceLog.php
         * @summary Update an existing invoice log
         * @param {number} id Id of invoice log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateInvoiceLog.');
            }
            const localVarPath = `/InvoiceLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoiceLogApi - functional programming interface
 * @export
 */
export const InvoiceLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls InvoiceLog.php
         * @summary Create a new invoice log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoiceLog(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoiceLog> {
            const localVarFetchArgs = InvoiceLogApiFetchParamCreator(configuration).addInvoiceLog(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in InvoiceLog.php
         * @summary Delete an existing invoice log
         * @param {number} id Id of invoice log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoiceLogApiFetchParamCreator(configuration).deleteInvoiceLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls InvoiceLog.php to get necessary variables
         * @summary Get an overview of invoice logs
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceLogs(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoiceLog> {
            const localVarFetchArgs = InvoiceLogApiFetchParamCreator(configuration).getInvoiceLogs(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls InvoiceLog.php
         * @summary Update an existing invoice log
         * @param {number} id Id of invoice log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoiceLog> {
            const localVarFetchArgs = InvoiceLogApiFetchParamCreator(configuration).updateInvoiceLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvoiceLogApi - factory interface
 * @export
 */
export const InvoiceLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls InvoiceLog.php
         * @summary Create a new invoice log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoiceLog(options?: any) {
            return InvoiceLogApiFp(configuration).addInvoiceLog(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in InvoiceLog.php
         * @summary Delete an existing invoice log
         * @param {number} id Id of invoice log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoiceLog(id: number, options?: any) {
            return InvoiceLogApiFp(configuration).deleteInvoiceLog(id, options)(fetch, basePath);
        },
        /**
         * Calls InvoiceLog.php to get necessary variables
         * @summary Get an overview of invoice logs
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoiceLogs(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return InvoiceLogApiFp(configuration).getInvoiceLogs(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls InvoiceLog.php
         * @summary Update an existing invoice log
         * @param {number} id Id of invoice log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoiceLog(id: number, options?: any) {
            return InvoiceLogApiFp(configuration).updateInvoiceLog(id, options)(fetch, basePath);
        },
    };
};

/**
 * InvoiceLogApi - object-oriented interface
 * @export
 * @class InvoiceLogApi
 * @extends {BaseAPI}
 */
export class InvoiceLogApi extends BaseAPI {
    /**
     * Calls InvoiceLog.php
     * @summary Create a new invoice log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceLogApi
     */
    public addInvoiceLog(options?: any) {
        return InvoiceLogApiFp(this.configuration).addInvoiceLog(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in InvoiceLog.php
     * @summary Delete an existing invoice log
     * @param {number} id Id of invoice log you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceLogApi
     */
    public deleteInvoiceLog(id: number, options?: any) {
        return InvoiceLogApiFp(this.configuration).deleteInvoiceLog(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls InvoiceLog.php to get necessary variables
     * @summary Get an overview of invoice logs
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned invoice logs start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceLogApi
     */
    public getInvoiceLogs(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return InvoiceLogApiFp(this.configuration).getInvoiceLogs(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls InvoiceLog.php
     * @summary Update an existing invoice log
     * @param {number} id Id of invoice log you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoiceLogApi
     */
    public updateInvoiceLog(id: number, options?: any) {
        return InvoiceLogApiFp(this.configuration).updateInvoiceLog(id, options)(this.fetch, this.basePath);
    }

}
/**
 * InvoicePosApi - fetch parameter creator
 * @export
 */
export const InvoicePosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls InvoicePos.php.    As described in the Model_Invoice earlier, some of its parameters get their value from other models/functions.    InvoicePos is one of those Models and provides the ability to add products/parts to your invoice which fills values like sumNet,taxation, etc.
         * @summary Create a new invoice position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoicePos(options: any = {}): FetchArgs {
            const localVarPath = `/InvoicePos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in InvoicePos.php. This does NOT delete an invoice, just the position which belonged to the invoice!
         * @summary Delete an existing invoice position
         * @param {number} id id of invoice position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePos(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteInvoicePos.');
            }
            const localVarPath = `/InvoicePos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls InvoicePos.php to get necessary variables.
         * @summary Get an overview of all invoice positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePositions(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/InvoicePos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing invoice position
         * @param {number} id id of invoice position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoicePos(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateInvoicePos.');
            }
            const localVarPath = `/InvoicePos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * InvoicePosApi - functional programming interface
 * @export
 */
export const InvoicePosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls InvoicePos.php.    As described in the Model_Invoice earlier, some of its parameters get their value from other models/functions.    InvoicePos is one of those Models and provides the ability to add products/parts to your invoice which fills values like sumNet,taxation, etc.
         * @summary Create a new invoice position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoicePos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoicePos> {
            const localVarFetchArgs = InvoicePosApiFetchParamCreator(configuration).addInvoicePos(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in InvoicePos.php. This does NOT delete an invoice, just the position which belonged to the invoice!
         * @summary Delete an existing invoice position
         * @param {number} id id of invoice position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePos(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = InvoicePosApiFetchParamCreator(configuration).deleteInvoicePos(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls InvoicePos.php to get necessary variables.
         * @summary Get an overview of all invoice positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePositions(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoicePos> {
            const localVarFetchArgs = InvoicePosApiFetchParamCreator(configuration).getInvoicePositions(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing invoice position
         * @param {number} id id of invoice position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoicePos(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInvoicePos> {
            const localVarFetchArgs = InvoicePosApiFetchParamCreator(configuration).updateInvoicePos(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * InvoicePosApi - factory interface
 * @export
 */
export const InvoicePosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls InvoicePos.php.    As described in the Model_Invoice earlier, some of its parameters get their value from other models/functions.    InvoicePos is one of those Models and provides the ability to add products/parts to your invoice which fills values like sumNet,taxation, etc.
         * @summary Create a new invoice position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addInvoicePos(options?: any) {
            return InvoicePosApiFp(configuration).addInvoicePos(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in InvoicePos.php. This does NOT delete an invoice, just the position which belonged to the invoice!
         * @summary Delete an existing invoice position
         * @param {number} id id of invoice position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteInvoicePos(id: number, options?: any) {
            return InvoicePosApiFp(configuration).deleteInvoicePos(id, options)(fetch, basePath);
        },
        /**
         * Calls InvoicePos.php to get necessary variables.
         * @summary Get an overview of all invoice positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getInvoicePositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return InvoicePosApiFp(configuration).getInvoicePositions(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing invoice position
         * @param {number} id id of invoice position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateInvoicePos(id: number, options?: any) {
            return InvoicePosApiFp(configuration).updateInvoicePos(id, options)(fetch, basePath);
        },
    };
};

/**
 * InvoicePosApi - object-oriented interface
 * @export
 * @class InvoicePosApi
 * @extends {BaseAPI}
 */
export class InvoicePosApi extends BaseAPI {
    /**
     * Calls InvoicePos.php.    As described in the Model_Invoice earlier, some of its parameters get their value from other models/functions.    InvoicePos is one of those Models and provides the ability to add products/parts to your invoice which fills values like sumNet,taxation, etc.
     * @summary Create a new invoice position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePosApi
     */
    public addInvoicePos(options?: any) {
        return InvoicePosApiFp(this.configuration).addInvoicePos(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in InvoicePos.php. This does NOT delete an invoice, just the position which belonged to the invoice!
     * @summary Delete an existing invoice position
     * @param {number} id id of invoice position you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePosApi
     */
    public deleteInvoicePos(id: number, options?: any) {
        return InvoicePosApiFp(this.configuration).deleteInvoicePos(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls InvoicePos.php to get necessary variables.
     * @summary Get an overview of all invoice positions
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePosApi
     */
    public getInvoicePositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return InvoicePosApiFp(this.configuration).getInvoicePositions(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * TODO: Enter short backend documentation here
     * @summary Update an existing invoice position
     * @param {number} id id of invoice position you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof InvoicePosApi
     */
    public updateInvoicePos(id: number, options?: any) {
        return InvoicePosApiFp(this.configuration).updateInvoicePos(id, options)(this.fetch, this.basePath);
    }

}
/**
 * LetterApi - fetch parameter creator
 * @export
 */
export const LetterApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Letter.php
         * @summary Create a new letter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLetter(options: any = {}): FetchArgs {
            const localVarPath = `/Letter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Letter.php
         * @summary Delete an existing letter
         * @param {number} id id of letter you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLetter(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteLetter.');
            }
            const localVarPath = `/Letter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Letter.php to get necessary variables
         * @summary Get an overview of all letters
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned letters start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLetters(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Letter`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPdf() in Letter.php to get the pdf of a specified letter from the docserver
         * @summary Get pdf from docserver
         * @param {number} id Id of the letter of which you want to get the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterGetPdf(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling letterGetPdf.');
            }
            const localVarPath = `/Letter/{id}/getPdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls render() in Letter.php to render a letter to the docserver and return the metadata.    Note that this does not work for letters created by calling the api directly (eg. over Swagger)!
         * @summary Render a letter to the docserver and return the metadata
         * @param {number} id id of letter you want to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterRender(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling letterRender.');
            }
            const localVarPath = `/Letter/{id}/render`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendBy() in Letter.php to update the sendType parameter of the letter and change its status to DELIVERED
         * @summary Update parameter sendType
         * @param {number} id id of letter of which you want to update the sendType parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendBy(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling letterSendBy.');
            }
            const localVarPath = `/Letter/{id}/sendBy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendViaMail() in Letter.php to send a letter via mail.    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
         * @summary Send a letter via mail
         * @param {number} id id of letter you want to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendViaMail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling letterSendViaMail.');
            }
            const localVarPath = `/Letter/{id}/sendViaEmail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendViaPost() in Letter.php to send a letter via post if enabled in your subscription    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
         * @summary Send a letter via post
         * @param {number} id id of letter you want to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendViaPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling letterSendViaPost.');
            }
            const localVarPath = `/Letter/{id}/sendViaPost`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Letter.php
         * @summary Update an existing letter
         * @param {number} id id of letter you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLetter(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateLetter.');
            }
            const localVarPath = `/Letter/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * LetterApi - functional programming interface
 * @export
 */
export const LetterApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Letter.php
         * @summary Create a new letter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLetter(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelLetter> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).addLetter(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Letter.php
         * @summary Delete an existing letter
         * @param {number} id id of letter you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLetter(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).deleteLetter(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Letter.php to get necessary variables
         * @summary Get an overview of all letters
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned letters start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLetters(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelLetter> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).getLetters(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPdf() in Letter.php to get the pdf of a specified letter from the docserver
         * @summary Get pdf from docserver
         * @param {number} id Id of the letter of which you want to get the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterGetPdf(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).letterGetPdf(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls render() in Letter.php to render a letter to the docserver and return the metadata.    Note that this does not work for letters created by calling the api directly (eg. over Swagger)!
         * @summary Render a letter to the docserver and return the metadata
         * @param {number} id id of letter you want to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterRender(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).letterRender(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendBy() in Letter.php to update the sendType parameter of the letter and change its status to DELIVERED
         * @summary Update parameter sendType
         * @param {number} id id of letter of which you want to update the sendType parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendBy(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelLetter> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).letterSendBy(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendViaMail() in Letter.php to send a letter via mail.    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
         * @summary Send a letter via mail
         * @param {number} id id of letter you want to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendViaMail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).letterSendViaMail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendViaPost() in Letter.php to send a letter via post if enabled in your subscription    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
         * @summary Send a letter via post
         * @param {number} id id of letter you want to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendViaPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).letterSendViaPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Letter.php
         * @summary Update an existing letter
         * @param {number} id id of letter you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLetter(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelLetter> {
            const localVarFetchArgs = LetterApiFetchParamCreator(configuration).updateLetter(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * LetterApi - factory interface
 * @export
 */
export const LetterApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Letter.php
         * @summary Create a new letter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addLetter(options?: any) {
            return LetterApiFp(configuration).addLetter(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Letter.php
         * @summary Delete an existing letter
         * @param {number} id id of letter you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteLetter(id: number, options?: any) {
            return LetterApiFp(configuration).deleteLetter(id, options)(fetch, basePath);
        },
        /**
         * Calls Letter.php to get necessary variables
         * @summary Get an overview of all letters
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned letters start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getLetters(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return LetterApiFp(configuration).getLetters(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getPdf() in Letter.php to get the pdf of a specified letter from the docserver
         * @summary Get pdf from docserver
         * @param {number} id Id of the letter of which you want to get the pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterGetPdf(id: number, options?: any) {
            return LetterApiFp(configuration).letterGetPdf(id, options)(fetch, basePath);
        },
        /**
         * Calls render() in Letter.php to render a letter to the docserver and return the metadata.    Note that this does not work for letters created by calling the api directly (eg. over Swagger)!
         * @summary Render a letter to the docserver and return the metadata
         * @param {number} id id of letter you want to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterRender(id: number, options?: any) {
            return LetterApiFp(configuration).letterRender(id, options)(fetch, basePath);
        },
        /**
         * Calls sendBy() in Letter.php to update the sendType parameter of the letter and change its status to DELIVERED
         * @summary Update parameter sendType
         * @param {number} id id of letter of which you want to update the sendType parameter
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendBy(id: number, options?: any) {
            return LetterApiFp(configuration).letterSendBy(id, options)(fetch, basePath);
        },
        /**
         * Calls sendViaMail() in Letter.php to send a letter via mail.    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
         * @summary Send a letter via mail
         * @param {number} id id of letter you want to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendViaMail(id: number, options?: any) {
            return LetterApiFp(configuration).letterSendViaMail(id, options)(fetch, basePath);
        },
        /**
         * Calls sendViaPost() in Letter.php to send a letter via post if enabled in your subscription    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
         * @summary Send a letter via post
         * @param {number} id id of letter you want to send
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        letterSendViaPost(id: number, options?: any) {
            return LetterApiFp(configuration).letterSendViaPost(id, options)(fetch, basePath);
        },
        /**
         * Calls Letter.php
         * @summary Update an existing letter
         * @param {number} id id of letter you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateLetter(id: number, options?: any) {
            return LetterApiFp(configuration).updateLetter(id, options)(fetch, basePath);
        },
    };
};

/**
 * LetterApi - object-oriented interface
 * @export
 * @class LetterApi
 * @extends {BaseAPI}
 */
export class LetterApi extends BaseAPI {
    /**
     * Calls Letter.php
     * @summary Create a new letter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public addLetter(options?: any) {
        return LetterApiFp(this.configuration).addLetter(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Letter.php
     * @summary Delete an existing letter
     * @param {number} id id of letter you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public deleteLetter(id: number, options?: any) {
        return LetterApiFp(this.configuration).deleteLetter(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Letter.php to get necessary variables
     * @summary Get an overview of all letters
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned letters start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public getLetters(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return LetterApiFp(this.configuration).getLetters(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPdf() in Letter.php to get the pdf of a specified letter from the docserver
     * @summary Get pdf from docserver
     * @param {number} id Id of the letter of which you want to get the pdf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public letterGetPdf(id: number, options?: any) {
        return LetterApiFp(this.configuration).letterGetPdf(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls render() in Letter.php to render a letter to the docserver and return the metadata.    Note that this does not work for letters created by calling the api directly (eg. over Swagger)!
     * @summary Render a letter to the docserver and return the metadata
     * @param {number} id id of letter you want to render
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public letterRender(id: number, options?: any) {
        return LetterApiFp(this.configuration).letterRender(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendBy() in Letter.php to update the sendType parameter of the letter and change its status to DELIVERED
     * @summary Update parameter sendType
     * @param {number} id id of letter of which you want to update the sendType parameter
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public letterSendBy(id: number, options?: any) {
        return LetterApiFp(this.configuration).letterSendBy(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendViaMail() in Letter.php to send a letter via mail.    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
     * @summary Send a letter via mail
     * @param {number} id id of letter you want to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public letterSendViaMail(id: number, options?: any) {
        return LetterApiFp(this.configuration).letterSendViaMail(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendViaPost() in Letter.php to send a letter via post if enabled in your subscription    Note that you can not send a letter created by calling the api directly (eg. over Swagger)!
     * @summary Send a letter via post
     * @param {number} id id of letter you want to send
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public letterSendViaPost(id: number, options?: any) {
        return LetterApiFp(this.configuration).letterSendViaPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Letter.php
     * @summary Update an existing letter
     * @param {number} id id of letter you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof LetterApi
     */
    public updateLetter(id: number, options?: any) {
        return LetterApiFp(this.configuration).updateLetter(id, options)(this.fetch, this.basePath);
    }

}
/**
 * ObjectUsedApi - fetch parameter creator
 * @export
 */
export const ObjectUsedApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls ObjectUsed.php to get necessary variables
         * @summary Get an overview of all objects used
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned objects used start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectUsed(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/ObjectUsed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectUsedApi - functional programming interface
 * @export
 */
export const ObjectUsedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls ObjectUsed.php to get necessary variables
         * @summary Get an overview of all objects used
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned objects used start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectUsed(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelObjectUsed> {
            const localVarFetchArgs = ObjectUsedApiFetchParamCreator(configuration).getObjectUsed(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ObjectUsedApi - factory interface
 * @export
 */
export const ObjectUsedApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls ObjectUsed.php to get necessary variables
         * @summary Get an overview of all objects used
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned objects used start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectUsed(limit?: number, offset?: number, options?: any) {
            return ObjectUsedApiFp(configuration).getObjectUsed(limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * ObjectUsedApi - object-oriented interface
 * @export
 * @class ObjectUsedApi
 * @extends {BaseAPI}
 */
export class ObjectUsedApi extends BaseAPI {
    /**
     * Calls ObjectUsed.php to get necessary variables
     * @summary Get an overview of all objects used
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned objects used start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectUsedApi
     */
    public getObjectUsed(limit?: number, offset?: number, options?: any) {
        return ObjectUsedApiFp(this.configuration).getObjectUsed(limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * ObjectViewedApi - fetch parameter creator
 * @export
 */
export const ObjectViewedApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls ObjectViewed.php to get necessary variables
         * @summary Get an overview of objects viewed
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned objects viewed start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectViewed(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/ObjectViewed`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ObjectViewedApi - functional programming interface
 * @export
 */
export const ObjectViewedApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls ObjectViewed.php to get necessary variables
         * @summary Get an overview of objects viewed
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned objects viewed start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectViewed(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelObjectViewed> {
            const localVarFetchArgs = ObjectViewedApiFetchParamCreator(configuration).getObjectViewed(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ObjectViewedApi - factory interface
 * @export
 */
export const ObjectViewedApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls ObjectViewed.php to get necessary variables
         * @summary Get an overview of objects viewed
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned objects viewed start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getObjectViewed(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return ObjectViewedApiFp(configuration).getObjectViewed(limit, offset, embed, options)(fetch, basePath);
        },
    };
};

/**
 * ObjectViewedApi - object-oriented interface
 * @export
 * @class ObjectViewedApi
 * @extends {BaseAPI}
 */
export class ObjectViewedApi extends BaseAPI {
    /**
     * Calls ObjectViewed.php to get necessary variables
     * @summary Get an overview of objects viewed
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned objects viewed start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ObjectViewedApi
     */
    public getObjectViewed(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return ObjectViewedApiFp(this.configuration).getObjectViewed(limit, offset, embed, options)(this.fetch, this.basePath);
    }

}
/**
 * OrderApi - fetch parameter creator
 * @export
 */
export const OrderApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Order.php
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrder(options: any = {}): FetchArgs {
            const localVarPath = `/Order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls copy() in Order.php to copy an existing order.    The new orders origin is the copied order, and its version is the copied orders version increased by one.
         * @summary Copy an existing order
         * @param {number} id Id of the order which you want to copy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyOrder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling copyOrder.');
            }
            const localVarPath = `/Order/{id}/copy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Order.php
         * @summary Delete an existing order
         * @param {number} id id of order you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOrder.');
            }
            const localVarPath = `/Order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls duplicate() in Order.php to duplicate an existing order
         * @summary Duplicate an existing order
         * @param {number} id Id of the order which you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateOrder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling duplicateOrder.');
            }
            const localVarPath = `/Order/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * 
         * @summary Get the next order number
         * @param {string} orderType defines the type of order you want to get the next number from
         * @param {boolean} useNextNumber By default this is true, so the orderNumber will increase by one otherwise the orderNumber will not change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextOrderNumber(orderType: string, useNextNumber: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'orderType' is not null or undefined
            if (orderType === null || orderType === undefined) {
                throw new RequiredError('orderType','Required parameter orderType was null or undefined when calling getNextOrderNumber.');
            }
            // verify required parameter 'useNextNumber' is not null or undefined
            if (useNextNumber === null || useNextNumber === undefined) {
                throw new RequiredError('useNextNumber','Required parameter useNextNumber was null or undefined when calling getNextOrderNumber.');
            }
            const localVarPath = `/Order/Factory/getNextOrderNumber`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (orderType !== undefined) {
                localVarQueryParameter['orderType'] = orderType;
            }

            if (useNextNumber !== undefined) {
                localVarQueryParameter['useNextNumber'] = useNextNumber;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDiscounts() in Order.php to get the discounts of the specified order
         * @summary Get all order discounts
         * @param {number} id Id of the order of which you want to get the discounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderDiscounts(id: number, limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling getOrderDiscounts.');
            }
            const localVarPath = `/Order/{id}/getDiscounts`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Order.php to get necessary variables. However, not all variables get their value from Order.php directly but from other models like Model_OrderPos
         * @summary Get an overview of all orders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Order`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls changeStatus() in Order.php to update the specified orders status
         * @summary Update status of an existing order
         * @param {number} id Id of order of which you want to change the status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderChangeStatus(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderChangeStatus.');
            }
            const localVarPath = `/Order/{id}/changeStatus`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getChargeableInformation() in Order.php to get the sum charged already, total net, gross and tax amount and tax rate of the specified order
         * @summary Get sum charged already, total net, gross and tax amount and tax rate
         * @param {number} id Id of the order of which you want to get the information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetChargeableInformation(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetChargeableInformation.');
            }
            const localVarPath = `/Order/{id}/getChargeableInformation`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getChargeableSums() in Order.php to get the total net, gross and tax amount of the specified order
         * @summary Get total net, gross and tax amount of order
         * @param {number} id Id of the order of which you want to get the total net, gross and tax amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetChargeableSums(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetChargeableSums.');
            }
            const localVarPath = `/Order/{id}/getChargeableSums`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getMainOrderByLogs() in Order.php to get main order by checking if there are existing order logs of the specified order.    If the specified order is not the main order (eg. if there are no existing logs), this will return null!
         * @summary Get main order by checking if there are existing order logs of the specified order
         * @param {number} id Id of the order of which you want to know if it is the main order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetMainOrderByLogs(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetMainOrderByLogs.');
            }
            const localVarPath = `/Order/{id}/getMainOrderByLogs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPdf() in Order.php
         * @summary Get the order as a pdf
         * @param {number} id Id of the order of which you want to get the pdf
         * @param {boolean} [preventSendBy] Define if you want to prevent to send the order via pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetPdf(id: number, preventSendBy?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetPdf.');
            }
            const localVarPath = `/Order/{id}/getPdf`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (preventSendBy !== undefined) {
                localVarQueryParameter['preventSendBy'] = preventSendBy;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPositions() in Order.php to get necessary variables
         * @summary Get all order positions
         * @param {number} id Id of the order of which you want to get the positions
         * @param {boolean} [withOptional] Define if you want optional order positions
         * @param {boolean} [onlyChargeable] Define if you want only chargeable order positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetPositions(id: number, withOptional?: boolean, onlyChargeable?: boolean, limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetPositions.');
            }
            const localVarPath = `/Order/{id}/getPositions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (withOptional !== undefined) {
                localVarQueryParameter['withOptional'] = withOptional;
            }

            if (onlyChargeable !== undefined) {
                localVarQueryParameter['onlyChargeable'] = onlyChargeable;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getRelatedObjects() in Order.php to get related objects of the order
         * @summary Get related objects of a specified order
         * @param {number} id Id of the order of which you want to get the related objects
         * @param {boolean} [includeItself] Define if the related objects include the order itself
         * @param {boolean} [sortByType] Define if you want the related objects sorted by type
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetRelatedObjects.');
            }
            const localVarPath = `/Order/{id}/getRelatedObjects`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (includeItself !== undefined) {
                localVarQueryParameter['includeItself'] = includeItself;
            }

            if (sortByType !== undefined) {
                localVarQueryParameter['sortByType'] = sortByType;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTags() in Order.php to get the tags of the specified order
         * @summary Get tags of the specified order
         * @param {number} id Id of the order of which you want to get the tags
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTags(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetTags.');
            }
            const localVarPath = `/Order/{id}/getTags`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTax() in Order.php to get the sum tax of the specified order
         * @summary Get sum tax of the specified order
         * @param {number} id Id of the order of which you want to get the sum tax
         * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTax(id: number, foreignCurrency?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetTax.');
            }
            const localVarPath = `/Order/{id}/getTax`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (foreignCurrency !== undefined) {
                localVarQueryParameter['foreignCurrency'] = foreignCurrency;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTaxGroupes() in Order.php to get the tax groups of the specified order
         * @summary Get tax groups of the specified order
         * @param {number} id Id of the order of which you want to get the tax groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTaxGroupes(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetTaxGroupes.');
            }
            const localVarPath = `/Order/{id}/getTaxGroupes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTotal() in Order.php to get the sum gross of the specified order
         * @summary Get sum gross of the specified order
         * @param {number} id Id of the order of which you want to get the sum gross
         * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotal(id: number, foreignCurrency?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetTotal.');
            }
            const localVarPath = `/Order/{id}/getTotal`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (foreignCurrency !== undefined) {
                localVarQueryParameter['foreignCurrency'] = foreignCurrency;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTotalCalc() in Order.php to get the total gross amount of the specified order
         * @summary Get total gross amount of order
         * @param {number} id Id of the order of which you want to get the total gross amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotalCalc(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetTotalCalc.');
            }
            const localVarPath = `/Order/{id}/getTotalCalc`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getTotalNet() in Order.php to get the total net amount of the specified order
         * @summary Get total net amount of order
         * @param {number} id Id of the order of which you want to get the total net amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotalNet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderGetTotalNet.');
            }
            const localVarPath = `/Order/{id}/getTotalNet`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls render() in Order.php to render an order document on doc server and return the metadata
         * @summary Render the order document on doc server and return the metadata
         * @param {number} id Id of order you want to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRender(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderRender.');
            }
            const localVarPath = `/Order/{id}/render`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendBy() in Order.php to send the order by the desired send type
         * @summary Send an order by the desired send type
         * @param {number} id Id of order which you want to send
         * @param {string} [sendType] Your desired send type. Available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSendBy(id: number, sendType?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling orderSendBy.');
            }
            const localVarPath = `/Order/{id}/sendBy`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (sendType !== undefined) {
                localVarQueryParameter['sendType'] = sendType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendViaEmail in Order.php
         * @summary Send an order via Email
         * @param {number} id Id of order you want to send via Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOrderViaEmail(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendOrderViaEmail.');
            }
            const localVarPath = `/Order/{id}/sendViaEmail`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls sendViaPost() in Order.php
         * @summary Send an order via post
         * @param {number} id Id of order you want to send via post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOrderViaPost(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling sendOrderViaPost.');
            }
            const localVarPath = `/Order/{id}/sendViaPost`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Order.php
         * @summary Update an existing order
         * @param {number} id id of order you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateOrder.');
            }
            const localVarPath = `/Order/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderApi - functional programming interface
 * @export
 */
export const OrderApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Order.php
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrder(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).addOrder(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls copy() in Order.php to copy an existing order.    The new orders origin is the copied order, and its version is the copied orders version increased by one.
         * @summary Copy an existing order
         * @param {number} id Id of the order which you want to copy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyOrder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).copyOrder(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Order.php
         * @summary Delete an existing order
         * @param {number} id id of order you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).deleteOrder(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls duplicate() in Order.php to duplicate an existing order
         * @summary Duplicate an existing order
         * @param {number} id Id of the order which you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateOrder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).duplicateOrder(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * 
         * @summary Get the next order number
         * @param {string} orderType defines the type of order you want to get the next number from
         * @param {boolean} useNextNumber By default this is true, so the orderNumber will increase by one otherwise the orderNumber will not change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextOrderNumber(orderType: string, useNextNumber: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getNextOrderNumber(orderType, useNextNumber, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDiscounts() in Order.php to get the discounts of the specified order
         * @summary Get all order discounts
         * @param {number} id Id of the order of which you want to get the discounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderDiscounts(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelDiscounts> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrderDiscounts(id, limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Order.php to get necessary variables. However, not all variables get their value from Order.php directly but from other models like Model_OrderPos
         * @summary Get an overview of all orders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).getOrders(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls changeStatus() in Order.php to update the specified orders status
         * @summary Update status of an existing order
         * @param {number} id Id of order of which you want to change the status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderChangeStatus(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderChangeStatus(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getChargeableInformation() in Order.php to get the sum charged already, total net, gross and tax amount and tax rate of the specified order
         * @summary Get sum charged already, total net, gross and tax amount and tax rate
         * @param {number} id Id of the order of which you want to get the information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetChargeableInformation(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetChargeableInformation(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getChargeableSums() in Order.php to get the total net, gross and tax amount of the specified order
         * @summary Get total net, gross and tax amount of order
         * @param {number} id Id of the order of which you want to get the total net, gross and tax amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetChargeableSums(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetChargeableSums(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getMainOrderByLogs() in Order.php to get main order by checking if there are existing order logs of the specified order.    If the specified order is not the main order (eg. if there are no existing logs), this will return null!
         * @summary Get main order by checking if there are existing order logs of the specified order
         * @param {number} id Id of the order of which you want to know if it is the main order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetMainOrderByLogs(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetMainOrderByLogs(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPdf() in Order.php
         * @summary Get the order as a pdf
         * @param {number} id Id of the order of which you want to get the pdf
         * @param {boolean} [preventSendBy] Define if you want to prevent to send the order via pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetPdf(id: number, preventSendBy?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetPdf(id, preventSendBy, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPositions() in Order.php to get necessary variables
         * @summary Get all order positions
         * @param {number} id Id of the order of which you want to get the positions
         * @param {boolean} [withOptional] Define if you want optional order positions
         * @param {boolean} [onlyChargeable] Define if you want only chargeable order positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetPositions(id: number, withOptional?: boolean, onlyChargeable?: boolean, limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderPos> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetPositions(id, withOptional, onlyChargeable, limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getRelatedObjects() in Order.php to get related objects of the order
         * @summary Get related objects of a specified order
         * @param {number} id Id of the order of which you want to get the related objects
         * @param {boolean} [includeItself] Define if the related objects include the order itself
         * @param {boolean} [sortByType] Define if you want the related objects sorted by type
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetRelatedObjects(id, includeItself, sortByType, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTags() in Order.php to get the tags of the specified order
         * @summary Get tags of the specified order
         * @param {number} id Id of the order of which you want to get the tags
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTags(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetTags(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTax() in Order.php to get the sum tax of the specified order
         * @summary Get sum tax of the specified order
         * @param {number} id Id of the order of which you want to get the sum tax
         * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTax(id: number, foreignCurrency?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetTax(id, foreignCurrency, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTaxGroupes() in Order.php to get the tax groups of the specified order
         * @summary Get tax groups of the specified order
         * @param {number} id Id of the order of which you want to get the tax groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTaxGroupes(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetTaxGroupes(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTotal() in Order.php to get the sum gross of the specified order
         * @summary Get sum gross of the specified order
         * @param {number} id Id of the order of which you want to get the sum gross
         * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotal(id: number, foreignCurrency?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetTotal(id, foreignCurrency, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTotalCalc() in Order.php to get the total gross amount of the specified order
         * @summary Get total gross amount of order
         * @param {number} id Id of the order of which you want to get the total gross amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotalCalc(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetTotalCalc(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getTotalNet() in Order.php to get the total net amount of the specified order
         * @summary Get total net amount of order
         * @param {number} id Id of the order of which you want to get the total net amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotalNet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderGetTotalNet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls render() in Order.php to render an order document on doc server and return the metadata
         * @summary Render the order document on doc server and return the metadata
         * @param {number} id Id of order you want to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRender(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderRender(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendBy() in Order.php to send the order by the desired send type
         * @summary Send an order by the desired send type
         * @param {number} id Id of order which you want to send
         * @param {string} [sendType] Your desired send type. Available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSendBy(id: number, sendType?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).orderSendBy(id, sendType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendViaEmail in Order.php
         * @summary Send an order via Email
         * @param {number} id Id of order you want to send via Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOrderViaEmail(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelEmail> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).sendOrderViaEmail(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls sendViaPost() in Order.php
         * @summary Send an order via post
         * @param {number} id Id of order you want to send via post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOrderViaPost(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).sendOrderViaPost(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Order.php
         * @summary Update an existing order
         * @param {number} id id of order you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrder> {
            const localVarFetchArgs = OrderApiFetchParamCreator(configuration).updateOrder(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderApi - factory interface
 * @export
 */
export const OrderApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Order.php
         * @summary Create a new order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrder(options?: any) {
            return OrderApiFp(configuration).addOrder(options)(fetch, basePath);
        },
        /**
         * Calls copy() in Order.php to copy an existing order.    The new orders origin is the copied order, and its version is the copied orders version increased by one.
         * @summary Copy an existing order
         * @param {number} id Id of the order which you want to copy
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        copyOrder(id: number, options?: any) {
            return OrderApiFp(configuration).copyOrder(id, options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Order.php
         * @summary Delete an existing order
         * @param {number} id id of order you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrder(id: number, options?: any) {
            return OrderApiFp(configuration).deleteOrder(id, options)(fetch, basePath);
        },
        /**
         * Calls duplicate() in Order.php to duplicate an existing order
         * @summary Duplicate an existing order
         * @param {number} id Id of the order which you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicateOrder(id: number, options?: any) {
            return OrderApiFp(configuration).duplicateOrder(id, options)(fetch, basePath);
        },
        /**
         * 
         * @summary Get the next order number
         * @param {string} orderType defines the type of order you want to get the next number from
         * @param {boolean} useNextNumber By default this is true, so the orderNumber will increase by one otherwise the orderNumber will not change
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getNextOrderNumber(orderType: string, useNextNumber: boolean, options?: any) {
            return OrderApiFp(configuration).getNextOrderNumber(orderType, useNextNumber, options)(fetch, basePath);
        },
        /**
         * Calls getDiscounts() in Order.php to get the discounts of the specified order
         * @summary Get all order discounts
         * @param {number} id Id of the order of which you want to get the discounts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderDiscounts(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return OrderApiFp(configuration).getOrderDiscounts(id, limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls Order.php to get necessary variables. However, not all variables get their value from Order.php directly but from other models like Model_OrderPos
         * @summary Get an overview of all orders
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrders(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return OrderApiFp(configuration).getOrders(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls changeStatus() in Order.php to update the specified orders status
         * @summary Update status of an existing order
         * @param {number} id Id of order of which you want to change the status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderChangeStatus(id: number, options?: any) {
            return OrderApiFp(configuration).orderChangeStatus(id, options)(fetch, basePath);
        },
        /**
         * Calls getChargeableInformation() in Order.php to get the sum charged already, total net, gross and tax amount and tax rate of the specified order
         * @summary Get sum charged already, total net, gross and tax amount and tax rate
         * @param {number} id Id of the order of which you want to get the information
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetChargeableInformation(id: number, options?: any) {
            return OrderApiFp(configuration).orderGetChargeableInformation(id, options)(fetch, basePath);
        },
        /**
         * Calls getChargeableSums() in Order.php to get the total net, gross and tax amount of the specified order
         * @summary Get total net, gross and tax amount of order
         * @param {number} id Id of the order of which you want to get the total net, gross and tax amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetChargeableSums(id: number, options?: any) {
            return OrderApiFp(configuration).orderGetChargeableSums(id, options)(fetch, basePath);
        },
        /**
         * Calls getMainOrderByLogs() in Order.php to get main order by checking if there are existing order logs of the specified order.    If the specified order is not the main order (eg. if there are no existing logs), this will return null!
         * @summary Get main order by checking if there are existing order logs of the specified order
         * @param {number} id Id of the order of which you want to know if it is the main order
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetMainOrderByLogs(id: number, options?: any) {
            return OrderApiFp(configuration).orderGetMainOrderByLogs(id, options)(fetch, basePath);
        },
        /**
         * Calls getPdf() in Order.php
         * @summary Get the order as a pdf
         * @param {number} id Id of the order of which you want to get the pdf
         * @param {boolean} [preventSendBy] Define if you want to prevent to send the order via pdf
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetPdf(id: number, preventSendBy?: boolean, options?: any) {
            return OrderApiFp(configuration).orderGetPdf(id, preventSendBy, options)(fetch, basePath);
        },
        /**
         * Calls getPositions() in Order.php to get necessary variables
         * @summary Get all order positions
         * @param {number} id Id of the order of which you want to get the positions
         * @param {boolean} [withOptional] Define if you want optional order positions
         * @param {boolean} [onlyChargeable] Define if you want only chargeable order positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetPositions(id: number, withOptional?: boolean, onlyChargeable?: boolean, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return OrderApiFp(configuration).orderGetPositions(id, withOptional, onlyChargeable, limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getRelatedObjects() in Order.php to get related objects of the order
         * @summary Get related objects of a specified order
         * @param {number} id Id of the order of which you want to get the related objects
         * @param {boolean} [includeItself] Define if the related objects include the order itself
         * @param {boolean} [sortByType] Define if you want the related objects sorted by type
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options?: any) {
            return OrderApiFp(configuration).orderGetRelatedObjects(id, includeItself, sortByType, embed, options)(fetch, basePath);
        },
        /**
         * Calls getTags() in Order.php to get the tags of the specified order
         * @summary Get tags of the specified order
         * @param {number} id Id of the order of which you want to get the tags
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTags(id: number, embed?: Array<string>, options?: any) {
            return OrderApiFp(configuration).orderGetTags(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getTax() in Order.php to get the sum tax of the specified order
         * @summary Get sum tax of the specified order
         * @param {number} id Id of the order of which you want to get the sum tax
         * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTax(id: number, foreignCurrency?: boolean, options?: any) {
            return OrderApiFp(configuration).orderGetTax(id, foreignCurrency, options)(fetch, basePath);
        },
        /**
         * Calls getTaxGroupes() in Order.php to get the tax groups of the specified order
         * @summary Get tax groups of the specified order
         * @param {number} id Id of the order of which you want to get the tax groups
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTaxGroupes(id: number, options?: any) {
            return OrderApiFp(configuration).orderGetTaxGroupes(id, options)(fetch, basePath);
        },
        /**
         * Calls getTotal() in Order.php to get the sum gross of the specified order
         * @summary Get sum gross of the specified order
         * @param {number} id Id of the order of which you want to get the sum gross
         * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotal(id: number, foreignCurrency?: boolean, options?: any) {
            return OrderApiFp(configuration).orderGetTotal(id, foreignCurrency, options)(fetch, basePath);
        },
        /**
         * Calls getTotalCalc() in Order.php to get the total gross amount of the specified order
         * @summary Get total gross amount of order
         * @param {number} id Id of the order of which you want to get the total gross amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotalCalc(id: number, options?: any) {
            return OrderApiFp(configuration).orderGetTotalCalc(id, options)(fetch, basePath);
        },
        /**
         * Calls getTotalNet() in Order.php to get the total net amount of the specified order
         * @summary Get total net amount of order
         * @param {number} id Id of the order of which you want to get the total net amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderGetTotalNet(id: number, options?: any) {
            return OrderApiFp(configuration).orderGetTotalNet(id, options)(fetch, basePath);
        },
        /**
         * Calls render() in Order.php to render an order document on doc server and return the metadata
         * @summary Render the order document on doc server and return the metadata
         * @param {number} id Id of order you want to render
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderRender(id: number, options?: any) {
            return OrderApiFp(configuration).orderRender(id, options)(fetch, basePath);
        },
        /**
         * Calls sendBy() in Order.php to send the order by the desired send type
         * @summary Send an order by the desired send type
         * @param {number} id Id of order which you want to send
         * @param {string} [sendType] Your desired send type. Available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        orderSendBy(id: number, sendType?: string, options?: any) {
            return OrderApiFp(configuration).orderSendBy(id, sendType, options)(fetch, basePath);
        },
        /**
         * Calls sendViaEmail in Order.php
         * @summary Send an order via Email
         * @param {number} id Id of order you want to send via Email
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOrderViaEmail(id: number, options?: any) {
            return OrderApiFp(configuration).sendOrderViaEmail(id, options)(fetch, basePath);
        },
        /**
         * Calls sendViaPost() in Order.php
         * @summary Send an order via post
         * @param {number} id Id of order you want to send via post
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sendOrderViaPost(id: number, options?: any) {
            return OrderApiFp(configuration).sendOrderViaPost(id, options)(fetch, basePath);
        },
        /**
         * Calls Order.php
         * @summary Update an existing order
         * @param {number} id id of order you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrder(id: number, options?: any) {
            return OrderApiFp(configuration).updateOrder(id, options)(fetch, basePath);
        },
    };
};

/**
 * OrderApi - object-oriented interface
 * @export
 * @class OrderApi
 * @extends {BaseAPI}
 */
export class OrderApi extends BaseAPI {
    /**
     * Calls Order.php
     * @summary Create a new order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public addOrder(options?: any) {
        return OrderApiFp(this.configuration).addOrder(options)(this.fetch, this.basePath);
    }

    /**
     * Calls copy() in Order.php to copy an existing order.    The new orders origin is the copied order, and its version is the copied orders version increased by one.
     * @summary Copy an existing order
     * @param {number} id Id of the order which you want to copy
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public copyOrder(id: number, options?: any) {
        return OrderApiFp(this.configuration).copyOrder(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Order.php
     * @summary Delete an existing order
     * @param {number} id id of order you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public deleteOrder(id: number, options?: any) {
        return OrderApiFp(this.configuration).deleteOrder(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls duplicate() in Order.php to duplicate an existing order
     * @summary Duplicate an existing order
     * @param {number} id Id of the order which you want to duplicate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public duplicateOrder(id: number, options?: any) {
        return OrderApiFp(this.configuration).duplicateOrder(id, options)(this.fetch, this.basePath);
    }

    /**
     * 
     * @summary Get the next order number
     * @param {string} orderType defines the type of order you want to get the next number from
     * @param {boolean} useNextNumber By default this is true, so the orderNumber will increase by one otherwise the orderNumber will not change
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getNextOrderNumber(orderType: string, useNextNumber: boolean, options?: any) {
        return OrderApiFp(this.configuration).getNextOrderNumber(orderType, useNextNumber, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDiscounts() in Order.php to get the discounts of the specified order
     * @summary Get all order discounts
     * @param {number} id Id of the order of which you want to get the discounts
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned order positions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrderDiscounts(id: number, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return OrderApiFp(this.configuration).getOrderDiscounts(id, limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Order.php to get necessary variables. However, not all variables get their value from Order.php directly but from other models like Model_OrderPos
     * @summary Get an overview of all orders
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned invoice positions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public getOrders(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return OrderApiFp(this.configuration).getOrders(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls changeStatus() in Order.php to update the specified orders status
     * @summary Update status of an existing order
     * @param {number} id Id of order of which you want to change the status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderChangeStatus(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderChangeStatus(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getChargeableInformation() in Order.php to get the sum charged already, total net, gross and tax amount and tax rate of the specified order
     * @summary Get sum charged already, total net, gross and tax amount and tax rate
     * @param {number} id Id of the order of which you want to get the information
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetChargeableInformation(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderGetChargeableInformation(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getChargeableSums() in Order.php to get the total net, gross and tax amount of the specified order
     * @summary Get total net, gross and tax amount of order
     * @param {number} id Id of the order of which you want to get the total net, gross and tax amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetChargeableSums(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderGetChargeableSums(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getMainOrderByLogs() in Order.php to get main order by checking if there are existing order logs of the specified order.    If the specified order is not the main order (eg. if there are no existing logs), this will return null!
     * @summary Get main order by checking if there are existing order logs of the specified order
     * @param {number} id Id of the order of which you want to know if it is the main order
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetMainOrderByLogs(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderGetMainOrderByLogs(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPdf() in Order.php
     * @summary Get the order as a pdf
     * @param {number} id Id of the order of which you want to get the pdf
     * @param {boolean} [preventSendBy] Define if you want to prevent to send the order via pdf
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetPdf(id: number, preventSendBy?: boolean, options?: any) {
        return OrderApiFp(this.configuration).orderGetPdf(id, preventSendBy, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPositions() in Order.php to get necessary variables
     * @summary Get all order positions
     * @param {number} id Id of the order of which you want to get the positions
     * @param {boolean} [withOptional] Define if you want optional order positions
     * @param {boolean} [onlyChargeable] Define if you want only chargeable order positions
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned order positions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetPositions(id: number, withOptional?: boolean, onlyChargeable?: boolean, limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return OrderApiFp(this.configuration).orderGetPositions(id, withOptional, onlyChargeable, limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getRelatedObjects() in Order.php to get related objects of the order
     * @summary Get related objects of a specified order
     * @param {number} id Id of the order of which you want to get the related objects
     * @param {boolean} [includeItself] Define if the related objects include the order itself
     * @param {boolean} [sortByType] Define if you want the related objects sorted by type
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetRelatedObjects(id: number, includeItself?: boolean, sortByType?: boolean, embed?: Array<string>, options?: any) {
        return OrderApiFp(this.configuration).orderGetRelatedObjects(id, includeItself, sortByType, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTags() in Order.php to get the tags of the specified order
     * @summary Get tags of the specified order
     * @param {number} id Id of the order of which you want to get the tags
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetTags(id: number, embed?: Array<string>, options?: any) {
        return OrderApiFp(this.configuration).orderGetTags(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTax() in Order.php to get the sum tax of the specified order
     * @summary Get sum tax of the specified order
     * @param {number} id Id of the order of which you want to get the sum tax
     * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetTax(id: number, foreignCurrency?: boolean, options?: any) {
        return OrderApiFp(this.configuration).orderGetTax(id, foreignCurrency, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTaxGroupes() in Order.php to get the tax groups of the specified order
     * @summary Get tax groups of the specified order
     * @param {number} id Id of the order of which you want to get the tax groups
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetTaxGroupes(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderGetTaxGroupes(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTotal() in Order.php to get the sum gross of the specified order
     * @summary Get sum gross of the specified order
     * @param {number} id Id of the order of which you want to get the sum gross
     * @param {boolean} [foreignCurrency] Specify if a foreign currency is used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetTotal(id: number, foreignCurrency?: boolean, options?: any) {
        return OrderApiFp(this.configuration).orderGetTotal(id, foreignCurrency, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTotalCalc() in Order.php to get the total gross amount of the specified order
     * @summary Get total gross amount of order
     * @param {number} id Id of the order of which you want to get the total gross amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetTotalCalc(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderGetTotalCalc(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getTotalNet() in Order.php to get the total net amount of the specified order
     * @summary Get total net amount of order
     * @param {number} id Id of the order of which you want to get the total net amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderGetTotalNet(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderGetTotalNet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls render() in Order.php to render an order document on doc server and return the metadata
     * @summary Render the order document on doc server and return the metadata
     * @param {number} id Id of order you want to render
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderRender(id: number, options?: any) {
        return OrderApiFp(this.configuration).orderRender(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendBy() in Order.php to send the order by the desired send type
     * @summary Send an order by the desired send type
     * @param {number} id Id of order which you want to send
     * @param {string} [sendType] Your desired send type. Available are: VM &#x3D; Mail, VP &#x3D; Post, VPDF &#x3D; PDF, PRN &#x3D; Print
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public orderSendBy(id: number, sendType?: string, options?: any) {
        return OrderApiFp(this.configuration).orderSendBy(id, sendType, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendViaEmail in Order.php
     * @summary Send an order via Email
     * @param {number} id Id of order you want to send via Email
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public sendOrderViaEmail(id: number, options?: any) {
        return OrderApiFp(this.configuration).sendOrderViaEmail(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls sendViaPost() in Order.php
     * @summary Send an order via post
     * @param {number} id Id of order you want to send via post
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public sendOrderViaPost(id: number, options?: any) {
        return OrderApiFp(this.configuration).sendOrderViaPost(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Order.php
     * @summary Update an existing order
     * @param {number} id id of order you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderApi
     */
    public updateOrder(id: number, options?: any) {
        return OrderApiFp(this.configuration).updateOrder(id, options)(this.fetch, this.basePath);
    }

}
/**
 * OrderLogApi - fetch parameter creator
 * @export
 */
export const OrderLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls OrderLog.php
         * @summary Create a new order log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderLog(options: any = {}): FetchArgs {
            const localVarPath = `/OrderLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in OrderLog.php
         * @summary Delete an existing order log
         * @param {number} id Id of order log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOrderLog.');
            }
            const localVarPath = `/OrderLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls OrderLog.php to get necessary variables
         * @summary Get an overview of order logs
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderLogs(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/OrderLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls OrderLog.php
         * @summary Update an existing order log
         * @param {number} id Id of order log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderLog(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateOrderLog.');
            }
            const localVarPath = `/OrderLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderLogApi - functional programming interface
 * @export
 */
export const OrderLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls OrderLog.php
         * @summary Create a new order log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderLog(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderLog> {
            const localVarFetchArgs = OrderLogApiFetchParamCreator(configuration).addOrderLog(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in OrderLog.php
         * @summary Delete an existing order log
         * @param {number} id Id of order log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderLogApiFetchParamCreator(configuration).deleteOrderLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls OrderLog.php to get necessary variables
         * @summary Get an overview of order logs
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderLogs(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderLog> {
            const localVarFetchArgs = OrderLogApiFetchParamCreator(configuration).getOrderLogs(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls OrderLog.php
         * @summary Update an existing order log
         * @param {number} id Id of order log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderLog(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderLog> {
            const localVarFetchArgs = OrderLogApiFetchParamCreator(configuration).updateOrderLog(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderLogApi - factory interface
 * @export
 */
export const OrderLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls OrderLog.php
         * @summary Create a new order log
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderLog(options?: any) {
            return OrderLogApiFp(configuration).addOrderLog(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in OrderLog.php
         * @summary Delete an existing order log
         * @param {number} id Id of order log you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderLog(id: number, options?: any) {
            return OrderLogApiFp(configuration).deleteOrderLog(id, options)(fetch, basePath);
        },
        /**
         * Calls OrderLog.php to get necessary variables
         * @summary Get an overview of order logs
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order logs start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderLogs(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return OrderLogApiFp(configuration).getOrderLogs(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls OrderLog.php
         * @summary Update an existing order log
         * @param {number} id Id of order log you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderLog(id: number, options?: any) {
            return OrderLogApiFp(configuration).updateOrderLog(id, options)(fetch, basePath);
        },
    };
};

/**
 * OrderLogApi - object-oriented interface
 * @export
 * @class OrderLogApi
 * @extends {BaseAPI}
 */
export class OrderLogApi extends BaseAPI {
    /**
     * Calls OrderLog.php
     * @summary Create a new order log
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderLogApi
     */
    public addOrderLog(options?: any) {
        return OrderLogApiFp(this.configuration).addOrderLog(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in OrderLog.php
     * @summary Delete an existing order log
     * @param {number} id Id of order log you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderLogApi
     */
    public deleteOrderLog(id: number, options?: any) {
        return OrderLogApiFp(this.configuration).deleteOrderLog(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls OrderLog.php to get necessary variables
     * @summary Get an overview of order logs
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned order logs start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderLogApi
     */
    public getOrderLogs(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return OrderLogApiFp(this.configuration).getOrderLogs(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls OrderLog.php
     * @summary Update an existing order log
     * @param {number} id Id of order log you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderLogApi
     */
    public updateOrderLog(id: number, options?: any) {
        return OrderLogApiFp(this.configuration).updateOrderLog(id, options)(this.fetch, this.basePath);
    }

}
/**
 * OrderPosApi - fetch parameter creator
 * @export
 */
export const OrderPosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls OrderPos.php.     As described in the Model_Order earlier, some of its parameters get their value from other models/functions.     OrderPos is one of those Models and provides the ability to add products/parts to your order which fills values like sumNet,taxation, etc.
         * @summary Create a new order position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderPos(options: any = {}): FetchArgs {
            const localVarPath = `/OrderPos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in OrderPos.php. This does NOT delete an order, just the position which belonged to the order!
         * @summary Delete an existing order position
         * @param {number} id id of order position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderPos(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteOrderPos.');
            }
            const localVarPath = `/OrderPos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls OrderPos.php to get necessary variables.
         * @summary Get an overview of all order positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderPositions(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/OrderPos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing order position
         * @param {number} id id of order position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderPos(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateOrderPos.');
            }
            const localVarPath = `/OrderPos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * OrderPosApi - functional programming interface
 * @export
 */
export const OrderPosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls OrderPos.php.     As described in the Model_Order earlier, some of its parameters get their value from other models/functions.     OrderPos is one of those Models and provides the ability to add products/parts to your order which fills values like sumNet,taxation, etc.
         * @summary Create a new order position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderPos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderPos> {
            const localVarFetchArgs = OrderPosApiFetchParamCreator(configuration).addOrderPos(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in OrderPos.php. This does NOT delete an order, just the position which belonged to the order!
         * @summary Delete an existing order position
         * @param {number} id id of order position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderPos(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = OrderPosApiFetchParamCreator(configuration).deleteOrderPos(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls OrderPos.php to get necessary variables.
         * @summary Get an overview of all order positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderPos> {
            const localVarFetchArgs = OrderPosApiFetchParamCreator(configuration).getOrderPositions(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing order position
         * @param {number} id id of order position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderPos(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderPos> {
            const localVarFetchArgs = OrderPosApiFetchParamCreator(configuration).updateOrderPos(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * OrderPosApi - factory interface
 * @export
 */
export const OrderPosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls OrderPos.php.     As described in the Model_Order earlier, some of its parameters get their value from other models/functions.     OrderPos is one of those Models and provides the ability to add products/parts to your order which fills values like sumNet,taxation, etc.
         * @summary Create a new order position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addOrderPos(options?: any) {
            return OrderPosApiFp(configuration).addOrderPos(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in OrderPos.php. This does NOT delete an order, just the position which belonged to the order!
         * @summary Delete an existing order position
         * @param {number} id id of order position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteOrderPos(id: number, options?: any) {
            return OrderPosApiFp(configuration).deleteOrderPos(id, options)(fetch, basePath);
        },
        /**
         * Calls OrderPos.php to get necessary variables.
         * @summary Get an overview of all order positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned order positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getOrderPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return OrderPosApiFp(configuration).getOrderPositions(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing order position
         * @param {number} id id of order position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateOrderPos(id: number, options?: any) {
            return OrderPosApiFp(configuration).updateOrderPos(id, options)(fetch, basePath);
        },
    };
};

/**
 * OrderPosApi - object-oriented interface
 * @export
 * @class OrderPosApi
 * @extends {BaseAPI}
 */
export class OrderPosApi extends BaseAPI {
    /**
     * Calls OrderPos.php.     As described in the Model_Order earlier, some of its parameters get their value from other models/functions.     OrderPos is one of those Models and provides the ability to add products/parts to your order which fills values like sumNet,taxation, etc.
     * @summary Create a new order position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderPosApi
     */
    public addOrderPos(options?: any) {
        return OrderPosApiFp(this.configuration).addOrderPos(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in OrderPos.php. This does NOT delete an order, just the position which belonged to the order!
     * @summary Delete an existing order position
     * @param {number} id id of order position you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderPosApi
     */
    public deleteOrderPos(id: number, options?: any) {
        return OrderPosApiFp(this.configuration).deleteOrderPos(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls OrderPos.php to get necessary variables.
     * @summary Get an overview of all order positions
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned order positions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderPosApi
     */
    public getOrderPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return OrderPosApiFp(this.configuration).getOrderPositions(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * TODO: Enter short backend documentation here
     * @summary Update an existing order position
     * @param {number} id id of order position you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof OrderPosApi
     */
    public updateOrderPos(id: number, options?: any) {
        return OrderPosApiFp(this.configuration).updateOrderPos(id, options)(this.fetch, this.basePath);
    }

}
/**
 * PartApi - fetch parameter creator
 * @export
 */
export const PartApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Part.php to add a part
         * @summary Create a new part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPart(options: any = {}): FetchArgs {
            const localVarPath = `/Part`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls book() in Part.php
         * @summary add / remove parts from the stock
         * @param {number} id id of part of which you want to update the stock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookPart(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling bookPart.');
            }
            const localVarPath = `/Part/{id}/book`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Part.php. Be aware that you can't delete parts which are used somewhere!
         * @summary Delete an existing part
         * @param {number} id id of the part you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePart(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePart.');
            }
            const localVarPath = `/Part/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls duplicate() in Part.php to duplicate the specified part. Mind that the stock will be zero
         * @summary Duplicate an existing part
         * @param {number} id Id of the part which you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicatePart(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling duplicatePart.');
            }
            const localVarPath = `/Part/{id}/duplicate`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Part.php to get necessary variables.
         * @summary Get an overview of all parts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned parts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParts(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Part`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getLastLog() in Part.php to get the last log about the specified part
         * @summary Get last log about the part
         * @param {number} id Id of the part of which you want to get the last log
         * @param {string} [maxDate] Sets the maximal date if required
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetLastLog(id: number, maxDate?: string, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling partGetLastLog.');
            }
            const localVarPath = `/Part/{id}/getLastLog`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (maxDate !== undefined) {
                localVarQueryParameter['maxDate'] = maxDate;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getPrice() in Part.php to get the price of the specified part
         * @summary Get price of a specified part
         * @param {number} id Id of the part of which you want to get the price
         * @param {number} [contactId] Enter valid contact id here for getting a part contact price
         * @param {string} [contactObjectName] Enter &#x27;Contact&#x27; here for getting a part contact price
         * @param {number} [partUnityId] Enter a valid part unity id here for getting a part unity price
         * @param {string} [partUnityObjectName] Enter &#x27;PartUnity&#x27; here for getting a part unity price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetPrice(id: number, contactId?: number, contactObjectName?: string, partUnityId?: number, partUnityObjectName?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling partGetPrice.');
            }
            const localVarPath = `/Part/{id}/getPrice`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (contactId !== undefined) {
                localVarQueryParameter['contact[id]'] = contactId;
            }

            if (contactObjectName !== undefined) {
                localVarQueryParameter['contact[objectName]'] = contactObjectName;
            }

            if (partUnityId !== undefined) {
                localVarQueryParameter['partUnity[id]'] = partUnityId;
            }

            if (partUnityObjectName !== undefined) {
                localVarQueryParameter['partUnity[objectName]'] = partUnityObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getStock() in Part.php to get the stock of the specified part
         * @summary Get stock of the part
         * @param {number} id Id of the part of which you want to get stock
         * @param {string} [maxDate] Sets the maximal date if required. The function will return the stock of the part at the specified date!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetStock(id: number, maxDate?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling partGetStock.');
            }
            const localVarPath = `/Part/{id}/getStock`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (maxDate !== undefined) {
                localVarQueryParameter['maxDate'] = maxDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getStockBefore() in Part.php to get the stock difference of the specified part before the specified date
         * @summary Get stock difference of the part before a specified date
         * @param {number} id Id of the part of which you want to get the stock difference
         * @param {string} [date] You will get the stock difference before this specified date, otherwise the current date will be used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetStockBefore(id: number, date?: string, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling partGetStockBefore.');
            }
            const localVarPath = `/Part/{id}/getStockBefore`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (date !== undefined) {
                localVarQueryParameter['date'] = date;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PartContactPrice to update a part
         * @summary Update an existing part
         * @param {number} id id of part you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePart(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePart.');
            }
            const localVarPath = `/Part/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartApi - functional programming interface
 * @export
 */
export const PartApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Part.php to add a part
         * @summary Create a new part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPart(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPart> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).addPart(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls book() in Part.php
         * @summary add / remove parts from the stock
         * @param {number} id id of part of which you want to update the stock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookPart(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPart> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).bookPart(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Part.php. Be aware that you can't delete parts which are used somewhere!
         * @summary Delete an existing part
         * @param {number} id id of the part you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePart(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).deletePart(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls duplicate() in Part.php to duplicate the specified part. Mind that the stock will be zero
         * @summary Duplicate an existing part
         * @param {number} id Id of the part which you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicatePart(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPart> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).duplicatePart(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Part.php to get necessary variables.
         * @summary Get an overview of all parts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned parts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParts(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPart> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).getParts(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getLastLog() in Part.php to get the last log about the specified part
         * @summary Get last log about the part
         * @param {number} id Id of the part of which you want to get the last log
         * @param {string} [maxDate] Sets the maximal date if required
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetLastLog(id: number, maxDate?: string, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelInventoryPartLog> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).partGetLastLog(id, maxDate, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getPrice() in Part.php to get the price of the specified part
         * @summary Get price of a specified part
         * @param {number} id Id of the part of which you want to get the price
         * @param {number} [contactId] Enter valid contact id here for getting a part contact price
         * @param {string} [contactObjectName] Enter &#x27;Contact&#x27; here for getting a part contact price
         * @param {number} [partUnityId] Enter a valid part unity id here for getting a part unity price
         * @param {string} [partUnityObjectName] Enter &#x27;PartUnity&#x27; here for getting a part unity price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetPrice(id: number, contactId?: number, contactObjectName?: string, partUnityId?: number, partUnityObjectName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).partGetPrice(id, contactId, contactObjectName, partUnityId, partUnityObjectName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getStock() in Part.php to get the stock of the specified part
         * @summary Get stock of the part
         * @param {number} id Id of the part of which you want to get stock
         * @param {string} [maxDate] Sets the maximal date if required. The function will return the stock of the part at the specified date!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetStock(id: number, maxDate?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).partGetStock(id, maxDate, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getStockBefore() in Part.php to get the stock difference of the specified part before the specified date
         * @summary Get stock difference of the part before a specified date
         * @param {number} id Id of the part of which you want to get the stock difference
         * @param {string} [date] You will get the stock difference before this specified date, otherwise the current date will be used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetStockBefore(id: number, date?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).partGetStockBefore(id, date, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PartContactPrice to update a part
         * @summary Update an existing part
         * @param {number} id id of part you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePart(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPart> {
            const localVarFetchArgs = PartApiFetchParamCreator(configuration).updatePart(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PartApi - factory interface
 * @export
 */
export const PartApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Part.php to add a part
         * @summary Create a new part
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPart(options?: any) {
            return PartApiFp(configuration).addPart(options)(fetch, basePath);
        },
        /**
         * Calls book() in Part.php
         * @summary add / remove parts from the stock
         * @param {number} id id of part of which you want to update the stock
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        bookPart(id: number, options?: any) {
            return PartApiFp(configuration).bookPart(id, options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Part.php. Be aware that you can't delete parts which are used somewhere!
         * @summary Delete an existing part
         * @param {number} id id of the part you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePart(id: number, options?: any) {
            return PartApiFp(configuration).deletePart(id, options)(fetch, basePath);
        },
        /**
         * Calls duplicate() in Part.php to duplicate the specified part. Mind that the stock will be zero
         * @summary Duplicate an existing part
         * @param {number} id Id of the part which you want to duplicate
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        duplicatePart(id: number, options?: any) {
            return PartApiFp(configuration).duplicatePart(id, options)(fetch, basePath);
        },
        /**
         * Calls Part.php to get necessary variables.
         * @summary Get an overview of all parts
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned parts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getParts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return PartApiFp(configuration).getParts(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls getLastLog() in Part.php to get the last log about the specified part
         * @summary Get last log about the part
         * @param {number} id Id of the part of which you want to get the last log
         * @param {string} [maxDate] Sets the maximal date if required
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetLastLog(id: number, maxDate?: string, embed?: Array<string>, options?: any) {
            return PartApiFp(configuration).partGetLastLog(id, maxDate, embed, options)(fetch, basePath);
        },
        /**
         * Calls getPrice() in Part.php to get the price of the specified part
         * @summary Get price of a specified part
         * @param {number} id Id of the part of which you want to get the price
         * @param {number} [contactId] Enter valid contact id here for getting a part contact price
         * @param {string} [contactObjectName] Enter &#x27;Contact&#x27; here for getting a part contact price
         * @param {number} [partUnityId] Enter a valid part unity id here for getting a part unity price
         * @param {string} [partUnityObjectName] Enter &#x27;PartUnity&#x27; here for getting a part unity price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetPrice(id: number, contactId?: number, contactObjectName?: string, partUnityId?: number, partUnityObjectName?: string, options?: any) {
            return PartApiFp(configuration).partGetPrice(id, contactId, contactObjectName, partUnityId, partUnityObjectName, options)(fetch, basePath);
        },
        /**
         * Calls getStock() in Part.php to get the stock of the specified part
         * @summary Get stock of the part
         * @param {number} id Id of the part of which you want to get stock
         * @param {string} [maxDate] Sets the maximal date if required. The function will return the stock of the part at the specified date!
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetStock(id: number, maxDate?: string, options?: any) {
            return PartApiFp(configuration).partGetStock(id, maxDate, options)(fetch, basePath);
        },
        /**
         * Calls getStockBefore() in Part.php to get the stock difference of the specified part before the specified date
         * @summary Get stock difference of the part before a specified date
         * @param {number} id Id of the part of which you want to get the stock difference
         * @param {string} [date] You will get the stock difference before this specified date, otherwise the current date will be used
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        partGetStockBefore(id: number, date?: string, options?: any) {
            return PartApiFp(configuration).partGetStockBefore(id, date, options)(fetch, basePath);
        },
        /**
         * Calls PartContactPrice to update a part
         * @summary Update an existing part
         * @param {number} id id of part you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePart(id: number, options?: any) {
            return PartApiFp(configuration).updatePart(id, options)(fetch, basePath);
        },
    };
};

/**
 * PartApi - object-oriented interface
 * @export
 * @class PartApi
 * @extends {BaseAPI}
 */
export class PartApi extends BaseAPI {
    /**
     * Calls Part.php to add a part
     * @summary Create a new part
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public addPart(options?: any) {
        return PartApiFp(this.configuration).addPart(options)(this.fetch, this.basePath);
    }

    /**
     * Calls book() in Part.php
     * @summary add / remove parts from the stock
     * @param {number} id id of part of which you want to update the stock
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public bookPart(id: number, options?: any) {
        return PartApiFp(this.configuration).bookPart(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Part.php. Be aware that you can't delete parts which are used somewhere!
     * @summary Delete an existing part
     * @param {number} id id of the part you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public deletePart(id: number, options?: any) {
        return PartApiFp(this.configuration).deletePart(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls duplicate() in Part.php to duplicate the specified part. Mind that the stock will be zero
     * @summary Duplicate an existing part
     * @param {number} id Id of the part which you want to duplicate
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public duplicatePart(id: number, options?: any) {
        return PartApiFp(this.configuration).duplicatePart(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Part.php to get necessary variables.
     * @summary Get an overview of all parts
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned parts start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public getParts(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return PartApiFp(this.configuration).getParts(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getLastLog() in Part.php to get the last log about the specified part
     * @summary Get last log about the part
     * @param {number} id Id of the part of which you want to get the last log
     * @param {string} [maxDate] Sets the maximal date if required
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public partGetLastLog(id: number, maxDate?: string, embed?: Array<string>, options?: any) {
        return PartApiFp(this.configuration).partGetLastLog(id, maxDate, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getPrice() in Part.php to get the price of the specified part
     * @summary Get price of a specified part
     * @param {number} id Id of the part of which you want to get the price
     * @param {number} [contactId] Enter valid contact id here for getting a part contact price
     * @param {string} [contactObjectName] Enter &#x27;Contact&#x27; here for getting a part contact price
     * @param {number} [partUnityId] Enter a valid part unity id here for getting a part unity price
     * @param {string} [partUnityObjectName] Enter &#x27;PartUnity&#x27; here for getting a part unity price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public partGetPrice(id: number, contactId?: number, contactObjectName?: string, partUnityId?: number, partUnityObjectName?: string, options?: any) {
        return PartApiFp(this.configuration).partGetPrice(id, contactId, contactObjectName, partUnityId, partUnityObjectName, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getStock() in Part.php to get the stock of the specified part
     * @summary Get stock of the part
     * @param {number} id Id of the part of which you want to get stock
     * @param {string} [maxDate] Sets the maximal date if required. The function will return the stock of the part at the specified date!
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public partGetStock(id: number, maxDate?: string, options?: any) {
        return PartApiFp(this.configuration).partGetStock(id, maxDate, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getStockBefore() in Part.php to get the stock difference of the specified part before the specified date
     * @summary Get stock difference of the part before a specified date
     * @param {number} id Id of the part of which you want to get the stock difference
     * @param {string} [date] You will get the stock difference before this specified date, otherwise the current date will be used
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public partGetStockBefore(id: number, date?: string, options?: any) {
        return PartApiFp(this.configuration).partGetStockBefore(id, date, options)(this.fetch, this.basePath);
    }

    /**
     * Calls PartContactPrice to update a part
     * @summary Update an existing part
     * @param {number} id id of part you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartApi
     */
    public updatePart(id: number, options?: any) {
        return PartApiFp(this.configuration).updatePart(id, options)(this.fetch, this.basePath);
    }

}
/**
 * PartContactPriceApi - fetch parameter creator
 * @export
 */
export const PartContactPriceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls PartContactPrice.php to add a part contact price
         * @summary Create a new part contact price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartContactPrice(options: any = {}): FetchArgs {
            const localVarPath = `/PartContactPrice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PartContactPrice.php to delete a part contact price
         * @summary Delete an existing part contact price
         * @param {number} id id of the part contact price you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartContactPrice(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePartContactPrice.');
            }
            const localVarPath = `/PartContactPrice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PartContactPrice.php to get necessary variables.
         * @summary Get an overview of all part contact prices
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part contact prices start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartContactPrices(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/PartContactPrice`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PartContactPrice.php to update a part contact price
         * @summary Update an existing part contact price
         * @param {number} id id of part contact price you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartContactPrice(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePartContactPrice.');
            }
            const localVarPath = `/PartContactPrice/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartContactPriceApi - functional programming interface
 * @export
 */
export const PartContactPriceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls PartContactPrice.php to add a part contact price
         * @summary Create a new part contact price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartContactPrice(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPartContactPrice> {
            const localVarFetchArgs = PartContactPriceApiFetchParamCreator(configuration).addPartContactPrice(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PartContactPrice.php to delete a part contact price
         * @summary Delete an existing part contact price
         * @param {number} id id of the part contact price you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartContactPrice(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartContactPriceApiFetchParamCreator(configuration).deletePartContactPrice(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PartContactPrice.php to get necessary variables.
         * @summary Get an overview of all part contact prices
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part contact prices start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartContactPrices(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPartContactPrice> {
            const localVarFetchArgs = PartContactPriceApiFetchParamCreator(configuration).getPartContactPrices(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PartContactPrice.php to update a part contact price
         * @summary Update an existing part contact price
         * @param {number} id id of part contact price you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartContactPrice(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPartContactPrice> {
            const localVarFetchArgs = PartContactPriceApiFetchParamCreator(configuration).updatePartContactPrice(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PartContactPriceApi - factory interface
 * @export
 */
export const PartContactPriceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls PartContactPrice.php to add a part contact price
         * @summary Create a new part contact price
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartContactPrice(options?: any) {
            return PartContactPriceApiFp(configuration).addPartContactPrice(options)(fetch, basePath);
        },
        /**
         * Calls PartContactPrice.php to delete a part contact price
         * @summary Delete an existing part contact price
         * @param {number} id id of the part contact price you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartContactPrice(id: number, options?: any) {
            return PartContactPriceApiFp(configuration).deletePartContactPrice(id, options)(fetch, basePath);
        },
        /**
         * Calls PartContactPrice.php to get necessary variables.
         * @summary Get an overview of all part contact prices
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part contact prices start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartContactPrices(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return PartContactPriceApiFp(configuration).getPartContactPrices(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls PartContactPrice.php to update a part contact price
         * @summary Update an existing part contact price
         * @param {number} id id of part contact price you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartContactPrice(id: number, options?: any) {
            return PartContactPriceApiFp(configuration).updatePartContactPrice(id, options)(fetch, basePath);
        },
    };
};

/**
 * PartContactPriceApi - object-oriented interface
 * @export
 * @class PartContactPriceApi
 * @extends {BaseAPI}
 */
export class PartContactPriceApi extends BaseAPI {
    /**
     * Calls PartContactPrice.php to add a part contact price
     * @summary Create a new part contact price
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartContactPriceApi
     */
    public addPartContactPrice(options?: any) {
        return PartContactPriceApiFp(this.configuration).addPartContactPrice(options)(this.fetch, this.basePath);
    }

    /**
     * Calls PartContactPrice.php to delete a part contact price
     * @summary Delete an existing part contact price
     * @param {number} id id of the part contact price you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartContactPriceApi
     */
    public deletePartContactPrice(id: number, options?: any) {
        return PartContactPriceApiFp(this.configuration).deletePartContactPrice(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls PartContactPrice.php to get necessary variables.
     * @summary Get an overview of all part contact prices
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned part contact prices start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartContactPriceApi
     */
    public getPartContactPrices(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return PartContactPriceApiFp(this.configuration).getPartContactPrices(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls PartContactPrice.php to update a part contact price
     * @summary Update an existing part contact price
     * @param {number} id id of part contact price you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartContactPriceApi
     */
    public updatePartContactPrice(id: number, options?: any) {
        return PartContactPriceApiFp(this.configuration).updatePartContactPrice(id, options)(this.fetch, this.basePath);
    }

}
/**
 * PartUnityApi - fetch parameter creator
 * @export
 */
export const PartUnityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls PartUnity.php to add a part unity
         * @summary Create a new part unity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartUnity(options: any = {}): FetchArgs {
            const localVarPath = `/PartUnity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PartUnity.php to delete a part unity
         * @summary Delete an existing part unity
         * @param {number} id id of the part unity you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartUnity(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePartUnity.');
            }
            const localVarPath = `/PartUnity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PartUnity.php to get necessary variables.
         * @summary Get an overview of all part unities
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part unities start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartUnities(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/PartUnity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PartUnity.php to update a part unity
         * @summary Update an existing part unity
         * @param {number} id id of part unity you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartUnity(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePartUnity.');
            }
            const localVarPath = `/PartUnity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PartUnityApi - functional programming interface
 * @export
 */
export const PartUnityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls PartUnity.php to add a part unity
         * @summary Create a new part unity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartUnity(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPartUnity> {
            const localVarFetchArgs = PartUnityApiFetchParamCreator(configuration).addPartUnity(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PartUnity.php to delete a part unity
         * @summary Delete an existing part unity
         * @param {number} id id of the part unity you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartUnity(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PartUnityApiFetchParamCreator(configuration).deletePartUnity(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PartUnity.php to get necessary variables.
         * @summary Get an overview of all part unities
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part unities start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartUnities(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPartUnity> {
            const localVarFetchArgs = PartUnityApiFetchParamCreator(configuration).getPartUnities(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PartUnity.php to update a part unity
         * @summary Update an existing part unity
         * @param {number} id id of part unity you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartUnity(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPartUnity> {
            const localVarFetchArgs = PartUnityApiFetchParamCreator(configuration).updatePartUnity(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PartUnityApi - factory interface
 * @export
 */
export const PartUnityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls PartUnity.php to add a part unity
         * @summary Create a new part unity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPartUnity(options?: any) {
            return PartUnityApiFp(configuration).addPartUnity(options)(fetch, basePath);
        },
        /**
         * Calls PartUnity.php to delete a part unity
         * @summary Delete an existing part unity
         * @param {number} id id of the part unity you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePartUnity(id: number, options?: any) {
            return PartUnityApiFp(configuration).deletePartUnity(id, options)(fetch, basePath);
        },
        /**
         * Calls PartUnity.php to get necessary variables.
         * @summary Get an overview of all part unities
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned part unities start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPartUnities(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return PartUnityApiFp(configuration).getPartUnities(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls PartUnity.php to update a part unity
         * @summary Update an existing part unity
         * @param {number} id id of part unity you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePartUnity(id: number, options?: any) {
            return PartUnityApiFp(configuration).updatePartUnity(id, options)(fetch, basePath);
        },
    };
};

/**
 * PartUnityApi - object-oriented interface
 * @export
 * @class PartUnityApi
 * @extends {BaseAPI}
 */
export class PartUnityApi extends BaseAPI {
    /**
     * Calls PartUnity.php to add a part unity
     * @summary Create a new part unity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartUnityApi
     */
    public addPartUnity(options?: any) {
        return PartUnityApiFp(this.configuration).addPartUnity(options)(this.fetch, this.basePath);
    }

    /**
     * Calls PartUnity.php to delete a part unity
     * @summary Delete an existing part unity
     * @param {number} id id of the part unity you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartUnityApi
     */
    public deletePartUnity(id: number, options?: any) {
        return PartUnityApiFp(this.configuration).deletePartUnity(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls PartUnity.php to get necessary variables.
     * @summary Get an overview of all part unities
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned part unities start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartUnityApi
     */
    public getPartUnities(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return PartUnityApiFp(this.configuration).getPartUnities(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls PartUnity.php to update a part unity
     * @summary Update an existing part unity
     * @param {number} id id of part unity you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PartUnityApi
     */
    public updatePartUnity(id: number, options?: any) {
        return PartUnityApiFp(this.configuration).updatePartUnity(id, options)(this.fetch, this.basePath);
    }

}
/**
 * PaymentMethodApi - fetch parameter creator
 * @export
 */
export const PaymentMethodApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls PaymentMethod.php to create a payment method
         * @summary Create a new payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethod(options: any = {}): FetchArgs {
            const localVarPath = `/PaymentMethod`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in PaymentMethod.php
         * @summary Delete an existing payment method
         * @param {number} id id of payment method you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deletePaymentMethod.');
            }
            const localVarPath = `/PaymentMethod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PaymentMethod.php to get necessary variables.
         * @summary Get an overview of all payment methods
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned payment methods start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/PaymentMethod`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls PaymentMethod.php to update a payment method
         * @summary Update an existing payment method
         * @param {number} id id of payment method you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updatePaymentMethod.');
            }
            const localVarPath = `/PaymentMethod/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PaymentMethodApi - functional programming interface
 * @export
 */
export const PaymentMethodApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls PaymentMethod.php to create a payment method
         * @summary Create a new payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethod(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPaymentMethod> {
            const localVarFetchArgs = PaymentMethodApiFetchParamCreator(configuration).addPaymentMethod(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in PaymentMethod.php
         * @summary Delete an existing payment method
         * @param {number} id id of payment method you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = PaymentMethodApiFetchParamCreator(configuration).deletePaymentMethod(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PaymentMethod.php to get necessary variables.
         * @summary Get an overview of all payment methods
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned payment methods start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPaymentMethod> {
            const localVarFetchArgs = PaymentMethodApiFetchParamCreator(configuration).getPaymentMethods(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls PaymentMethod.php to update a payment method
         * @summary Update an existing payment method
         * @param {number} id id of payment method you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPaymentMethod> {
            const localVarFetchArgs = PaymentMethodApiFetchParamCreator(configuration).updatePaymentMethod(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PaymentMethodApi - factory interface
 * @export
 */
export const PaymentMethodApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls PaymentMethod.php to create a payment method
         * @summary Create a new payment method
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addPaymentMethod(options?: any) {
            return PaymentMethodApiFp(configuration).addPaymentMethod(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in PaymentMethod.php
         * @summary Delete an existing payment method
         * @param {number} id id of payment method you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deletePaymentMethod(id: number, options?: any) {
            return PaymentMethodApiFp(configuration).deletePaymentMethod(id, options)(fetch, basePath);
        },
        /**
         * Calls PaymentMethod.php to get necessary variables.
         * @summary Get an overview of all payment methods
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned payment methods start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPaymentMethods(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return PaymentMethodApiFp(configuration).getPaymentMethods(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls PaymentMethod.php to update a payment method
         * @summary Update an existing payment method
         * @param {number} id id of payment method you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updatePaymentMethod(id: number, options?: any) {
            return PaymentMethodApiFp(configuration).updatePaymentMethod(id, options)(fetch, basePath);
        },
    };
};

/**
 * PaymentMethodApi - object-oriented interface
 * @export
 * @class PaymentMethodApi
 * @extends {BaseAPI}
 */
export class PaymentMethodApi extends BaseAPI {
    /**
     * Calls PaymentMethod.php to create a payment method
     * @summary Create a new payment method
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public addPaymentMethod(options?: any) {
        return PaymentMethodApiFp(this.configuration).addPaymentMethod(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in PaymentMethod.php
     * @summary Delete an existing payment method
     * @param {number} id id of payment method you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public deletePaymentMethod(id: number, options?: any) {
        return PaymentMethodApiFp(this.configuration).deletePaymentMethod(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls PaymentMethod.php to get necessary variables.
     * @summary Get an overview of all payment methods
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned payment methods start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public getPaymentMethods(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return PaymentMethodApiFp(this.configuration).getPaymentMethods(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls PaymentMethod.php to update a payment method
     * @summary Update an existing payment method
     * @param {number} id id of payment method you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PaymentMethodApi
     */
    public updatePaymentMethod(id: number, options?: any) {
        return PaymentMethodApiFp(this.configuration).updatePaymentMethod(id, options)(this.fetch, this.basePath);
    }

}
/**
 * PlaceApi - fetch parameter creator
 * @export
 */
export const PlaceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Place.php to get necessary variables.    It is recommended to set limit and offset appropriately as there are over 5000 entries for place!
         * @summary Get an overview of all places
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned places start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaces(limit?: number, offset?: number, options: any = {}): FetchArgs {
            const localVarPath = `/Place`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * PlaceApi - functional programming interface
 * @export
 */
export const PlaceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Place.php to get necessary variables.    It is recommended to set limit and offset appropriately as there are over 5000 entries for place!
         * @summary Get an overview of all places
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned places start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaces(limit?: number, offset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelPlace> {
            const localVarFetchArgs = PlaceApiFetchParamCreator(configuration).getPlaces(limit, offset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * PlaceApi - factory interface
 * @export
 */
export const PlaceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Place.php to get necessary variables.    It is recommended to set limit and offset appropriately as there are over 5000 entries for place!
         * @summary Get an overview of all places
         * @param {number} [limit] Limits the number of entries returned. Default is 1000
         * @param {number} [offset] Set the index where the returned places start. Default is 0
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getPlaces(limit?: number, offset?: number, options?: any) {
            return PlaceApiFp(configuration).getPlaces(limit, offset, options)(fetch, basePath);
        },
    };
};

/**
 * PlaceApi - object-oriented interface
 * @export
 * @class PlaceApi
 * @extends {BaseAPI}
 */
export class PlaceApi extends BaseAPI {
    /**
     * Calls Place.php to get necessary variables.    It is recommended to set limit and offset appropriately as there are over 5000 entries for place!
     * @summary Get an overview of all places
     * @param {number} [limit] Limits the number of entries returned. Default is 1000
     * @param {number} [offset] Set the index where the returned places start. Default is 0
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof PlaceApi
     */
    public getPlaces(limit?: number, offset?: number, options?: any) {
        return PlaceApiFp(this.configuration).getPlaces(limit, offset, options)(this.fetch, this.basePath);
    }

}
/**
 * ReportApi - fetch parameter creator
 * @export
 */
export const ReportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls contact() in Report.php to export the contact.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact
         * @param {boolean} download Specifies if the document is downloaded
         * @param {number} contactId Id of contact which should be exported
         * @param {string} contactObjectName Model name which is exported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContact(download: boolean, contactId: number, contactObjectName: string, options: any = {}): FetchArgs {
            // verify required parameter 'download' is not null or undefined
            if (download === null || download === undefined) {
                throw new RequiredError('download','Required parameter download was null or undefined when calling reportContact.');
            }
            // verify required parameter 'contactId' is not null or undefined
            if (contactId === null || contactId === undefined) {
                throw new RequiredError('contactId','Required parameter contactId was null or undefined when calling reportContact.');
            }
            // verify required parameter 'contactObjectName' is not null or undefined
            if (contactObjectName === null || contactObjectName === undefined) {
                throw new RequiredError('contactObjectName','Required parameter contactObjectName was null or undefined when calling reportContact.');
            }
            const localVarPath = `/Report/contact`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (contactId !== undefined) {
                localVarQueryParameter['contact[id]'] = contactId;
            }

            if (contactObjectName !== undefined) {
                localVarQueryParameter['contact[objectName]'] = contactObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls contactlist() in Report.php to export the contact list.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact list
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported contacts
         * @param {number} [sevQueryOffset] Set the index where the exported contacts start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContactList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling reportContactList.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling reportContactList.');
            }
            const localVarPath = `/Report/contactlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryOffset !== undefined) {
                localVarQueryParameter['sevQuery[offset]'] = sevQueryOffset;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls inventory() in Report.php to export the inventory.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the inventory
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported inventory entries
         * @param {number} [sevQueryOffset] Set the index where the exported parts start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportInventory(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling reportInventory.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling reportInventory.');
            }
            const localVarPath = `/Report/inventory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryOffset !== undefined) {
                localVarQueryParameter['sevQuery[offset]'] = sevQueryOffset;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls invoicelist() in Report.php to export the invoices.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoicelist
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {number} [sevQueryOffset] Set the index where the exported invoices should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportInvoiceList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling reportInvoiceList.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling reportInvoiceList.');
            }
            const localVarPath = `/Report/invoicelist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryOffset !== undefined) {
                localVarQueryParameter['sevQuery[offset]'] = sevQueryOffset;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls orderlist() in Report.php to export the orders.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the order list
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported orders
         * @param {number} [sevQueryOffset] Set the index where the exported orders should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportOrderList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling reportOrderList.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling reportOrderList.');
            }
            const localVarPath = `/Report/orderlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryOffset !== undefined) {
                localVarQueryParameter['sevQuery[offset]'] = sevQueryOffset;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls profitAndLoss() in Report.php to export the profit and loss.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the profit and loss
         * @param {string} startDate Start date of the profit and loss calculation
         * @param {string} endDate End date of the profit and loss calculation
         * @param {boolean} taxRule Specify if you want the net income method or the profit and loss
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportProfitAndLoss(startDate: string, endDate: string, taxRule: boolean, download?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportProfitAndLoss.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportProfitAndLoss.');
            }
            // verify required parameter 'taxRule' is not null or undefined
            if (taxRule === null || taxRule === undefined) {
                throw new RequiredError('taxRule','Required parameter taxRule was null or undefined when calling reportProfitAndLoss.');
            }
            const localVarPath = `/Report/profitAndLoss`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            if (taxRule !== undefined) {
                localVarQueryParameter['taxRule'] = taxRule;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls registerBook() in Report.php to export the register book / cash report.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the register book / cash report
         * @param {number} checkAccountId Check account you want to export
         * @param {string} checkAccountObjectName Check account object name
         * @param {string} startDate Start date of the register book / cash report
         * @param {string} endDate End date of the register book / cash report
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportRegisterBook(checkAccountId: number, checkAccountObjectName: string, startDate: string, endDate: string, download?: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'checkAccountId' is not null or undefined
            if (checkAccountId === null || checkAccountId === undefined) {
                throw new RequiredError('checkAccountId','Required parameter checkAccountId was null or undefined when calling reportRegisterBook.');
            }
            // verify required parameter 'checkAccountObjectName' is not null or undefined
            if (checkAccountObjectName === null || checkAccountObjectName === undefined) {
                throw new RequiredError('checkAccountObjectName','Required parameter checkAccountObjectName was null or undefined when calling reportRegisterBook.');
            }
            // verify required parameter 'startDate' is not null or undefined
            if (startDate === null || startDate === undefined) {
                throw new RequiredError('startDate','Required parameter startDate was null or undefined when calling reportRegisterBook.');
            }
            // verify required parameter 'endDate' is not null or undefined
            if (endDate === null || endDate === undefined) {
                throw new RequiredError('endDate','Required parameter endDate was null or undefined when calling reportRegisterBook.');
            }
            const localVarPath = `/Report/registerBook`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (checkAccountId !== undefined) {
                localVarQueryParameter['checkAccount[id]'] = checkAccountId;
            }

            if (checkAccountObjectName !== undefined) {
                localVarQueryParameter['checkAccount[objectName]'] = checkAccountObjectName;
            }

            if (startDate !== undefined) {
                localVarQueryParameter['startDate'] = startDate;
            }

            if (endDate !== undefined) {
                localVarQueryParameter['endDate'] = endDate;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls voucherlist() in Report.php to export the vouchers.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list
         * @param {string} sevQueryFilterStartDate Start date to filter vouchers with
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {number} [sevQueryOffset] Set the index where the exported vouchers should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportVoucherList(sevQueryFilterStartDate: string, sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options: any = {}): FetchArgs {
            // verify required parameter 'sevQueryFilterStartDate' is not null or undefined
            if (sevQueryFilterStartDate === null || sevQueryFilterStartDate === undefined) {
                throw new RequiredError('sevQueryFilterStartDate','Required parameter sevQueryFilterStartDate was null or undefined when calling reportVoucherList.');
            }
            // verify required parameter 'sevQueryModelName' is not null or undefined
            if (sevQueryModelName === null || sevQueryModelName === undefined) {
                throw new RequiredError('sevQueryModelName','Required parameter sevQueryModelName was null or undefined when calling reportVoucherList.');
            }
            // verify required parameter 'sevQueryObjectName' is not null or undefined
            if (sevQueryObjectName === null || sevQueryObjectName === undefined) {
                throw new RequiredError('sevQueryObjectName','Required parameter sevQueryObjectName was null or undefined when calling reportVoucherList.');
            }
            const localVarPath = `/Report/voucherlist`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (download !== undefined) {
                localVarQueryParameter['download'] = download;
            }

            if (sevQueryFilterStartDate !== undefined) {
                localVarQueryParameter['sevQuery[filter][startDate]'] = sevQueryFilterStartDate;
            }

            if (sevQueryLimit !== undefined) {
                localVarQueryParameter['sevQuery[limit]'] = sevQueryLimit;
            }

            if (sevQueryOffset !== undefined) {
                localVarQueryParameter['sevQuery[offset]'] = sevQueryOffset;
            }

            if (sevQueryModelName !== undefined) {
                localVarQueryParameter['sevQuery[modelName]'] = sevQueryModelName;
            }

            if (sevQueryObjectName !== undefined) {
                localVarQueryParameter['sevQuery[objectName]'] = sevQueryObjectName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * ReportApi - functional programming interface
 * @export
 */
export const ReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls contact() in Report.php to export the contact.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact
         * @param {boolean} download Specifies if the document is downloaded
         * @param {number} contactId Id of contact which should be exported
         * @param {string} contactObjectName Model name which is exported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContact(download: boolean, contactId: number, contactObjectName: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportContact(download, contactId, contactObjectName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls contactlist() in Report.php to export the contact list.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact list
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported contacts
         * @param {number} [sevQueryOffset] Set the index where the exported contacts start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContactList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportContactList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls inventory() in Report.php to export the inventory.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the inventory
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported inventory entries
         * @param {number} [sevQueryOffset] Set the index where the exported parts start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportInventory(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportInventory(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls invoicelist() in Report.php to export the invoices.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoicelist
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {number} [sevQueryOffset] Set the index where the exported invoices should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportInvoiceList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportInvoiceList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls orderlist() in Report.php to export the orders.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the order list
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported orders
         * @param {number} [sevQueryOffset] Set the index where the exported orders should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportOrderList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportOrderList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls profitAndLoss() in Report.php to export the profit and loss.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the profit and loss
         * @param {string} startDate Start date of the profit and loss calculation
         * @param {string} endDate End date of the profit and loss calculation
         * @param {boolean} taxRule Specify if you want the net income method or the profit and loss
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportProfitAndLoss(startDate: string, endDate: string, taxRule: boolean, download?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportProfitAndLoss(startDate, endDate, taxRule, download, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls registerBook() in Report.php to export the register book / cash report.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the register book / cash report
         * @param {number} checkAccountId Check account you want to export
         * @param {string} checkAccountObjectName Check account object name
         * @param {string} startDate Start date of the register book / cash report
         * @param {string} endDate End date of the register book / cash report
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportRegisterBook(checkAccountId: number, checkAccountObjectName: string, startDate: string, endDate: string, download?: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportRegisterBook(checkAccountId, checkAccountObjectName, startDate, endDate, download, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls voucherlist() in Report.php to export the vouchers.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list
         * @param {string} sevQueryFilterStartDate Start date to filter vouchers with
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {number} [sevQueryOffset] Set the index where the exported vouchers should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportVoucherList(sevQueryFilterStartDate: string, sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Blob> {
            const localVarFetchArgs = ReportApiFetchParamCreator(configuration).reportVoucherList(sevQueryFilterStartDate, sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * ReportApi - factory interface
 * @export
 */
export const ReportApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls contact() in Report.php to export the contact.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact
         * @param {boolean} download Specifies if the document is downloaded
         * @param {number} contactId Id of contact which should be exported
         * @param {string} contactObjectName Model name which is exported
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContact(download: boolean, contactId: number, contactObjectName: string, options?: any) {
            return ReportApiFp(configuration).reportContact(download, contactId, contactObjectName, options)(fetch, basePath);
        },
        /**
         * Calls contactlist() in Report.php to export the contact list.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the contact list
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported contacts
         * @param {number} [sevQueryOffset] Set the index where the exported contacts start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportContactList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
            return ReportApiFp(configuration).reportContactList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(fetch, basePath);
        },
        /**
         * Calls inventory() in Report.php to export the inventory.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the inventory
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported inventory entries
         * @param {number} [sevQueryOffset] Set the index where the exported parts start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportInventory(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
            return ReportApiFp(configuration).reportInventory(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(fetch, basePath);
        },
        /**
         * Calls invoicelist() in Report.php to export the invoices.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the invoicelist
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported invoices
         * @param {number} [sevQueryOffset] Set the index where the exported invoices should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportInvoiceList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
            return ReportApiFp(configuration).reportInvoiceList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(fetch, basePath);
        },
        /**
         * Calls orderlist() in Report.php to export the orders.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the order list
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported orders
         * @param {number} [sevQueryOffset] Set the index where the exported orders should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportOrderList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
            return ReportApiFp(configuration).reportOrderList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(fetch, basePath);
        },
        /**
         * Calls profitAndLoss() in Report.php to export the profit and loss.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the profit and loss
         * @param {string} startDate Start date of the profit and loss calculation
         * @param {string} endDate End date of the profit and loss calculation
         * @param {boolean} taxRule Specify if you want the net income method or the profit and loss
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportProfitAndLoss(startDate: string, endDate: string, taxRule: boolean, download?: boolean, options?: any) {
            return ReportApiFp(configuration).reportProfitAndLoss(startDate, endDate, taxRule, download, options)(fetch, basePath);
        },
        /**
         * Calls registerBook() in Report.php to export the register book / cash report.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the register book / cash report
         * @param {number} checkAccountId Check account you want to export
         * @param {string} checkAccountObjectName Check account object name
         * @param {string} startDate Start date of the register book / cash report
         * @param {string} endDate End date of the register book / cash report
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportRegisterBook(checkAccountId: number, checkAccountObjectName: string, startDate: string, endDate: string, download?: boolean, options?: any) {
            return ReportApiFp(configuration).reportRegisterBook(checkAccountId, checkAccountObjectName, startDate, endDate, download, options)(fetch, basePath);
        },
        /**
         * Calls voucherlist() in Report.php to export the vouchers.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
         * @summary Export the voucher list
         * @param {string} sevQueryFilterStartDate Start date to filter vouchers with
         * @param {string} sevQueryModelName Model name which is exported
         * @param {string} sevQueryObjectName SevQuery object name
         * @param {boolean} [download] Specifies if the document is downloaded
         * @param {number} [sevQueryLimit] Limit exported vouchers
         * @param {number} [sevQueryOffset] Set the index where the exported vouchers should start
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        reportVoucherList(sevQueryFilterStartDate: string, sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
            return ReportApiFp(configuration).reportVoucherList(sevQueryFilterStartDate, sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(fetch, basePath);
        },
    };
};

/**
 * ReportApi - object-oriented interface
 * @export
 * @class ReportApi
 * @extends {BaseAPI}
 */
export class ReportApi extends BaseAPI {
    /**
     * Calls contact() in Report.php to export the contact.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the contact
     * @param {boolean} download Specifies if the document is downloaded
     * @param {number} contactId Id of contact which should be exported
     * @param {string} contactObjectName Model name which is exported
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportContact(download: boolean, contactId: number, contactObjectName: string, options?: any) {
        return ReportApiFp(this.configuration).reportContact(download, contactId, contactObjectName, options)(this.fetch, this.basePath);
    }

    /**
     * Calls contactlist() in Report.php to export the contact list.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the contact list
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported contacts
     * @param {number} [sevQueryOffset] Set the index where the exported contacts start
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportContactList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
        return ReportApiFp(this.configuration).reportContactList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls inventory() in Report.php to export the inventory.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the inventory
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported inventory entries
     * @param {number} [sevQueryOffset] Set the index where the exported parts start
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportInventory(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
        return ReportApiFp(this.configuration).reportInventory(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls invoicelist() in Report.php to export the invoices.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the invoicelist
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported invoices
     * @param {number} [sevQueryOffset] Set the index where the exported invoices should start
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportInvoiceList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
        return ReportApiFp(this.configuration).reportInvoiceList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls orderlist() in Report.php to export the orders.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the order list
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported orders
     * @param {number} [sevQueryOffset] Set the index where the exported orders should start
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportOrderList(sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
        return ReportApiFp(this.configuration).reportOrderList(sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(this.fetch, this.basePath);
    }

    /**
     * Calls profitAndLoss() in Report.php to export the profit and loss.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the profit and loss
     * @param {string} startDate Start date of the profit and loss calculation
     * @param {string} endDate End date of the profit and loss calculation
     * @param {boolean} taxRule Specify if you want the net income method or the profit and loss
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportProfitAndLoss(startDate: string, endDate: string, taxRule: boolean, download?: boolean, options?: any) {
        return ReportApiFp(this.configuration).reportProfitAndLoss(startDate, endDate, taxRule, download, options)(this.fetch, this.basePath);
    }

    /**
     * Calls registerBook() in Report.php to export the register book / cash report.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the register book / cash report
     * @param {number} checkAccountId Check account you want to export
     * @param {string} checkAccountObjectName Check account object name
     * @param {string} startDate Start date of the register book / cash report
     * @param {string} endDate End date of the register book / cash report
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportRegisterBook(checkAccountId: number, checkAccountObjectName: string, startDate: string, endDate: string, download?: boolean, options?: any) {
        return ReportApiFp(this.configuration).reportRegisterBook(checkAccountId, checkAccountObjectName, startDate, endDate, download, options)(this.fetch, this.basePath);
    }

    /**
     * Calls voucherlist() in Report.php to export the vouchers.    With **sevQuery[filter][yourFilter]**, you can filter the entries you want to export. For this, just switch 'yourFilter' with some parameter the involved model would normally take.    **Currently there is a problem with swagger understanding return type 'file', so the api will respond accordingly but swagger ui can not display it correctly.**
     * @summary Export the voucher list
     * @param {string} sevQueryFilterStartDate Start date to filter vouchers with
     * @param {string} sevQueryModelName Model name which is exported
     * @param {string} sevQueryObjectName SevQuery object name
     * @param {boolean} [download] Specifies if the document is downloaded
     * @param {number} [sevQueryLimit] Limit exported vouchers
     * @param {number} [sevQueryOffset] Set the index where the exported vouchers should start
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof ReportApi
     */
    public reportVoucherList(sevQueryFilterStartDate: string, sevQueryModelName: string, sevQueryObjectName: string, download?: boolean, sevQueryLimit?: number, sevQueryOffset?: number, options?: any) {
        return ReportApiFp(this.configuration).reportVoucherList(sevQueryFilterStartDate, sevQueryModelName, sevQueryObjectName, download, sevQueryLimit, sevQueryOffset, options)(this.fetch, this.basePath);
    }

}
/**
 * SearchApi - fetch parameter creator
 * @export
 */
export const SearchApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls search() in Search.php to search with a specified term in Contacts, Orders, Invoices, Vouchers, Documents and Parts.    It is also possible to search without defining a model, so sevDesk system operations will also be shown.
         * @summary Search for a specified term
         * @param {string} [embed] 
         * @param {string} [term] Term you want to search
         * @param {Array<string>} [searchType] Specify a type (model) that you want to have searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(embed?: string, term?: string, searchType?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Search/search`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed !== undefined) {
                localVarQueryParameter['embed'] = embed;
            }

            if (term !== undefined) {
                localVarQueryParameter['term'] = term;
            }

            if (searchType) {
                localVarQueryParameter['searchType'] = searchType;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SearchApi - functional programming interface
 * @export
 */
export const SearchApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls search() in Search.php to search with a specified term in Contacts, Orders, Invoices, Vouchers, Documents and Parts.    It is also possible to search without defining a model, so sevDesk system operations will also be shown.
         * @summary Search for a specified term
         * @param {string} [embed] 
         * @param {string} [term] Term you want to search
         * @param {Array<string>} [searchType] Specify a type (model) that you want to have searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(embed?: string, term?: string, searchType?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SearchApiFetchParamCreator(configuration).search(embed, term, searchType, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SearchApi - factory interface
 * @export
 */
export const SearchApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls search() in Search.php to search with a specified term in Contacts, Orders, Invoices, Vouchers, Documents and Parts.    It is also possible to search without defining a model, so sevDesk system operations will also be shown.
         * @summary Search for a specified term
         * @param {string} [embed] 
         * @param {string} [term] Term you want to search
         * @param {Array<string>} [searchType] Specify a type (model) that you want to have searched
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        search(embed?: string, term?: string, searchType?: Array<string>, options?: any) {
            return SearchApiFp(configuration).search(embed, term, searchType, options)(fetch, basePath);
        },
    };
};

/**
 * SearchApi - object-oriented interface
 * @export
 * @class SearchApi
 * @extends {BaseAPI}
 */
export class SearchApi extends BaseAPI {
    /**
     * Calls search() in Search.php to search with a specified term in Contacts, Orders, Invoices, Vouchers, Documents and Parts.    It is also possible to search without defining a model, so sevDesk system operations will also be shown.
     * @summary Search for a specified term
     * @param {string} [embed] 
     * @param {string} [term] Term you want to search
     * @param {Array<string>} [searchType] Specify a type (model) that you want to have searched
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SearchApi
     */
    public search(embed?: string, term?: string, searchType?: Array<string>, options?: any) {
        return SearchApiFp(this.configuration).search(embed, term, searchType, options)(this.fetch, this.basePath);
    }

}
/**
 * SevClientApi - fetch parameter creator
 * @export
 */
export const SevClientApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Get sevDesk account invoices
         * @summary Get sevDesk account invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sevClientGetSevDeskAccountInvoices(options: any = {}): FetchArgs {
            const localVarPath = `/SevClient/getSevDeskAccountInvoices`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SevClientApi - functional programming interface
 * @export
 */
export const SevClientApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Get sevDesk account invoices
         * @summary Get sevDesk account invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sevClientGetSevDeskAccountInvoices(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SevClientApiFetchParamCreator(configuration).sevClientGetSevDeskAccountInvoices(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SevClientApi - factory interface
 * @export
 */
export const SevClientApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Get sevDesk account invoices
         * @summary Get sevDesk account invoices
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sevClientGetSevDeskAccountInvoices(options?: any) {
            return SevClientApiFp(configuration).sevClientGetSevDeskAccountInvoices(options)(fetch, basePath);
        },
    };
};

/**
 * SevClientApi - object-oriented interface
 * @export
 * @class SevClientApi
 * @extends {BaseAPI}
 */
export class SevClientApi extends BaseAPI {
    /**
     * Get sevDesk account invoices
     * @summary Get sevDesk account invoices
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SevClientApi
     */
    public sevClientGetSevDeskAccountInvoices(options?: any) {
        return SevClientApiFp(this.configuration).sevClientGetSevDeskAccountInvoices(options)(this.fetch, this.basePath);
    }

}
/**
 * SevClientConfigApi - fetch parameter creator
 * @export
 */
export const SevClientConfigApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls SevClientConfig.php to get necessary variables.
         * @summary Get an overview of your sevClient config
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevClientConfig(embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/SevClientConfig`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls SevClientConfig.php
         * @summary Update an existing sevClient config
         * @param {number} id Id of sevClient config you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSevClientConfig(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateSevClientConfig.');
            }
            const localVarPath = `/SevClientConfig/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SevClientConfigApi - functional programming interface
 * @export
 */
export const SevClientConfigApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls SevClientConfig.php to get necessary variables.
         * @summary Get an overview of your sevClient config
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevClientConfig(embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSevClientConfig> {
            const localVarFetchArgs = SevClientConfigApiFetchParamCreator(configuration).getSevClientConfig(embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls SevClientConfig.php
         * @summary Update an existing sevClient config
         * @param {number} id Id of sevClient config you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSevClientConfig(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSevClientConfig> {
            const localVarFetchArgs = SevClientConfigApiFetchParamCreator(configuration).updateSevClientConfig(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SevClientConfigApi - factory interface
 * @export
 */
export const SevClientConfigApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls SevClientConfig.php to get necessary variables.
         * @summary Get an overview of your sevClient config
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevClientConfig(embed?: Array<string>, options?: any) {
            return SevClientConfigApiFp(configuration).getSevClientConfig(embed, options)(fetch, basePath);
        },
        /**
         * Calls SevClientConfig.php
         * @summary Update an existing sevClient config
         * @param {number} id Id of sevClient config you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateSevClientConfig(id: number, options?: any) {
            return SevClientConfigApiFp(configuration).updateSevClientConfig(id, options)(fetch, basePath);
        },
    };
};

/**
 * SevClientConfigApi - object-oriented interface
 * @export
 * @class SevClientConfigApi
 * @extends {BaseAPI}
 */
export class SevClientConfigApi extends BaseAPI {
    /**
     * Calls SevClientConfig.php to get necessary variables.
     * @summary Get an overview of your sevClient config
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SevClientConfigApi
     */
    public getSevClientConfig(embed?: Array<string>, options?: any) {
        return SevClientConfigApiFp(this.configuration).getSevClientConfig(embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls SevClientConfig.php
     * @summary Update an existing sevClient config
     * @param {number} id Id of sevClient config you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SevClientConfigApi
     */
    public updateSevClientConfig(id: number, options?: any) {
        return SevClientConfigApiFp(this.configuration).updateSevClientConfig(id, options)(this.fetch, this.basePath);
    }

}
/**
 * SevSequenceApi - fetch parameter creator
 * @export
 */
export const SevSequenceApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls SevSequence.php to get necessary variables.
         * @summary Get an overview of all object sequences
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevSequence(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/SevSequence`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SevSequenceApi - functional programming interface
 * @export
 */
export const SevSequenceApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls SevSequence.php to get necessary variables.
         * @summary Get an overview of all object sequences
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevSequence(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSevSequence> {
            const localVarFetchArgs = SevSequenceApiFetchParamCreator(configuration).getSevSequence(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SevSequenceApi - factory interface
 * @export
 */
export const SevSequenceApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls SevSequence.php to get necessary variables.
         * @summary Get an overview of all object sequences
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevSequence(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return SevSequenceApiFp(configuration).getSevSequence(limit, offset, embed, options)(fetch, basePath);
        },
    };
};

/**
 * SevSequenceApi - object-oriented interface
 * @export
 * @class SevSequenceApi
 * @extends {BaseAPI}
 */
export class SevSequenceApi extends BaseAPI {
    /**
     * Calls SevSequence.php to get necessary variables.
     * @summary Get an overview of all object sequences
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned check accounts start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SevSequenceApi
     */
    public getSevSequence(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return SevSequenceApiFp(this.configuration).getSevSequence(limit, offset, embed, options)(this.fetch, this.basePath);
    }

}
/**
 * SevTokenApi - fetch parameter creator
 * @export
 */
export const SevTokenApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls SevToken.php to get necessary variables.
         * @summary Get an overview of all sevTokens
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sevTokens start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevTokens(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/SevToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SevTokenApi - functional programming interface
 * @export
 */
export const SevTokenApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls SevToken.php to get necessary variables.
         * @summary Get an overview of all sevTokens
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sevTokens start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevTokens(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSevToken> {
            const localVarFetchArgs = SevTokenApiFetchParamCreator(configuration).getSevTokens(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SevTokenApi - factory interface
 * @export
 */
export const SevTokenApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls SevToken.php to get necessary variables.
         * @summary Get an overview of all sevTokens
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned sevTokens start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevTokens(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return SevTokenApiFp(configuration).getSevTokens(limit, offset, embed, options)(fetch, basePath);
        },
    };
};

/**
 * SevTokenApi - object-oriented interface
 * @export
 * @class SevTokenApi
 * @extends {BaseAPI}
 */
export class SevTokenApi extends BaseAPI {
    /**
     * Calls SevToken.php to get necessary variables.
     * @summary Get an overview of all sevTokens
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned sevTokens start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SevTokenApi
     */
    public getSevTokens(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return SevTokenApiFp(this.configuration).getSevTokens(limit, offset, embed, options)(this.fetch, this.basePath);
    }

}
/**
 * SevUserApi - fetch parameter creator
 * @export
 */
export const SevUserApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls SevUser.php to get necessary variables.
         * @summary Get an overview of your sevUser
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevUser(embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/SevUser`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getApiToken() in SevUser.php to get the api token of your user. Be aware that this only works if your sevUser has certain privileges!
         * @summary Get the api token of your user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sevUserGetApiToken(options: any = {}): FetchArgs {
            const localVarPath = `/SevUser/getApiToken`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SevUserApi - functional programming interface
 * @export
 */
export const SevUserApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls SevUser.php to get necessary variables.
         * @summary Get an overview of your sevUser
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevUser(embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSevUser> {
            const localVarFetchArgs = SevUserApiFetchParamCreator(configuration).getSevUser(embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getApiToken() in SevUser.php to get the api token of your user. Be aware that this only works if your sevUser has certain privileges!
         * @summary Get the api token of your user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sevUserGetApiToken(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = SevUserApiFetchParamCreator(configuration).sevUserGetApiToken(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SevUserApi - factory interface
 * @export
 */
export const SevUserApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls SevUser.php to get necessary variables.
         * @summary Get an overview of your sevUser
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSevUser(embed?: Array<string>, options?: any) {
            return SevUserApiFp(configuration).getSevUser(embed, options)(fetch, basePath);
        },
        /**
         * Calls getApiToken() in SevUser.php to get the api token of your user. Be aware that this only works if your sevUser has certain privileges!
         * @summary Get the api token of your user
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        sevUserGetApiToken(options?: any) {
            return SevUserApiFp(configuration).sevUserGetApiToken(options)(fetch, basePath);
        },
    };
};

/**
 * SevUserApi - object-oriented interface
 * @export
 * @class SevUserApi
 * @extends {BaseAPI}
 */
export class SevUserApi extends BaseAPI {
    /**
     * Calls SevUser.php to get necessary variables.
     * @summary Get an overview of your sevUser
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SevUserApi
     */
    public getSevUser(embed?: Array<string>, options?: any) {
        return SevUserApiFp(this.configuration).getSevUser(embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getApiToken() in SevUser.php to get the api token of your user. Be aware that this only works if your sevUser has certain privileges!
     * @summary Get the api token of your user
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SevUserApi
     */
    public sevUserGetApiToken(options?: any) {
        return SevUserApiFp(this.configuration).sevUserGetApiToken(options)(this.fetch, this.basePath);
    }

}
/**
 * StaticCountryApi - fetch parameter creator
 * @export
 */
export const StaticCountryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls StaticCountry.php to return the staticCountry list which is basically the list of countries.
         * @summary Get staticCountry list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticCountry(options: any = {}): FetchArgs {
            const localVarPath = `/StaticCountry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls StaticIndustry.php to return the staticIndustry list which is basically the list of industries.
         * @summary Get staticIndustry list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticIndustry(options: any = {}): FetchArgs {
            const localVarPath = `/StaticIndustry`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaticCountryApi - functional programming interface
 * @export
 */
export const StaticCountryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls StaticCountry.php to return the staticCountry list which is basically the list of countries.
         * @summary Get staticCountry list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticCountry(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StaticCountryApiFetchParamCreator(configuration).getStaticCountry(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls StaticIndustry.php to return the staticIndustry list which is basically the list of industries.
         * @summary Get staticIndustry list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticIndustry(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = StaticCountryApiFetchParamCreator(configuration).getStaticIndustry(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StaticCountryApi - factory interface
 * @export
 */
export const StaticCountryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls StaticCountry.php to return the staticCountry list which is basically the list of countries.
         * @summary Get staticCountry list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticCountry(options?: any) {
            return StaticCountryApiFp(configuration).getStaticCountry(options)(fetch, basePath);
        },
        /**
         * Calls StaticIndustry.php to return the staticIndustry list which is basically the list of industries.
         * @summary Get staticIndustry list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticIndustry(options?: any) {
            return StaticCountryApiFp(configuration).getStaticIndustry(options)(fetch, basePath);
        },
    };
};

/**
 * StaticCountryApi - object-oriented interface
 * @export
 * @class StaticCountryApi
 * @extends {BaseAPI}
 */
export class StaticCountryApi extends BaseAPI {
    /**
     * Calls StaticCountry.php to return the staticCountry list which is basically the list of countries.
     * @summary Get staticCountry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticCountryApi
     */
    public getStaticCountry(options?: any) {
        return StaticCountryApiFp(this.configuration).getStaticCountry(options)(this.fetch, this.basePath);
    }

    /**
     * Calls StaticIndustry.php to return the staticIndustry list which is basically the list of industries.
     * @summary Get staticIndustry list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticCountryApi
     */
    public getStaticIndustry(options?: any) {
        return StaticCountryApiFp(this.configuration).getStaticIndustry(options)(this.fetch, this.basePath);
    }

}
/**
 * StaticReferralProgramApi - fetch parameter creator
 * @export
 */
export const StaticReferralProgramApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls StaticReferralProgram.php to return the staticReferralProgram list which is basically the list of referral programs.
         * @summary Get staticReferralProgram list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticReferralPrograms(options: any = {}): FetchArgs {
            const localVarPath = `/StaticReferralProgram`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * StaticReferralProgramApi - functional programming interface
 * @export
 */
export const StaticReferralProgramApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls StaticReferralProgram.php to return the staticReferralProgram list which is basically the list of referral programs.
         * @summary Get staticReferralProgram list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticReferralPrograms(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelStaticReferralProgram> {
            const localVarFetchArgs = StaticReferralProgramApiFetchParamCreator(configuration).getStaticReferralPrograms(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * StaticReferralProgramApi - factory interface
 * @export
 */
export const StaticReferralProgramApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls StaticReferralProgram.php to return the staticReferralProgram list which is basically the list of referral programs.
         * @summary Get staticReferralProgram list
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getStaticReferralPrograms(options?: any) {
            return StaticReferralProgramApiFp(configuration).getStaticReferralPrograms(options)(fetch, basePath);
        },
    };
};

/**
 * StaticReferralProgramApi - object-oriented interface
 * @export
 * @class StaticReferralProgramApi
 * @extends {BaseAPI}
 */
export class StaticReferralProgramApi extends BaseAPI {
    /**
     * Calls StaticReferralProgram.php to return the staticReferralProgram list which is basically the list of referral programs.
     * @summary Get staticReferralProgram list
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof StaticReferralProgramApi
     */
    public getStaticReferralPrograms(options?: any) {
        return StaticReferralProgramApiFp(this.configuration).getStaticReferralPrograms(options)(this.fetch, this.basePath);
    }

}
/**
 * SubscriptionHistoryApi - fetch parameter creator
 * @export
 */
export const SubscriptionHistoryApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls SubscriptionHistory.php to get necessary variables.
         * @summary Get an overview of your subscription history
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionHistory(embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/SubscriptionHistory`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionHistoryApi - functional programming interface
 * @export
 */
export const SubscriptionHistoryApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls SubscriptionHistory.php to get necessary variables.
         * @summary Get an overview of your subscription history
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionHistory(embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSubscriptionHistory> {
            const localVarFetchArgs = SubscriptionHistoryApiFetchParamCreator(configuration).getSubscriptionHistory(embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionHistoryApi - factory interface
 * @export
 */
export const SubscriptionHistoryApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls SubscriptionHistory.php to get necessary variables.
         * @summary Get an overview of your subscription history
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionHistory(embed?: Array<string>, options?: any) {
            return SubscriptionHistoryApiFp(configuration).getSubscriptionHistory(embed, options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionHistoryApi - object-oriented interface
 * @export
 * @class SubscriptionHistoryApi
 * @extends {BaseAPI}
 */
export class SubscriptionHistoryApi extends BaseAPI {
    /**
     * Calls SubscriptionHistory.php to get necessary variables.
     * @summary Get an overview of your subscription history
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionHistoryApi
     */
    public getSubscriptionHistory(embed?: Array<string>, options?: any) {
        return SubscriptionHistoryApiFp(this.configuration).getSubscriptionHistory(embed, options)(this.fetch, this.basePath);
    }

}
/**
 * SubscriptionTypeApi - fetch parameter creator
 * @export
 */
export const SubscriptionTypeApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls SubscriptionType.php to get necessary variables.
         * @summary Get an overview of all subscription types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypes(options: any = {}): FetchArgs {
            const localVarPath = `/SubscriptionType`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SubscriptionTypeApi - functional programming interface
 * @export
 */
export const SubscriptionTypeApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls SubscriptionType.php to get necessary variables.
         * @summary Get an overview of all subscription types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypes(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSubscriptionType> {
            const localVarFetchArgs = SubscriptionTypeApiFetchParamCreator(configuration).getSubscriptionTypes(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SubscriptionTypeApi - factory interface
 * @export
 */
export const SubscriptionTypeApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls SubscriptionType.php to get necessary variables.
         * @summary Get an overview of all subscription types
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSubscriptionTypes(options?: any) {
            return SubscriptionTypeApiFp(configuration).getSubscriptionTypes(options)(fetch, basePath);
        },
    };
};

/**
 * SubscriptionTypeApi - object-oriented interface
 * @export
 * @class SubscriptionTypeApi
 * @extends {BaseAPI}
 */
export class SubscriptionTypeApi extends BaseAPI {
    /**
     * Calls SubscriptionType.php to get necessary variables.
     * @summary Get an overview of all subscription types
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SubscriptionTypeApi
     */
    public getSubscriptionTypes(options?: any) {
        return SubscriptionTypeApiFp(this.configuration).getSubscriptionTypes(options)(this.fetch, this.basePath);
    }

}
/**
 * SwissEsrApi - fetch parameter creator
 * @export
 */
export const SwissEsrApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls SwissEsr.php to get necessary variables.
         * @summary Get an overview of swiss esr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwissEsr(options: any = {}): FetchArgs {
            const localVarPath = `/SwissEsr`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * SwissEsrApi - functional programming interface
 * @export
 */
export const SwissEsrApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls SwissEsr.php to get necessary variables.
         * @summary Get an overview of swiss esr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwissEsr(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelSwissEsr> {
            const localVarFetchArgs = SwissEsrApiFetchParamCreator(configuration).getSwissEsr(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * SwissEsrApi - factory interface
 * @export
 */
export const SwissEsrApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls SwissEsr.php to get necessary variables.
         * @summary Get an overview of swiss esr
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getSwissEsr(options?: any) {
            return SwissEsrApiFp(configuration).getSwissEsr(options)(fetch, basePath);
        },
    };
};

/**
 * SwissEsrApi - object-oriented interface
 * @export
 * @class SwissEsrApi
 * @extends {BaseAPI}
 */
export class SwissEsrApi extends BaseAPI {
    /**
     * Calls SwissEsr.php to get necessary variables.
     * @summary Get an overview of swiss esr
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof SwissEsrApi
     */
    public getSwissEsr(options?: any) {
        return SwissEsrApiFp(this.configuration).getSwissEsr(options)(this.fetch, this.basePath);
    }

}
/**
 * TagApi - fetch parameter creator
 * @export
 */
export const TagApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Tag.php to create a new tag
         * @summary Create a new tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTag(options: any = {}): FetchArgs {
            const localVarPath = `/Tag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Tag.php
         * @summary Delete an existing tag
         * @param {number} id Id of tag you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTag.');
            }
            const localVarPath = `/Tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Tag.php to get necessary variables.
         * @summary Get an overview of all tags
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tags start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Tag`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Tag.php to update an existing tag
         * @summary Update an existing tag
         * @param {number} id Id of tag you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTag.');
            }
            const localVarPath = `/Tag/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagApi - functional programming interface
 * @export
 */
export const TagApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Tag.php to create a new tag
         * @summary Create a new tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTag(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTag> {
            const localVarFetchArgs = TagApiFetchParamCreator(configuration).addTag(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Tag.php
         * @summary Delete an existing tag
         * @param {number} id Id of tag you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagApiFetchParamCreator(configuration).deleteTag(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Tag.php to get necessary variables.
         * @summary Get an overview of all tags
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tags start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTag> {
            const localVarFetchArgs = TagApiFetchParamCreator(configuration).getTags(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Tag.php to update an existing tag
         * @summary Update an existing tag
         * @param {number} id Id of tag you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTag> {
            const localVarFetchArgs = TagApiFetchParamCreator(configuration).updateTag(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagApi - factory interface
 * @export
 */
export const TagApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Tag.php to create a new tag
         * @summary Create a new tag
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTag(options?: any) {
            return TagApiFp(configuration).addTag(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Tag.php
         * @summary Delete an existing tag
         * @param {number} id Id of tag you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTag(id: number, options?: any) {
            return TagApiFp(configuration).deleteTag(id, options)(fetch, basePath);
        },
        /**
         * Calls Tag.php to get necessary variables.
         * @summary Get an overview of all tags
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tags start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTags(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return TagApiFp(configuration).getTags(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls Tag.php to update an existing tag
         * @summary Update an existing tag
         * @param {number} id Id of tag you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTag(id: number, options?: any) {
            return TagApiFp(configuration).updateTag(id, options)(fetch, basePath);
        },
    };
};

/**
 * TagApi - object-oriented interface
 * @export
 * @class TagApi
 * @extends {BaseAPI}
 */
export class TagApi extends BaseAPI {
    /**
     * Calls Tag.php to create a new tag
     * @summary Create a new tag
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public addTag(options?: any) {
        return TagApiFp(this.configuration).addTag(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Tag.php
     * @summary Delete an existing tag
     * @param {number} id Id of tag you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public deleteTag(id: number, options?: any) {
        return TagApiFp(this.configuration).deleteTag(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Tag.php to get necessary variables.
     * @summary Get an overview of all tags
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned tags start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public getTags(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return TagApiFp(this.configuration).getTags(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Tag.php to update an existing tag
     * @summary Update an existing tag
     * @param {number} id Id of tag you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagApi
     */
    public updateTag(id: number, options?: any) {
        return TagApiFp(this.configuration).updateTag(id, options)(this.fetch, this.basePath);
    }

}
/**
 * TagRelationApi - fetch parameter creator
 * @export
 */
export const TagRelationApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls TagRelation.php to create a new tag
         * @summary Create a new tag relation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagRelation(options: any = {}): FetchArgs {
            const localVarPath = `/TagRelation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in TagRelation.php
         * @summary Delete an existing tag relation
         * @param {number} id Id of tag relation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagRelation(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTagRelation.');
            }
            const localVarPath = `/TagRelation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls TagRelation.php to get necessary variables.
         * @summary Get an overview of all tag relations
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tag relations start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagRelations(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/TagRelation`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls TagRelation.php to update an existing tag
         * @summary Update an existing tag relation
         * @param {number} id Id of tag relation you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagRelation(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTagRelation.');
            }
            const localVarPath = `/TagRelation/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TagRelationApi - functional programming interface
 * @export
 */
export const TagRelationApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls TagRelation.php to create a new tag
         * @summary Create a new tag relation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagRelation(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTagRelation> {
            const localVarFetchArgs = TagRelationApiFetchParamCreator(configuration).addTagRelation(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in TagRelation.php
         * @summary Delete an existing tag relation
         * @param {number} id Id of tag relation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagRelation(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TagRelationApiFetchParamCreator(configuration).deleteTagRelation(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls TagRelation.php to get necessary variables.
         * @summary Get an overview of all tag relations
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tag relations start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagRelations(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTagRelation> {
            const localVarFetchArgs = TagRelationApiFetchParamCreator(configuration).getTagRelations(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls TagRelation.php to update an existing tag
         * @summary Update an existing tag relation
         * @param {number} id Id of tag relation you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagRelation(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTagRelation> {
            const localVarFetchArgs = TagRelationApiFetchParamCreator(configuration).updateTagRelation(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TagRelationApi - factory interface
 * @export
 */
export const TagRelationApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls TagRelation.php to create a new tag
         * @summary Create a new tag relation
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTagRelation(options?: any) {
            return TagRelationApiFp(configuration).addTagRelation(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in TagRelation.php
         * @summary Delete an existing tag relation
         * @param {number} id Id of tag relation you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTagRelation(id: number, options?: any) {
            return TagRelationApiFp(configuration).deleteTagRelation(id, options)(fetch, basePath);
        },
        /**
         * Calls TagRelation.php to get necessary variables.
         * @summary Get an overview of all tag relations
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tag relations start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTagRelations(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return TagRelationApiFp(configuration).getTagRelations(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls TagRelation.php to update an existing tag
         * @summary Update an existing tag relation
         * @param {number} id Id of tag relation you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTagRelation(id: number, options?: any) {
            return TagRelationApiFp(configuration).updateTagRelation(id, options)(fetch, basePath);
        },
    };
};

/**
 * TagRelationApi - object-oriented interface
 * @export
 * @class TagRelationApi
 * @extends {BaseAPI}
 */
export class TagRelationApi extends BaseAPI {
    /**
     * Calls TagRelation.php to create a new tag
     * @summary Create a new tag relation
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagRelationApi
     */
    public addTagRelation(options?: any) {
        return TagRelationApiFp(this.configuration).addTagRelation(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in TagRelation.php
     * @summary Delete an existing tag relation
     * @param {number} id Id of tag relation you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagRelationApi
     */
    public deleteTagRelation(id: number, options?: any) {
        return TagRelationApiFp(this.configuration).deleteTagRelation(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls TagRelation.php to get necessary variables.
     * @summary Get an overview of all tag relations
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned tag relations start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagRelationApi
     */
    public getTagRelations(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return TagRelationApiFp(this.configuration).getTagRelations(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls TagRelation.php to update an existing tag
     * @summary Update an existing tag relation
     * @param {number} id Id of tag relation you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TagRelationApi
     */
    public updateTagRelation(id: number, options?: any) {
        return TagRelationApiFp(this.configuration).updateTagRelation(id, options)(this.fetch, this.basePath);
    }

}
/**
 * TaskApi - fetch parameter creator
 * @export
 */
export const TaskApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Task.php to add a task
         * @summary Create a new task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTask(options: any = {}): FetchArgs {
            const localVarPath = `/Task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TODO: Write backend documentation
         * @summary Delete an existing task
         * @param {number} id id of the task you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTask.');
            }
            const localVarPath = `/Task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Task.php to get necessary variables.
         * @summary Get an overview of all tasks
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tasks start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Task`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Task
         * @param {number} id id of task you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTask.');
            }
            const localVarPath = `/Task/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaskApi - functional programming interface
 * @export
 */
export const TaskApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Task.php to add a task
         * @summary Create a new task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTask(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderPos> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).addTask(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * TODO: Write backend documentation
         * @summary Delete an existing task
         * @param {number} id id of the task you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).deleteTask(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Task.php to get necessary variables.
         * @summary Get an overview of all tasks
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tasks start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTask> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).getTasks(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Task
         * @param {number} id id of task you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTask> {
            const localVarFetchArgs = TaskApiFetchParamCreator(configuration).updateTask(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaskApi - factory interface
 * @export
 */
export const TaskApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Task.php to add a task
         * @summary Create a new task
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTask(options?: any) {
            return TaskApiFp(configuration).addTask(options)(fetch, basePath);
        },
        /**
         * TODO: Write backend documentation
         * @summary Delete an existing task
         * @param {number} id id of the task you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTask(id: number, options?: any) {
            return TaskApiFp(configuration).deleteTask(id, options)(fetch, basePath);
        },
        /**
         * Calls Task.php to get necessary variables.
         * @summary Get an overview of all tasks
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tasks start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTasks(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return TaskApiFp(configuration).getTasks(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Task
         * @param {number} id id of task you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTask(id: number, options?: any) {
            return TaskApiFp(configuration).updateTask(id, options)(fetch, basePath);
        },
    };
};

/**
 * TaskApi - object-oriented interface
 * @export
 * @class TaskApi
 * @extends {BaseAPI}
 */
export class TaskApi extends BaseAPI {
    /**
     * Calls Task.php to add a task
     * @summary Create a new task
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public addTask(options?: any) {
        return TaskApiFp(this.configuration).addTask(options)(this.fetch, this.basePath);
    }

    /**
     * TODO: Write backend documentation
     * @summary Delete an existing task
     * @param {number} id id of the task you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public deleteTask(id: number, options?: any) {
        return TaskApiFp(this.configuration).deleteTask(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Task.php to get necessary variables.
     * @summary Get an overview of all tasks
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned tasks start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public getTasks(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return TaskApiFp(this.configuration).getTasks(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * TODO: Enter short backend documentation here
     * @summary Update an existing Task
     * @param {number} id id of task you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaskApi
     */
    public updateTask(id: number, options?: any) {
        return TaskApiFp(this.configuration).updateTask(id, options)(this.fetch, this.basePath);
    }

}
/**
 * TaxSetApi - fetch parameter creator
 * @export
 */
export const TaxSetApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls TaxSet.php to create a new tax set
         * @summary Create a new tax set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTaxSet(options: any = {}): FetchArgs {
            const localVarPath = `/TaxSet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in TaxSet.php
         * @summary Delete an existing tax set
         * @param {number} id Id of tax set you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxSet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTaxSet.');
            }
            const localVarPath = `/TaxSet/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls TaxSet.php to get necessary variables.
         * @summary Get an overview of all tax sets
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tax sets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxSets(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/TaxSet`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls TaxSet.php to update an existing tax set
         * @summary Update an existing tax set
         * @param {number} id Id of tax set you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxSet(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTaxSet.');
            }
            const localVarPath = `/TaxSet/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TaxSetApi - functional programming interface
 * @export
 */
export const TaxSetApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls TaxSet.php to create a new tax set
         * @summary Create a new tax set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTaxSet(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTaxSet> {
            const localVarFetchArgs = TaxSetApiFetchParamCreator(configuration).addTaxSet(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in TaxSet.php
         * @summary Delete an existing tax set
         * @param {number} id Id of tax set you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxSet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TaxSetApiFetchParamCreator(configuration).deleteTaxSet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls TaxSet.php to get necessary variables.
         * @summary Get an overview of all tax sets
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tax sets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxSets(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTaxSet> {
            const localVarFetchArgs = TaxSetApiFetchParamCreator(configuration).getTaxSets(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls TaxSet.php to update an existing tax set
         * @summary Update an existing tax set
         * @param {number} id Id of tax set you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxSet(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTaxSet> {
            const localVarFetchArgs = TaxSetApiFetchParamCreator(configuration).updateTaxSet(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TaxSetApi - factory interface
 * @export
 */
export const TaxSetApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls TaxSet.php to create a new tax set
         * @summary Create a new tax set
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTaxSet(options?: any) {
            return TaxSetApiFp(configuration).addTaxSet(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in TaxSet.php
         * @summary Delete an existing tax set
         * @param {number} id Id of tax set you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTaxSet(id: number, options?: any) {
            return TaxSetApiFp(configuration).deleteTaxSet(id, options)(fetch, basePath);
        },
        /**
         * Calls TaxSet.php to get necessary variables.
         * @summary Get an overview of all tax sets
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned tax sets start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTaxSets(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return TaxSetApiFp(configuration).getTaxSets(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls TaxSet.php to update an existing tax set
         * @summary Update an existing tax set
         * @param {number} id Id of tax set you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTaxSet(id: number, options?: any) {
            return TaxSetApiFp(configuration).updateTaxSet(id, options)(fetch, basePath);
        },
    };
};

/**
 * TaxSetApi - object-oriented interface
 * @export
 * @class TaxSetApi
 * @extends {BaseAPI}
 */
export class TaxSetApi extends BaseAPI {
    /**
     * Calls TaxSet.php to create a new tax set
     * @summary Create a new tax set
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxSetApi
     */
    public addTaxSet(options?: any) {
        return TaxSetApiFp(this.configuration).addTaxSet(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in TaxSet.php
     * @summary Delete an existing tax set
     * @param {number} id Id of tax set you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxSetApi
     */
    public deleteTaxSet(id: number, options?: any) {
        return TaxSetApiFp(this.configuration).deleteTaxSet(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls TaxSet.php to get necessary variables.
     * @summary Get an overview of all tax sets
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned tax sets start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxSetApi
     */
    public getTaxSets(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return TaxSetApiFp(this.configuration).getTaxSets(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls TaxSet.php to update an existing tax set
     * @summary Update an existing tax set
     * @param {number} id Id of tax set you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TaxSetApi
     */
    public updateTaxSet(id: number, options?: any) {
        return TaxSetApiFp(this.configuration).updateTaxSet(id, options)(this.fetch, this.basePath);
    }

}
/**
 * TextTemplateApi - fetch parameter creator
 * @export
 */
export const TextTemplateApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls TextTemplate.php to create a new text template
         * @summary Create a new text template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTextTemplate(options: any = {}): FetchArgs {
            const localVarPath = `/TextTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls TextTemplate.php to delete a text template
         * @summary Delete an existing text template
         * @param {number} id Id of text template you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTextTemplate(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteTextTemplate.');
            }
            const localVarPath = `/TextTemplate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls TextTemplate.php to get necessary variables.
         * @summary Get an overview of all text template
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned text templates start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextTemplate(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/TextTemplate`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls TextTemplate.php to update an existing text template
         * @summary Update an existing text template
         * @param {number} id Id of text template you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextTemplate(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateTextTemplate.');
            }
            const localVarPath = `/TextTemplate/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * TextTemplateApi - functional programming interface
 * @export
 */
export const TextTemplateApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls TextTemplate.php to create a new text template
         * @summary Create a new text template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTextTemplate(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTextTemplate> {
            const localVarFetchArgs = TextTemplateApiFetchParamCreator(configuration).addTextTemplate(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls TextTemplate.php to delete a text template
         * @summary Delete an existing text template
         * @param {number} id Id of text template you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTextTemplate(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = TextTemplateApiFetchParamCreator(configuration).deleteTextTemplate(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls TextTemplate.php to get necessary variables.
         * @summary Get an overview of all text template
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned text templates start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextTemplate(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTextTemplate> {
            const localVarFetchArgs = TextTemplateApiFetchParamCreator(configuration).getTextTemplate(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls TextTemplate.php to update an existing text template
         * @summary Update an existing text template
         * @param {number} id Id of text template you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextTemplate(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelTextTemplate> {
            const localVarFetchArgs = TextTemplateApiFetchParamCreator(configuration).updateTextTemplate(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * TextTemplateApi - factory interface
 * @export
 */
export const TextTemplateApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls TextTemplate.php to create a new text template
         * @summary Create a new text template
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addTextTemplate(options?: any) {
            return TextTemplateApiFp(configuration).addTextTemplate(options)(fetch, basePath);
        },
        /**
         * Calls TextTemplate.php to delete a text template
         * @summary Delete an existing text template
         * @param {number} id Id of text template you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteTextTemplate(id: number, options?: any) {
            return TextTemplateApiFp(configuration).deleteTextTemplate(id, options)(fetch, basePath);
        },
        /**
         * Calls TextTemplate.php to get necessary variables.
         * @summary Get an overview of all text template
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned text templates start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getTextTemplate(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return TextTemplateApiFp(configuration).getTextTemplate(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls TextTemplate.php to update an existing text template
         * @summary Update an existing text template
         * @param {number} id Id of text template you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateTextTemplate(id: number, options?: any) {
            return TextTemplateApiFp(configuration).updateTextTemplate(id, options)(fetch, basePath);
        },
    };
};

/**
 * TextTemplateApi - object-oriented interface
 * @export
 * @class TextTemplateApi
 * @extends {BaseAPI}
 */
export class TextTemplateApi extends BaseAPI {
    /**
     * Calls TextTemplate.php to create a new text template
     * @summary Create a new text template
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTemplateApi
     */
    public addTextTemplate(options?: any) {
        return TextTemplateApiFp(this.configuration).addTextTemplate(options)(this.fetch, this.basePath);
    }

    /**
     * Calls TextTemplate.php to delete a text template
     * @summary Delete an existing text template
     * @param {number} id Id of text template you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTemplateApi
     */
    public deleteTextTemplate(id: number, options?: any) {
        return TextTemplateApiFp(this.configuration).deleteTextTemplate(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls TextTemplate.php to get necessary variables.
     * @summary Get an overview of all text template
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned text templates start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTemplateApi
     */
    public getTextTemplate(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return TextTemplateApiFp(this.configuration).getTextTemplate(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls TextTemplate.php to update an existing text template
     * @summary Update an existing text template
     * @param {number} id Id of text template you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof TextTemplateApi
     */
    public updateTextTemplate(id: number, options?: any) {
        return TextTemplateApiFp(this.configuration).updateTextTemplate(id, options)(this.fetch, this.basePath);
    }

}
/**
 * UnityApi - fetch parameter creator
 * @export
 */
export const UnityApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Unity.php to add an unity
         * @summary Create a new unity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUnity(options: any = {}): FetchArgs {
            const localVarPath = `/Unity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Unity.php. Be aware that you can't delete unities which are used somewhere!
         * @summary Delete an existing unity
         * @param {number} id id of the unity you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnity(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteUnity.');
            }
            const localVarPath = `/Unity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Unity.php to get necessary variables.
         * @summary Get an overview of all unities
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned unities start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnities(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Unity`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Unity
         * @param {number} id id of unity you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnity(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateUnity.');
            }
            const localVarPath = `/Unity/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * UnityApi - functional programming interface
 * @export
 */
export const UnityApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Unity.php to add an unity
         * @summary Create a new unity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUnity(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelOrderPos> {
            const localVarFetchArgs = UnityApiFetchParamCreator(configuration).addUnity(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Unity.php. Be aware that you can't delete unities which are used somewhere!
         * @summary Delete an existing unity
         * @param {number} id id of the unity you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnity(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = UnityApiFetchParamCreator(configuration).deleteUnity(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Unity.php to get necessary variables.
         * @summary Get an overview of all unities
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned unities start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnities(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelUnity> {
            const localVarFetchArgs = UnityApiFetchParamCreator(configuration).getUnities(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Unity
         * @param {number} id id of unity you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnity(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelUnity> {
            const localVarFetchArgs = UnityApiFetchParamCreator(configuration).updateUnity(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * UnityApi - factory interface
 * @export
 */
export const UnityApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Unity.php to add an unity
         * @summary Create a new unity
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addUnity(options?: any) {
            return UnityApiFp(configuration).addUnity(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Unity.php. Be aware that you can't delete unities which are used somewhere!
         * @summary Delete an existing unity
         * @param {number} id id of the unity you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteUnity(id: number, options?: any) {
            return UnityApiFp(configuration).deleteUnity(id, options)(fetch, basePath);
        },
        /**
         * Calls Unity.php to get necessary variables.
         * @summary Get an overview of all unities
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned unities start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getUnities(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return UnityApiFp(configuration).getUnities(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * TODO: Enter short backend documentation here
         * @summary Update an existing Unity
         * @param {number} id id of unity you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateUnity(id: number, options?: any) {
            return UnityApiFp(configuration).updateUnity(id, options)(fetch, basePath);
        },
    };
};

/**
 * UnityApi - object-oriented interface
 * @export
 * @class UnityApi
 * @extends {BaseAPI}
 */
export class UnityApi extends BaseAPI {
    /**
     * Calls Unity.php to add an unity
     * @summary Create a new unity
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnityApi
     */
    public addUnity(options?: any) {
        return UnityApiFp(this.configuration).addUnity(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Unity.php. Be aware that you can't delete unities which are used somewhere!
     * @summary Delete an existing unity
     * @param {number} id id of the unity you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnityApi
     */
    public deleteUnity(id: number, options?: any) {
        return UnityApiFp(this.configuration).deleteUnity(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Unity.php to get necessary variables.
     * @summary Get an overview of all unities
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned unities start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnityApi
     */
    public getUnities(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return UnityApiFp(this.configuration).getUnities(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * TODO: Enter short backend documentation here
     * @summary Update an existing Unity
     * @param {number} id id of unity you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof UnityApi
     */
    public updateUnity(id: number, options?: any) {
        return UnityApiFp(this.configuration).updateUnity(id, options)(this.fetch, this.basePath);
    }

}
/**
 * VatReportApi - fetch parameter creator
 * @export
 */
export const VatReportApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls VatReport.php to get necessary variables.
         * @summary Get a vat report for a defined period of time
         * @param {number} reportingYear Year for which you want to have a vat report
         * @param {string} reportingPeriodCode Define the period for your vat report
         * @param {boolean} noActualTaxationOnInputTax Define if you want actual taxation on input tax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatReport(reportingYear: number, reportingPeriodCode: string, noActualTaxationOnInputTax: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'reportingYear' is not null or undefined
            if (reportingYear === null || reportingYear === undefined) {
                throw new RequiredError('reportingYear','Required parameter reportingYear was null or undefined when calling getVatReport.');
            }
            // verify required parameter 'reportingPeriodCode' is not null or undefined
            if (reportingPeriodCode === null || reportingPeriodCode === undefined) {
                throw new RequiredError('reportingPeriodCode','Required parameter reportingPeriodCode was null or undefined when calling getVatReport.');
            }
            // verify required parameter 'noActualTaxationOnInputTax' is not null or undefined
            if (noActualTaxationOnInputTax === null || noActualTaxationOnInputTax === undefined) {
                throw new RequiredError('noActualTaxationOnInputTax','Required parameter noActualTaxationOnInputTax was null or undefined when calling getVatReport.');
            }
            const localVarPath = `/VatReport`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (reportingYear !== undefined) {
                localVarQueryParameter['reportingYear'] = reportingYear;
            }

            if (reportingPeriodCode !== undefined) {
                localVarQueryParameter['reportingPeriodCode'] = reportingPeriodCode;
            }

            if (noActualTaxationOnInputTax !== undefined) {
                localVarQueryParameter['noActualTaxationOnInputTax'] = noActualTaxationOnInputTax;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VatReportApi - functional programming interface
 * @export
 */
export const VatReportApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls VatReport.php to get necessary variables.
         * @summary Get a vat report for a defined period of time
         * @param {number} reportingYear Year for which you want to have a vat report
         * @param {string} reportingPeriodCode Define the period for your vat report
         * @param {boolean} noActualTaxationOnInputTax Define if you want actual taxation on input tax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatReport(reportingYear: number, reportingPeriodCode: string, noActualTaxationOnInputTax: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VatReportApiFetchParamCreator(configuration).getVatReport(reportingYear, reportingPeriodCode, noActualTaxationOnInputTax, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VatReportApi - factory interface
 * @export
 */
export const VatReportApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls VatReport.php to get necessary variables.
         * @summary Get a vat report for a defined period of time
         * @param {number} reportingYear Year for which you want to have a vat report
         * @param {string} reportingPeriodCode Define the period for your vat report
         * @param {boolean} noActualTaxationOnInputTax Define if you want actual taxation on input tax
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVatReport(reportingYear: number, reportingPeriodCode: string, noActualTaxationOnInputTax: boolean, options?: any) {
            return VatReportApiFp(configuration).getVatReport(reportingYear, reportingPeriodCode, noActualTaxationOnInputTax, options)(fetch, basePath);
        },
    };
};

/**
 * VatReportApi - object-oriented interface
 * @export
 * @class VatReportApi
 * @extends {BaseAPI}
 */
export class VatReportApi extends BaseAPI {
    /**
     * Calls VatReport.php to get necessary variables.
     * @summary Get a vat report for a defined period of time
     * @param {number} reportingYear Year for which you want to have a vat report
     * @param {string} reportingPeriodCode Define the period for your vat report
     * @param {boolean} noActualTaxationOnInputTax Define if you want actual taxation on input tax
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VatReportApi
     */
    public getVatReport(reportingYear: number, reportingPeriodCode: string, noActualTaxationOnInputTax: boolean, options?: any) {
        return VatReportApiFp(this.configuration).getVatReport(reportingYear, reportingPeriodCode, noActualTaxationOnInputTax, options)(this.fetch, this.basePath);
    }

}
/**
 * VoucherApi - fetch parameter creator
 * @export
 */
export const VoucherApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls Voucher.php to create a voucher
         * @summary Create a new voucher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucher(options: any = {}): FetchArgs {
            const localVarPath = `/Voucher`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in Voucher.php
         * @summary Delete an existing voucher
         * @param {number} id Id of voucher you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucher(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteVoucher.');
            }
            const localVarPath = `/Voucher/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Voucher.php to get necessary variables.
         * @summary Get an overview of all vouchers
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned vouchers start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchers(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/Voucher`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
         * @summary Create a new voucher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveVoucher(options: any = {}): FetchArgs {
            const localVarPath = `/Voucher/Factory/saveVoucher`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Voucher.php to update an existing voucher
         * @summary Update an existing voucher
         * @param {number} id Id of the voucher you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucher(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateVoucher.');
            }
            const localVarPath = `/Voucher/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Book an amount for the specified voucher
         * @summary Book an amount for a specified voucher
         * @param {number} id Id of the voucher for which you want to book an amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherBookAmount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherBookAmount.');
            }
            const localVarPath = `/Voucher/{id}/bookAmmount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Change the status of the specified voucher
         * @summary Change status of a specified voucher
         * @param {number} id Id of the voucher of which you want to change the status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherChangeStatus(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherChangeStatus.');
            }
            const localVarPath = `/Voucher/{id}/changeStatus`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the deleteDocument() function in Voucher.php to delete the document of an existing voucher
         * @summary Delete the document of an existing voucher
         * @param {number} id Id of the voucher of which you want to delete the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherDeleteDocument(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherDeleteDocument.');
            }
            const localVarPath = `/Voucher/{id}/deleteDocument`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls extractThumb() in Voucher/Factory.php to extract the thumb of the specified file
         * @summary Extract file thumb
         * @param {string} [fileName] Name of the file of which you want to extract the thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherExtractThumb(fileName?: string, options: any = {}): FetchArgs {
            const localVarPath = `/Voucher/Factory/extractThumb`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (fileName !== undefined) {
                localVarQueryParameter['fileName'] = fileName;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAccountingTypes() in Voucher.php to get the accounting types of the specified voucher
         * @summary Get the accounting types of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the accounting types
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetAccountingTypes(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetAccountingTypes.');
            }
            const localVarPath = `/Voucher/{id}/getAccountingTypes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCheckAccountTransactionLogs() in Voucher.php to get the check account transaction logs of the specified voucher
         * @summary Get the check account transaction logs of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the check account transaction logs
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetCheckAccountTransactionLogs.');
            }
            const localVarPath = `/Voucher/{id}/getCheckAccountTransactionLogs`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCheckAccountTransactions() in Voucher.php to get the check account transactions of the specified voucher
         * @summary Get the check account transactions of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the check account transactions
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCheckAccountTransactions(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetCheckAccountTransactions.');
            }
            const localVarPath = `/Voucher/{id}/getCheckAccountTransactions`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getCurrency() in Voucher.php to get the currency of the specified voucher
         * @summary Get the currency of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCurrency(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetCurrency.');
            }
            const localVarPath = `/Voucher/{id}/getCurrency`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDebit() in Voucher.php to get the unpaid amount of a specified voucher
         * @summary Get unpaid amount of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the unpaid amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDebit(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetDebit.');
            }
            const localVarPath = `/Voucher/{id}/getDebit`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDelinquent() in Voucher.php to get if the voucher is delinquent
         * @summary Return if the voucher is delinquent
         * @param {number} id Id of the voucher of which you want to know if it is delinquent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDelinquent(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetDelinquent.');
            }
            const localVarPath = `/Voucher/{id}/getDelinquent`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDependingRecurringVouchers() in Voucher.php to get the depending recurring vouchers of the specified origin voucher
         * @summary Get the depending recurring vouchers of a specified origin voucher
         * @param {number} id Id of the voucher of which you want to get the depending recurring vouchers
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDependingRecurringVouchers(id: number, embed?: Array<string>, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetDependingRecurringVouchers.');
            }
            const localVarPath = `/Voucher/{id}/getDependingRecurringVouchers`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getDocumentImage() in Voucher.php to return the base64 encoded preview content of the vouchers document
         * @summary Returns the base64 encoded preview content of the vouchers document
         * @param {number} id Id of the voucher of which you want to get the document image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDocumentImage(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetDocumentImage.');
            }
            const localVarPath = `/Voucher/{id}/getDocumentImage`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls Voucher.php to get necessary variables.
         * @summary Get an overview of all vouchers
         * @param {number} id Id of the voucher you want to update
         * @param {boolean} showTotalSum Define if you want to have the total sum of each tax group
         * @param {boolean} withCorrections Define if you want to have the total sum with corrections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetTaxGroups(id: number, showTotalSum: boolean, withCorrections: boolean, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherGetTaxGroups.');
            }
            // verify required parameter 'showTotalSum' is not null or undefined
            if (showTotalSum === null || showTotalSum === undefined) {
                throw new RequiredError('showTotalSum','Required parameter showTotalSum was null or undefined when calling voucherGetTaxGroups.');
            }
            // verify required parameter 'withCorrections' is not null or undefined
            if (withCorrections === null || withCorrections === undefined) {
                throw new RequiredError('withCorrections','Required parameter withCorrections was null or undefined when calling voucherGetTaxGroups.');
            }
            const localVarPath = `/Voucher/{id}/getTaxGroupes`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (showTotalSum !== undefined) {
                localVarQueryParameter['showTotalSum'] = showTotalSum;
            }

            if (withCorrections !== undefined) {
                localVarQueryParameter['withCorrections'] = withCorrections;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark the specified voucher as open
         * @summary Mark a specified voucher as open
         * @param {number} id Id of the voucher you want to mark as open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherMarkAsOpen(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherMarkAsOpen.');
            }
            const localVarPath = `/Voucher/{id}/markAsOpen`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Mark the specified voucher as paid
         * @summary Mark a specified voucher as paid
         * @param {number} id Id of the voucher you want to mark as paid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherMarkAsPaid(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherMarkAsPaid.');
            }
            const localVarPath = `/Voucher/{id}/markAsPaid`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Refund an amount for the specified voucher
         * @summary Refund an amount for a specified voucher
         * @param {number} id Id of the voucher for which you want to refund an amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherRefundAmount(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherRefundAmount.');
            }
            const localVarPath = `/Voucher/{id}/refundAmmount`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
         * @summary Upload a temporary file to be used later
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherUploadTempFile(file: Blob, options: any = {}): FetchArgs {
            // verify required parameter 'file' is not null or undefined
            if (file === null || file === undefined) {
                throw new RequiredError('file','Required parameter file was null or undefined when calling voucherUploadTempFile.');
            }
            const localVarPath = `/Voucher/Factory/uploadTempFile`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;
            const localVarFormParams = new url.URLSearchParams();

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (file !== undefined) {
                localVarFormParams.set('file', file as any);
            }

            localVarHeaderParameter['Content-Type'] = 'application/x-www-form-urlencoded';

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);
            localVarRequestOptions.body = localVarFormParams.toString();

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoucherApi - functional programming interface
 * @export
 */
export const VoucherApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls Voucher.php to create a voucher
         * @summary Create a new voucher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucher(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucher> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).addVoucher(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in Voucher.php
         * @summary Delete an existing voucher
         * @param {number} id Id of voucher you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucher(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).deleteVoucher(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Voucher.php to get necessary variables.
         * @summary Get an overview of all vouchers
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned vouchers start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchers(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucher> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).getVouchers(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
         * @summary Create a new voucher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveVoucher(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherFactory> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).saveVoucher(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Voucher.php to update an existing voucher
         * @summary Update an existing voucher
         * @param {number} id Id of the voucher you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucher(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucher> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).updateVoucher(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Book an amount for the specified voucher
         * @summary Book an amount for a specified voucher
         * @param {number} id Id of the voucher for which you want to book an amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherBookAmount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherBookAmount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Change the status of the specified voucher
         * @summary Change status of a specified voucher
         * @param {number} id Id of the voucher of which you want to change the status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherChangeStatus(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherChangeStatus(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the deleteDocument() function in Voucher.php to delete the document of an existing voucher
         * @summary Delete the document of an existing voucher
         * @param {number} id Id of the voucher of which you want to delete the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherDeleteDocument(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherDeleteDocument(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls extractThumb() in Voucher/Factory.php to extract the thumb of the specified file
         * @summary Extract file thumb
         * @param {string} [fileName] Name of the file of which you want to extract the thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherExtractThumb(fileName?: string, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherExtractThumb(fileName, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAccountingTypes() in Voucher.php to get the accounting types of the specified voucher
         * @summary Get the accounting types of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the accounting types
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetAccountingTypes(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAccountingType> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetAccountingTypes(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCheckAccountTransactionLogs() in Voucher.php to get the check account transaction logs of the specified voucher
         * @summary Get the check account transaction logs of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the check account transaction logs
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetCheckAccountTransactionLogs(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCheckAccountTransactions() in Voucher.php to get the check account transactions of the specified voucher
         * @summary Get the check account transactions of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the check account transactions
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCheckAccountTransactions(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetCheckAccountTransactions(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getCurrency() in Voucher.php to get the currency of the specified voucher
         * @summary Get the currency of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCurrency(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetCurrency(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDebit() in Voucher.php to get the unpaid amount of a specified voucher
         * @summary Get unpaid amount of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the unpaid amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDebit(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetDebit(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDelinquent() in Voucher.php to get if the voucher is delinquent
         * @summary Return if the voucher is delinquent
         * @param {number} id Id of the voucher of which you want to know if it is delinquent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDelinquent(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetDelinquent(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDependingRecurringVouchers() in Voucher.php to get the depending recurring vouchers of the specified origin voucher
         * @summary Get the depending recurring vouchers of a specified origin voucher
         * @param {number} id Id of the voucher of which you want to get the depending recurring vouchers
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDependingRecurringVouchers(id: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucher> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetDependingRecurringVouchers(id, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getDocumentImage() in Voucher.php to return the base64 encoded preview content of the vouchers document
         * @summary Returns the base64 encoded preview content of the vouchers document
         * @param {number} id Id of the voucher of which you want to get the document image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDocumentImage(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetDocumentImage(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls Voucher.php to get necessary variables.
         * @summary Get an overview of all vouchers
         * @param {number} id Id of the voucher you want to update
         * @param {boolean} showTotalSum Define if you want to have the total sum of each tax group
         * @param {boolean} withCorrections Define if you want to have the total sum with corrections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetTaxGroups(id: number, showTotalSum: boolean, withCorrections: boolean, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherGetTaxGroups(id, showTotalSum, withCorrections, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mark the specified voucher as open
         * @summary Mark a specified voucher as open
         * @param {number} id Id of the voucher you want to mark as open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherMarkAsOpen(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucher> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherMarkAsOpen(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Mark the specified voucher as paid
         * @summary Mark a specified voucher as paid
         * @param {number} id Id of the voucher you want to mark as paid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherMarkAsPaid(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucher> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherMarkAsPaid(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Refund an amount for the specified voucher
         * @summary Refund an amount for a specified voucher
         * @param {number} id Id of the voucher for which you want to refund an amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherRefundAmount(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherLog> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherRefundAmount(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
         * @summary Upload a temporary file to be used later
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherUploadTempFile(file: Blob, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherFactory> {
            const localVarFetchArgs = VoucherApiFetchParamCreator(configuration).voucherUploadTempFile(file, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VoucherApi - factory interface
 * @export
 */
export const VoucherApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls Voucher.php to create a voucher
         * @summary Create a new voucher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucher(options?: any) {
            return VoucherApiFp(configuration).addVoucher(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in Voucher.php
         * @summary Delete an existing voucher
         * @param {number} id Id of voucher you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucher(id: number, options?: any) {
            return VoucherApiFp(configuration).deleteVoucher(id, options)(fetch, basePath);
        },
        /**
         * Calls Voucher.php to get necessary variables.
         * @summary Get an overview of all vouchers
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned vouchers start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVouchers(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return VoucherApiFp(configuration).getVouchers(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
         * @summary Create a new voucher
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        saveVoucher(options?: any) {
            return VoucherApiFp(configuration).saveVoucher(options)(fetch, basePath);
        },
        /**
         * Calls Voucher.php to update an existing voucher
         * @summary Update an existing voucher
         * @param {number} id Id of the voucher you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucher(id: number, options?: any) {
            return VoucherApiFp(configuration).updateVoucher(id, options)(fetch, basePath);
        },
        /**
         * Book an amount for the specified voucher
         * @summary Book an amount for a specified voucher
         * @param {number} id Id of the voucher for which you want to book an amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherBookAmount(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherBookAmount(id, options)(fetch, basePath);
        },
        /**
         * Change the status of the specified voucher
         * @summary Change status of a specified voucher
         * @param {number} id Id of the voucher of which you want to change the status
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherChangeStatus(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherChangeStatus(id, options)(fetch, basePath);
        },
        /**
         * Calls the deleteDocument() function in Voucher.php to delete the document of an existing voucher
         * @summary Delete the document of an existing voucher
         * @param {number} id Id of the voucher of which you want to delete the document
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherDeleteDocument(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherDeleteDocument(id, options)(fetch, basePath);
        },
        /**
         * Calls extractThumb() in Voucher/Factory.php to extract the thumb of the specified file
         * @summary Extract file thumb
         * @param {string} [fileName] Name of the file of which you want to extract the thumb
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherExtractThumb(fileName?: string, options?: any) {
            return VoucherApiFp(configuration).voucherExtractThumb(fileName, options)(fetch, basePath);
        },
        /**
         * Calls getAccountingTypes() in Voucher.php to get the accounting types of the specified voucher
         * @summary Get the accounting types of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the accounting types
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetAccountingTypes(id: number, embed?: Array<string>, options?: any) {
            return VoucherApiFp(configuration).voucherGetAccountingTypes(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getCheckAccountTransactionLogs() in Voucher.php to get the check account transaction logs of the specified voucher
         * @summary Get the check account transaction logs of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the check account transaction logs
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options?: any) {
            return VoucherApiFp(configuration).voucherGetCheckAccountTransactionLogs(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getCheckAccountTransactions() in Voucher.php to get the check account transactions of the specified voucher
         * @summary Get the check account transactions of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the check account transactions
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCheckAccountTransactions(id: number, embed?: Array<string>, options?: any) {
            return VoucherApiFp(configuration).voucherGetCheckAccountTransactions(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getCurrency() in Voucher.php to get the currency of the specified voucher
         * @summary Get the currency of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the currency
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetCurrency(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherGetCurrency(id, options)(fetch, basePath);
        },
        /**
         * Calls getDebit() in Voucher.php to get the unpaid amount of a specified voucher
         * @summary Get unpaid amount of a specified voucher
         * @param {number} id Id of the voucher of which you want to get the unpaid amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDebit(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherGetDebit(id, options)(fetch, basePath);
        },
        /**
         * Calls getDelinquent() in Voucher.php to get if the voucher is delinquent
         * @summary Return if the voucher is delinquent
         * @param {number} id Id of the voucher of which you want to know if it is delinquent
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDelinquent(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherGetDelinquent(id, options)(fetch, basePath);
        },
        /**
         * Calls getDependingRecurringVouchers() in Voucher.php to get the depending recurring vouchers of the specified origin voucher
         * @summary Get the depending recurring vouchers of a specified origin voucher
         * @param {number} id Id of the voucher of which you want to get the depending recurring vouchers
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDependingRecurringVouchers(id: number, embed?: Array<string>, options?: any) {
            return VoucherApiFp(configuration).voucherGetDependingRecurringVouchers(id, embed, options)(fetch, basePath);
        },
        /**
         * Calls getDocumentImage() in Voucher.php to return the base64 encoded preview content of the vouchers document
         * @summary Returns the base64 encoded preview content of the vouchers document
         * @param {number} id Id of the voucher of which you want to get the document image
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetDocumentImage(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherGetDocumentImage(id, options)(fetch, basePath);
        },
        /**
         * Calls Voucher.php to get necessary variables.
         * @summary Get an overview of all vouchers
         * @param {number} id Id of the voucher you want to update
         * @param {boolean} showTotalSum Define if you want to have the total sum of each tax group
         * @param {boolean} withCorrections Define if you want to have the total sum with corrections
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherGetTaxGroups(id: number, showTotalSum: boolean, withCorrections: boolean, options?: any) {
            return VoucherApiFp(configuration).voucherGetTaxGroups(id, showTotalSum, withCorrections, options)(fetch, basePath);
        },
        /**
         * Mark the specified voucher as open
         * @summary Mark a specified voucher as open
         * @param {number} id Id of the voucher you want to mark as open
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherMarkAsOpen(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherMarkAsOpen(id, options)(fetch, basePath);
        },
        /**
         * Mark the specified voucher as paid
         * @summary Mark a specified voucher as paid
         * @param {number} id Id of the voucher you want to mark as paid
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherMarkAsPaid(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherMarkAsPaid(id, options)(fetch, basePath);
        },
        /**
         * Refund an amount for the specified voucher
         * @summary Refund an amount for a specified voucher
         * @param {number} id Id of the voucher for which you want to refund an amount
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherRefundAmount(id: number, options?: any) {
            return VoucherApiFp(configuration).voucherRefundAmount(id, options)(fetch, basePath);
        },
        /**
         * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
         * @summary Upload a temporary file to be used later
         * @param {Blob} file 
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherUploadTempFile(file: Blob, options?: any) {
            return VoucherApiFp(configuration).voucherUploadTempFile(file, options)(fetch, basePath);
        },
    };
};

/**
 * VoucherApi - object-oriented interface
 * @export
 * @class VoucherApi
 * @extends {BaseAPI}
 */
export class VoucherApi extends BaseAPI {
    /**
     * Calls Voucher.php to create a voucher
     * @summary Create a new voucher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public addVoucher(options?: any) {
        return VoucherApiFp(this.configuration).addVoucher(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in Voucher.php
     * @summary Delete an existing voucher
     * @param {number} id Id of voucher you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public deleteVoucher(id: number, options?: any) {
        return VoucherApiFp(this.configuration).deleteVoucher(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Voucher.php to get necessary variables.
     * @summary Get an overview of all vouchers
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned vouchers start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public getVouchers(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return VoucherApiFp(this.configuration).getVouchers(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
     * @summary Create a new voucher
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public saveVoucher(options?: any) {
        return VoucherApiFp(this.configuration).saveVoucher(options)(this.fetch, this.basePath);
    }

    /**
     * Calls Voucher.php to update an existing voucher
     * @summary Update an existing voucher
     * @param {number} id Id of the voucher you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public updateVoucher(id: number, options?: any) {
        return VoucherApiFp(this.configuration).updateVoucher(id, options)(this.fetch, this.basePath);
    }

    /**
     * Book an amount for the specified voucher
     * @summary Book an amount for a specified voucher
     * @param {number} id Id of the voucher for which you want to book an amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherBookAmount(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherBookAmount(id, options)(this.fetch, this.basePath);
    }

    /**
     * Change the status of the specified voucher
     * @summary Change status of a specified voucher
     * @param {number} id Id of the voucher of which you want to change the status
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherChangeStatus(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherChangeStatus(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls the deleteDocument() function in Voucher.php to delete the document of an existing voucher
     * @summary Delete the document of an existing voucher
     * @param {number} id Id of the voucher of which you want to delete the document
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherDeleteDocument(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherDeleteDocument(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls extractThumb() in Voucher/Factory.php to extract the thumb of the specified file
     * @summary Extract file thumb
     * @param {string} [fileName] Name of the file of which you want to extract the thumb
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherExtractThumb(fileName?: string, options?: any) {
        return VoucherApiFp(this.configuration).voucherExtractThumb(fileName, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAccountingTypes() in Voucher.php to get the accounting types of the specified voucher
     * @summary Get the accounting types of a specified voucher
     * @param {number} id Id of the voucher of which you want to get the accounting types
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetAccountingTypes(id: number, embed?: Array<string>, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetAccountingTypes(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCheckAccountTransactionLogs() in Voucher.php to get the check account transaction logs of the specified voucher
     * @summary Get the check account transaction logs of a specified voucher
     * @param {number} id Id of the voucher of which you want to get the check account transaction logs
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetCheckAccountTransactionLogs(id: number, embed?: Array<string>, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetCheckAccountTransactionLogs(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCheckAccountTransactions() in Voucher.php to get the check account transactions of the specified voucher
     * @summary Get the check account transactions of a specified voucher
     * @param {number} id Id of the voucher of which you want to get the check account transactions
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetCheckAccountTransactions(id: number, embed?: Array<string>, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetCheckAccountTransactions(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getCurrency() in Voucher.php to get the currency of the specified voucher
     * @summary Get the currency of a specified voucher
     * @param {number} id Id of the voucher of which you want to get the currency
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetCurrency(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetCurrency(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDebit() in Voucher.php to get the unpaid amount of a specified voucher
     * @summary Get unpaid amount of a specified voucher
     * @param {number} id Id of the voucher of which you want to get the unpaid amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetDebit(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetDebit(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDelinquent() in Voucher.php to get if the voucher is delinquent
     * @summary Return if the voucher is delinquent
     * @param {number} id Id of the voucher of which you want to know if it is delinquent
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetDelinquent(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetDelinquent(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDependingRecurringVouchers() in Voucher.php to get the depending recurring vouchers of the specified origin voucher
     * @summary Get the depending recurring vouchers of a specified origin voucher
     * @param {number} id Id of the voucher of which you want to get the depending recurring vouchers
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetDependingRecurringVouchers(id: number, embed?: Array<string>, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetDependingRecurringVouchers(id, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getDocumentImage() in Voucher.php to return the base64 encoded preview content of the vouchers document
     * @summary Returns the base64 encoded preview content of the vouchers document
     * @param {number} id Id of the voucher of which you want to get the document image
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetDocumentImage(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetDocumentImage(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls Voucher.php to get necessary variables.
     * @summary Get an overview of all vouchers
     * @param {number} id Id of the voucher you want to update
     * @param {boolean} showTotalSum Define if you want to have the total sum of each tax group
     * @param {boolean} withCorrections Define if you want to have the total sum with corrections
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherGetTaxGroups(id: number, showTotalSum: boolean, withCorrections: boolean, options?: any) {
        return VoucherApiFp(this.configuration).voucherGetTaxGroups(id, showTotalSum, withCorrections, options)(this.fetch, this.basePath);
    }

    /**
     * Mark the specified voucher as open
     * @summary Mark a specified voucher as open
     * @param {number} id Id of the voucher you want to mark as open
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherMarkAsOpen(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherMarkAsOpen(id, options)(this.fetch, this.basePath);
    }

    /**
     * Mark the specified voucher as paid
     * @summary Mark a specified voucher as paid
     * @param {number} id Id of the voucher you want to mark as paid
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherMarkAsPaid(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherMarkAsPaid(id, options)(this.fetch, this.basePath);
    }

    /**
     * Refund an amount for the specified voucher
     * @summary Refund an amount for a specified voucher
     * @param {number} id Id of the voucher for which you want to refund an amount
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherRefundAmount(id: number, options?: any) {
        return VoucherApiFp(this.configuration).voucherRefundAmount(id, options)(this.fetch, this.basePath);
    }

    /**
     * With the new version of sevdesk some models are not created by calling the Model.php directly but by calling the Factory.php because of better performance and flexibility.    Basically the model.php itself still constructs the model however new instances of the model are created trough the factory.php    So for example when you create a new voucher it wont be saved by a POST request with '/Voucher?para1=&...' but with the saveVoucher function in Factory.php 'Voucher/Factory/saveVoucher?para1='
     * @summary Upload a temporary file to be used later
     * @param {Blob} file 
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherApi
     */
    public voucherUploadTempFile(file: Blob, options?: any) {
        return VoucherApiFp(this.configuration).voucherUploadTempFile(file, options)(this.fetch, this.basePath);
    }

}
/**
 * VoucherLogApi - fetch parameter creator
 * @export
 */
export const VoucherLogApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls VoucherLog.php to create a voucher log entry
         * @summary Create a new voucher log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucherLogEntry(options: any = {}): FetchArgs {
            const localVarPath = `/VoucherLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in VoucherLog.php to delete a voucher log entry
         * @summary Delete an existing voucher log entry
         * @param {number} id Id of voucher log entry you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucherLogEntry(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteVoucherLogEntry.');
            }
            const localVarPath = `/VoucherLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls VoucherLog.php to get necessary variables.
         * @summary Get an overview of all voucher log entries
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned voucher log entries start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherLog(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/VoucherLog`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls VoucherLog.php to update an existing voucher log entry
         * @summary Update an existing voucher log entry
         * @param {number} id Id of the voucher log entry you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherLogEntry(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateVoucherLogEntry.');
            }
            const localVarPath = `/VoucherLog/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoucherLogApi - functional programming interface
 * @export
 */
export const VoucherLogApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls VoucherLog.php to create a voucher log entry
         * @summary Create a new voucher log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucherLogEntry(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherLog> {
            const localVarFetchArgs = VoucherLogApiFetchParamCreator(configuration).addVoucherLogEntry(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in VoucherLog.php to delete a voucher log entry
         * @summary Delete an existing voucher log entry
         * @param {number} id Id of voucher log entry you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucherLogEntry(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherLogApiFetchParamCreator(configuration).deleteVoucherLogEntry(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls VoucherLog.php to get necessary variables.
         * @summary Get an overview of all voucher log entries
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned voucher log entries start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherLog(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherLog> {
            const localVarFetchArgs = VoucherLogApiFetchParamCreator(configuration).getVoucherLog(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls VoucherLog.php to update an existing voucher log entry
         * @summary Update an existing voucher log entry
         * @param {number} id Id of the voucher log entry you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherLogEntry(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherLog> {
            const localVarFetchArgs = VoucherLogApiFetchParamCreator(configuration).updateVoucherLogEntry(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VoucherLogApi - factory interface
 * @export
 */
export const VoucherLogApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls VoucherLog.php to create a voucher log entry
         * @summary Create a new voucher log entry
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucherLogEntry(options?: any) {
            return VoucherLogApiFp(configuration).addVoucherLogEntry(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in VoucherLog.php to delete a voucher log entry
         * @summary Delete an existing voucher log entry
         * @param {number} id Id of voucher log entry you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucherLogEntry(id: number, options?: any) {
            return VoucherLogApiFp(configuration).deleteVoucherLogEntry(id, options)(fetch, basePath);
        },
        /**
         * Calls VoucherLog.php to get necessary variables.
         * @summary Get an overview of all voucher log entries
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned voucher log entries start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherLog(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return VoucherLogApiFp(configuration).getVoucherLog(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls VoucherLog.php to update an existing voucher log entry
         * @summary Update an existing voucher log entry
         * @param {number} id Id of the voucher log entry you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherLogEntry(id: number, options?: any) {
            return VoucherLogApiFp(configuration).updateVoucherLogEntry(id, options)(fetch, basePath);
        },
    };
};

/**
 * VoucherLogApi - object-oriented interface
 * @export
 * @class VoucherLogApi
 * @extends {BaseAPI}
 */
export class VoucherLogApi extends BaseAPI {
    /**
     * Calls VoucherLog.php to create a voucher log entry
     * @summary Create a new voucher log entry
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherLogApi
     */
    public addVoucherLogEntry(options?: any) {
        return VoucherLogApiFp(this.configuration).addVoucherLogEntry(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in VoucherLog.php to delete a voucher log entry
     * @summary Delete an existing voucher log entry
     * @param {number} id Id of voucher log entry you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherLogApi
     */
    public deleteVoucherLogEntry(id: number, options?: any) {
        return VoucherLogApiFp(this.configuration).deleteVoucherLogEntry(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls VoucherLog.php to get necessary variables.
     * @summary Get an overview of all voucher log entries
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned voucher log entries start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherLogApi
     */
    public getVoucherLog(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return VoucherLogApiFp(this.configuration).getVoucherLog(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls VoucherLog.php to update an existing voucher log entry
     * @summary Update an existing voucher log entry
     * @param {number} id Id of the voucher log entry you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherLogApi
     */
    public updateVoucherLogEntry(id: number, options?: any) {
        return VoucherLogApiFp(this.configuration).updateVoucherLogEntry(id, options)(this.fetch, this.basePath);
    }

}
/**
 * VoucherPosApi - fetch parameter creator
 * @export
 */
export const VoucherPosApiFetchParamCreator = function (configuration?: Configuration) {
    return {
        /**
         * Calls VoucherPos.php to create a voucher position
         * @summary Create a new voucher position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucherPos(options: any = {}): FetchArgs {
            const localVarPath = `/VoucherPos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'POST' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls the delete() function in VoucherPos.php to delete a voucher position
         * @summary Delete an existing voucher position
         * @param {number} id Id of voucher position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucherPos(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling deleteVoucherPos.');
            }
            const localVarPath = `/VoucherPos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'DELETE' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls VoucherPos.php to get necessary variables.
         * @summary Get an overview of all voucher positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned voucher positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherPositions(limit?: number, offset?: number, embed?: Array<string>, options: any = {}): FetchArgs {
            const localVarPath = `/VoucherPos`;
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            if (limit !== undefined) {
                localVarQueryParameter['limit'] = limit;
            }

            if (offset !== undefined) {
                localVarQueryParameter['offset'] = offset;
            }

            if (embed) {
                localVarQueryParameter['embed'] = embed.join(COLLECTION_FORMATS["csv"]);
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls VoucherPos.php to update an existing voucher position
         * @summary Update an existing voucher position
         * @param {number} id Id of the voucher position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherPos(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling updateVoucherPos.');
            }
            const localVarPath = `/VoucherPos/{id}`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'PUT' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAdditionalInformation() in VoucherPos.php to get additional information about the asset which is connected to the specified voucher position
         * @summary Get additional information about the asset which is connected to a specified voucher position
         * @param {number} id Id of the voucher position of which you want to get additional information about the connected asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherPosGetAdditionalInformation(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherPosGetAdditionalInformation.');
            }
            const localVarPath = `/VoucherPos/{id}/getAdditionalInfo`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
        /**
         * Calls getAssetInstance() in VoucherPos.php to get the asset which is connected to the specified voucher position
         * @summary Get the asset which is connected to a specified voucher position
         * @param {number} id Id of the voucher position of which you want to get the connected asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherPosGetAssetInstance(id: number, options: any = {}): FetchArgs {
            // verify required parameter 'id' is not null or undefined
            if (id === null || id === undefined) {
                throw new RequiredError('id','Required parameter id was null or undefined when calling voucherPosGetAssetInstance.');
            }
            const localVarPath = `/VoucherPos/{id}/getAssetInstance`
                .replace(`{${"id"}}`, encodeURIComponent(String(id)));
            const localVarUrlObj = url.parse(localVarPath, true);
            const localVarRequestOptions = Object.assign({ method: 'GET' }, options);
            const localVarHeaderParameter = {} as any;
            const localVarQueryParameter = {} as any;

            // authentication api_key required
            if (configuration && configuration.apiKey) {
                const localVarApiKeyValue = typeof configuration.apiKey === 'function'
					? configuration.apiKey("token")
					: configuration.apiKey;
                localVarQueryParameter["token"] = localVarApiKeyValue;
            }

            localVarUrlObj.query = Object.assign({}, localVarUrlObj.query, localVarQueryParameter, options.query);
            // fix override query string Detail: https://stackoverflow.com/a/7517673/1077943
            delete localVarUrlObj.search;
            localVarRequestOptions.headers = Object.assign({}, localVarHeaderParameter, options.headers);

            return {
                url: url.format(localVarUrlObj),
                options: localVarRequestOptions,
            };
        },
    }
};

/**
 * VoucherPosApi - functional programming interface
 * @export
 */
export const VoucherPosApiFp = function(configuration?: Configuration) {
    return {
        /**
         * Calls VoucherPos.php to create a voucher position
         * @summary Create a new voucher position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucherPos(options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherPos> {
            const localVarFetchArgs = VoucherPosApiFetchParamCreator(configuration).addVoucherPos(options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls the delete() function in VoucherPos.php to delete a voucher position
         * @summary Delete an existing voucher position
         * @param {number} id Id of voucher position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucherPos(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherPosApiFetchParamCreator(configuration).deleteVoucherPos(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls VoucherPos.php to get necessary variables.
         * @summary Get an overview of all voucher positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned voucher positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherPos> {
            const localVarFetchArgs = VoucherPosApiFetchParamCreator(configuration).getVoucherPositions(limit, offset, embed, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls VoucherPos.php to update an existing voucher position
         * @summary Update an existing voucher position
         * @param {number} id Id of the voucher position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherPos(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelVoucherPos> {
            const localVarFetchArgs = VoucherPosApiFetchParamCreator(configuration).updateVoucherPos(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAdditionalInformation() in VoucherPos.php to get additional information about the asset which is connected to the specified voucher position
         * @summary Get additional information about the asset which is connected to a specified voucher position
         * @param {number} id Id of the voucher position of which you want to get additional information about the connected asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherPosGetAdditionalInformation(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<Response> {
            const localVarFetchArgs = VoucherPosApiFetchParamCreator(configuration).voucherPosGetAdditionalInformation(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response;
                    } else {
                        throw response;
                    }
                });
            };
        },
        /**
         * Calls getAssetInstance() in VoucherPos.php to get the asset which is connected to the specified voucher position
         * @summary Get the asset which is connected to a specified voucher position
         * @param {number} id Id of the voucher position of which you want to get the connected asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherPosGetAssetInstance(id: number, options?: any): (fetch?: FetchAPI, basePath?: string) => Promise<ModelAsset> {
            const localVarFetchArgs = VoucherPosApiFetchParamCreator(configuration).voucherPosGetAssetInstance(id, options);
            return (fetch: FetchAPI = isomorphicFetch, basePath: string = BASE_PATH) => {
                return fetch(basePath + localVarFetchArgs.url, localVarFetchArgs.options).then((response) => {
                    if (response.status >= 200 && response.status < 300) {
                        return response.json();
                    } else {
                        throw response;
                    }
                });
            };
        },
    }
};

/**
 * VoucherPosApi - factory interface
 * @export
 */
export const VoucherPosApiFactory = function (configuration?: Configuration, fetch?: FetchAPI, basePath?: string) {
    return {
        /**
         * Calls VoucherPos.php to create a voucher position
         * @summary Create a new voucher position
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        addVoucherPos(options?: any) {
            return VoucherPosApiFp(configuration).addVoucherPos(options)(fetch, basePath);
        },
        /**
         * Calls the delete() function in VoucherPos.php to delete a voucher position
         * @summary Delete an existing voucher position
         * @param {number} id Id of voucher position you want to delete
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        deleteVoucherPos(id: number, options?: any) {
            return VoucherPosApiFp(configuration).deleteVoucherPos(id, options)(fetch, basePath);
        },
        /**
         * Calls VoucherPos.php to get necessary variables.
         * @summary Get an overview of all voucher positions
         * @param {number} [limit] Limits the number of entries returned. Default is 100
         * @param {number} [offset] Set the index where the returned voucher positions start. Default is 0
         * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        getVoucherPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
            return VoucherPosApiFp(configuration).getVoucherPositions(limit, offset, embed, options)(fetch, basePath);
        },
        /**
         * Calls VoucherPos.php to update an existing voucher position
         * @summary Update an existing voucher position
         * @param {number} id Id of the voucher position you want to update
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        updateVoucherPos(id: number, options?: any) {
            return VoucherPosApiFp(configuration).updateVoucherPos(id, options)(fetch, basePath);
        },
        /**
         * Calls getAdditionalInformation() in VoucherPos.php to get additional information about the asset which is connected to the specified voucher position
         * @summary Get additional information about the asset which is connected to a specified voucher position
         * @param {number} id Id of the voucher position of which you want to get additional information about the connected asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherPosGetAdditionalInformation(id: number, options?: any) {
            return VoucherPosApiFp(configuration).voucherPosGetAdditionalInformation(id, options)(fetch, basePath);
        },
        /**
         * Calls getAssetInstance() in VoucherPos.php to get the asset which is connected to the specified voucher position
         * @summary Get the asset which is connected to a specified voucher position
         * @param {number} id Id of the voucher position of which you want to get the connected asset
         * @param {*} [options] Override http request option.
         * @throws {RequiredError}
         */
        voucherPosGetAssetInstance(id: number, options?: any) {
            return VoucherPosApiFp(configuration).voucherPosGetAssetInstance(id, options)(fetch, basePath);
        },
    };
};

/**
 * VoucherPosApi - object-oriented interface
 * @export
 * @class VoucherPosApi
 * @extends {BaseAPI}
 */
export class VoucherPosApi extends BaseAPI {
    /**
     * Calls VoucherPos.php to create a voucher position
     * @summary Create a new voucher position
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherPosApi
     */
    public addVoucherPos(options?: any) {
        return VoucherPosApiFp(this.configuration).addVoucherPos(options)(this.fetch, this.basePath);
    }

    /**
     * Calls the delete() function in VoucherPos.php to delete a voucher position
     * @summary Delete an existing voucher position
     * @param {number} id Id of voucher position you want to delete
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherPosApi
     */
    public deleteVoucherPos(id: number, options?: any) {
        return VoucherPosApiFp(this.configuration).deleteVoucherPos(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls VoucherPos.php to get necessary variables.
     * @summary Get an overview of all voucher positions
     * @param {number} [limit] Limits the number of entries returned. Default is 100
     * @param {number} [offset] Set the index where the returned voucher positions start. Default is 0
     * @param {Array<string>} [embed] Get some additional information. Embed can handle multiple values, they must be separated by comma. Default &#x60;&#x60;.
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherPosApi
     */
    public getVoucherPositions(limit?: number, offset?: number, embed?: Array<string>, options?: any) {
        return VoucherPosApiFp(this.configuration).getVoucherPositions(limit, offset, embed, options)(this.fetch, this.basePath);
    }

    /**
     * Calls VoucherPos.php to update an existing voucher position
     * @summary Update an existing voucher position
     * @param {number} id Id of the voucher position you want to update
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherPosApi
     */
    public updateVoucherPos(id: number, options?: any) {
        return VoucherPosApiFp(this.configuration).updateVoucherPos(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAdditionalInformation() in VoucherPos.php to get additional information about the asset which is connected to the specified voucher position
     * @summary Get additional information about the asset which is connected to a specified voucher position
     * @param {number} id Id of the voucher position of which you want to get additional information about the connected asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherPosApi
     */
    public voucherPosGetAdditionalInformation(id: number, options?: any) {
        return VoucherPosApiFp(this.configuration).voucherPosGetAdditionalInformation(id, options)(this.fetch, this.basePath);
    }

    /**
     * Calls getAssetInstance() in VoucherPos.php to get the asset which is connected to the specified voucher position
     * @summary Get the asset which is connected to a specified voucher position
     * @param {number} id Id of the voucher position of which you want to get the connected asset
     * @param {*} [options] Override http request option.
     * @throws {RequiredError}
     * @memberof VoucherPosApi
     */
    public voucherPosGetAssetInstance(id: number, options?: any) {
        return VoucherPosApiFp(this.configuration).voucherPosGetAssetInstance(id, options)(this.fetch, this.basePath);
    }

}
